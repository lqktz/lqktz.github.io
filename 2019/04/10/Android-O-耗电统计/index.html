<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android O电量统计"><meta name="keywords" content="Android"><meta name="author" content="Michael"><meta name="copyright" content="Michael"><title>Android O电量统计 | Michael Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#电量统计"><span class="toc-text">电量统计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BatteryStatsHelper-java–-gt-processAppUsage"><span class="toc-text">BatteryStatsHelper.java–&gt;processAppUsage()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1cpu耗电计算"><span class="toc-text">1.1cpu耗电计算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-wakeup耗电统计"><span class="toc-text">1.2 wakeup耗电统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-radio耗电统计"><span class="toc-text">1.3 radio耗电统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-wifi-耗电"><span class="toc-text">1.4 wifi 耗电</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#WifiPowerCalculator"><span class="toc-text">WifiPowerCalculator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WifiPowerEstimator"><span class="toc-text">WifiPowerEstimator</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-bluetooth耗电统计"><span class="toc-text">1.5 bluetooth耗电统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-传感器耗电"><span class="toc-text">1.6 传感器耗电</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-Camera耗电统计"><span class="toc-text">1.7 Camera耗电统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-Flashlight耗电统计"><span class="toc-text">1.8 Flashlight耗电统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-OS耗电"><span class="toc-text">1.9 OS耗电</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-硬件电量统计"><span class="toc-text">2 硬件电量统计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BatteryStatsHelper-java–-gt-processMiscUsage"><span class="toc-text">BatteryStatsHelper.java–&gt;processMiscUsage()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-user耗电统计"><span class="toc-text">2.1 user耗电统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Phone耗电统计"><span class="toc-text">2.2 Phone耗电统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-屏幕耗电统计"><span class="toc-text">2.3 屏幕耗电统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-wifi耗电统计"><span class="toc-text">2.4 wifi耗电统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-蓝牙耗电统计"><span class="toc-text">2.5 蓝牙耗电统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-内存耗电统计"><span class="toc-text">2.6 内存耗电统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-手机空闲耗电统计"><span class="toc-text">2.7 手机空闲耗电统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-Radio耗电统计"><span class="toc-text">2.8 Radio耗电统计</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars2.githubusercontent.com/u/15813289?s=460&amp;v=4"></div><div class="author-info__name text-center">Michael</div><div class="author-info__description text-center">Android性能优化</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">18</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Michael Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">目录</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Android O电量统计</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/android/"> android</a></div><div class="article-container" id="post-content"><p>#Android O电量统计</p>
<p>平台:Android O</p>
<hr>
<h2 id="电量统计"><a href="#电量统计" class="headerlink" title="电量统计"></a>电量统计</h2><p>电池电量统计:  </p>
<ul>
<li>软件电量计算:BatteryStatsHelper类中的processAppUsage()方法  </li>
<li>硬件电量计算:BatteryStatsHelper类中的processMiscUsage()方法  </li>
</ul>
<hr>
<p><code>frameworks/base/core/java/com/android/internal/os/BatteryStatsHelper.java</code><br><code>framework/base/core/java/com/andoroid/internal/os/PowerProfile.java</code><br><code>device/mediateksample/a3a64g/overlay/frameworks/base/core/res/res/xml/power_profile.xml</code><br><code>frameworks/base/core/java/com/android/internal/os/CpuPowerCalculator.java</code><br><code>frameworks/base/core/java/com/android/internal/os/WakelockPowerCalculator.java</code><br><code>frameworks/base/core/java/com/android/internal/os/MobileRadioPowerCalculator.java</code><br><code>frameworks/base/core/java/com/android/internal/os/WifiPowerCalculator.java</code><br><code>frameworks/base/core/java/com/android/internal/os/WifiPowerEstimator.java</code><br><code>frameworks/base/core/java/com/android/internal/os/BluetoothPowerCalculator.java</code><br><code>frameworks/base/core/java/com/android/internal/os/SensorPowerCalculator.java</code><br><code>frameworks/base/core/java/com/android/internal/os/CameraPowerCalculator.java</code><br><code>frameworks/base/core/java/com/android/internal/os/FlashlightPowerCalculator.java</code>  </p>
<hr>
<p>耗电类型:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DrainType &#123;</span><br><span class="line">    IDLE,</span><br><span class="line">    CELL,</span><br><span class="line">    PHONE,</span><br><span class="line">    WIFI,</span><br><span class="line">    BLUETOOTH,</span><br><span class="line">    FLASHLIGHT,</span><br><span class="line">    SCREEN,</span><br><span class="line">    APP,</span><br><span class="line">    USER,</span><br><span class="line">    UNACCOUNTED,</span><br><span class="line">    OVERCOUNTED,</span><br><span class="line">    CAMERA,</span><br><span class="line">    MEMORY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###1 软件电量统计<br>软件的耗电,都属于上面分类的APP类别  </p>
<h4 id="BatteryStatsHelper-java–-gt-processAppUsage"><a href="#BatteryStatsHelper-java–-gt-processAppUsage" class="headerlink" title="BatteryStatsHelper.java–&gt;processAppUsage()"></a>BatteryStatsHelper.java–&gt;processAppUsage()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processAppUsage</span><span class="params">(SparseArray&lt;UserHandle&gt; asUsers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对所有用户进行统计?</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> forAllUsers = (asUsers.get(UserHandle.USER_ALL) != <span class="keyword">null</span>);</span><br><span class="line">    mStatsPeriod = mTypeBatteryRealtimeUs;</span><br><span class="line"></span><br><span class="line">    BatterySipper osSipper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取每一个uid的统计信息</span></span><br><span class="line">    <span class="keyword">final</span> SparseArray&lt;? extends Uid&gt; uidStats = mStats.getUidStats();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NU = uidStats.size();</span><br><span class="line">    <span class="comment">// 遍历每个uid的耗电</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iu = <span class="number">0</span>; iu &lt; NU; iu++) &#123;</span><br><span class="line">        <span class="keyword">final</span> Uid u = uidStats.valueAt(iu);</span><br><span class="line">        <span class="comment">// 统计归属于BatterySipper.DrainType.APP类别</span></span><br><span class="line">        <span class="keyword">final</span> BatterySipper app = <span class="keyword">new</span> BatterySipper(BatterySipper.DrainType.APP, u, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        mCpuPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">        mWakelockPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">        mMobileRadioPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">                mStatsType);</span><br><span class="line">        mWifiPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">        mBluetoothPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">                mStatsType);</span><br><span class="line">        mSensorPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">        mCameraPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">        mFlashlightPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">                mStatsType);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> totalPower = app.sumPower();<span class="comment">// 耗电累加</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG &amp;&amp; totalPower != <span class="number">0</span>) &#123;</span><br><span class="line">            Log.d(TAG, String.format(<span class="string">"UID %d: total power=%s"</span>, u.getUid(),</span><br><span class="line">                    makemAh(totalPower)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时耗电统计已经完成,只是为了将数据分类统计.</span></span><br><span class="line">        <span class="comment">// Add the app to the list if it is consuming power.</span></span><br><span class="line">        <span class="keyword">if</span> (totalPower != <span class="number">0</span> || u.getUid() == <span class="number">0</span>) &#123;<span class="comment">//有耗电去统计,</span></span><br><span class="line">            <span class="comment">// Add the app to the app list, WiFi, Bluetooth, etc, or into "Other Users" list.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> uid = app.getUid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(uid);</span><br><span class="line">            <span class="keyword">if</span> (uid == Process.WIFI_UID) &#123;<span class="comment">// mWifiSippers保存使用了wifi的app及其对应的功耗</span></span><br><span class="line">                mWifiSippers.add(app);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (uid == Process.BLUETOOTH_UID) &#123;<span class="comment">// mBluetoothSippers保存使用了Bluetooth的app及其对应的功耗</span></span><br><span class="line">                mBluetoothSippers.add(app);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!forAllUsers &amp;&amp; asUsers.get(userId) == <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; UserHandle.getAppId(uid) &gt;= Process.FIRST_APPLICATION_UID) &#123;</span><br><span class="line">                <span class="comment">// We are told to just report this user's apps as one large entry.</span></span><br><span class="line">                List&lt;BatterySipper&gt; list = mUserSippers.get(userId);</span><br><span class="line">                <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    mUserSippers.put(userId, list);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(app);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mUsageList.add(app);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uid == <span class="number">0</span>) &#123;<span class="comment">// 如果这次统计的是OS的耗电,那么初始化变量osSipper</span></span><br><span class="line">                osSipper = app;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// osSipper被初始化过,也就是上面统计的uid里面有系统的uid,下面把系统的耗电累加起来</span></span><br><span class="line">    <span class="keyword">if</span> (osSipper != <span class="keyword">null</span>) &#123;<span class="comment">// 长时间cpu唤醒,但是屏幕没有亮,该部分的耗算入OS耗电</span></span><br><span class="line">        <span class="comment">// The device has probably been awake for longer than the screen on</span></span><br><span class="line">        <span class="comment">// time and application wake lock time would account for.  Assign</span></span><br><span class="line">        <span class="comment">// this remainder to the OS, if possible.</span></span><br><span class="line">        mWakelockPowerCalculator.calculateRemaining(osSipper, mStats, mRawRealtimeUs,</span><br><span class="line">                mRawUptimeUs, mStatsType);</span><br><span class="line">        <span class="comment">// OS耗电求和</span></span><br><span class="line">        osSipper.sumPower();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中mStatsType 定义为:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mStatsType = BatteryStats.STATS_SINCE_CHARGED;</span><br></pre></td></tr></table></figure></p>
<p>表明是从上次充满电算起,实测中表明,充满电要拔掉充电线才清零开始算.<br>mStatsType的状态有三种,下面的定义来自BatteryStats.java<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Include all of the data in the stats, including previously saved data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATS_SINCE_CHARGED = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Include only the current run in the stats.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATS_CURRENT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Include only the run since the last time the device was unplugged in the stats.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATS_SINCE_UNPLUGGED = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="1-1cpu耗电计算"><a href="#1-1cpu耗电计算" class="headerlink" title="1.1cpu耗电计算"></a>1.1cpu耗电计算</h5><p><code>frameworks/base/core/java/com/android/internal/os/CpuPowerCalculator.java</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    app.cpuTimeMs = (u.getUserCpuTimeUs(statsType) + u.getSystemCpuTimeUs(statsType)) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Aggregate total time spent on each cluster.</span></span><br><span class="line">    <span class="keyword">long</span> totalTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numClusters = mProfile.getNumCpuClusters();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cluster = <span class="number">0</span>; cluster &lt; numClusters; cluster++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> speedsForCluster = mProfile.getNumSpeedStepsInCpuCluster(cluster);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> speed = <span class="number">0</span>; speed &lt; speedsForCluster; speed++) &#123;</span><br><span class="line">            totalTime += u.getTimeAtCpuSpeed(cluster, speed, statsType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    totalTime = Math.max(totalTime, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> cpuPowerMaMs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cluster = <span class="number">0</span>; cluster &lt; numClusters; cluster++) &#123;<span class="comment">//cluster是指cpu的簇数量,在电池配置文件中有(1)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> speedsForCluster = mProfile.getNumSpeedStepsInCpuCluster(cluster);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> speed = <span class="number">0</span>; speed &lt; speedsForCluster; speed++) &#123;<span class="comment">//speed值cpu的频点数(8)</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">double</span> ratio = (<span class="keyword">double</span>) u.getTimeAtCpuSpeed(cluster, speed, statsType) /</span><br><span class="line">                    totalTime;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">double</span> cpuSpeedStepPower = ratio * app.cpuTimeMs *</span><br><span class="line">                    mProfile.getAveragePowerForCpu(cluster, speed);<span class="comment">//不同cpu频率的单位耗电在电池配置文件中</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG &amp;&amp; ratio != <span class="number">0</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": CPU cluster #"</span> + cluster + <span class="string">" step #"</span></span><br><span class="line">                        + speed + <span class="string">" ratio="</span> + BatteryStatsHelper.makemAh(ratio) + <span class="string">" power="</span></span><br><span class="line">                        + BatteryStatsHelper.makemAh(cpuSpeedStepPower / (<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            cpuPowerMaMs += cpuSpeedStepPower;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存cpu的耗电</span></span><br><span class="line">    app.cpuPowerMah = cpuPowerMaMs / (<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; (app.cpuTimeMs != <span class="number">0</span> || app.cpuPowerMah != <span class="number">0</span>)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": CPU time="</span> + app.cpuTimeMs + <span class="string">" ms power="</span></span><br><span class="line">                + BatteryStatsHelper.makemAh(app.cpuPowerMah));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep track of the package with highest drain.</span></span><br><span class="line">    <span class="keyword">double</span> highestDrain = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    app.cpuFgTimeMs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> ArrayMap&lt;String, ? extends BatteryStats.Uid.Proc&gt; processStats = u.getProcessStats();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> processStatsCount = processStats.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; processStatsCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> BatteryStats.Uid.Proc ps = processStats.valueAt(i);</span><br><span class="line">        <span class="keyword">final</span> String processName = processStats.keyAt(i);</span><br><span class="line">        app.cpuFgTimeMs += ps.getForegroundTime(statsType);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> costValue = ps.getUserTime(statsType) + ps.getSystemTime(statsType)</span><br><span class="line">                + ps.getForegroundTime(statsType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Each App can have multiple packages and with multiple running processes.</span></span><br><span class="line">        <span class="comment">// Keep track of the package who's process has the highest drain.</span></span><br><span class="line">        <span class="keyword">if</span> (app.packageWithHighestDrain == <span class="keyword">null</span> ||</span><br><span class="line">                app.packageWithHighestDrain.startsWith(<span class="string">"*"</span>)) &#123;</span><br><span class="line">            highestDrain = costValue;</span><br><span class="line">            app.packageWithHighestDrain = processName;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (highestDrain &lt; costValue &amp;&amp; !processName.startsWith(<span class="string">"*"</span>)) &#123;</span><br><span class="line">            highestDrain = costValue;</span><br><span class="line">            app.packageWithHighestDrain = processName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that the CPU times make sense.</span></span><br><span class="line">    <span class="keyword">if</span> (app.cpuFgTimeMs &gt; app.cpuTimeMs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG &amp;&amp; app.cpuFgTimeMs &gt; app.cpuTimeMs + <span class="number">10000</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"WARNING! Cputime is more than 10 seconds behind Foreground time"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Statistics may not have been gathered yet.</span></span><br><span class="line">        app.cpuTimeMs = app.cpuFgTimeMs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于4g项目中的电池配置文件:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">array</span> <span class="attr">name</span>=<span class="string">"cpu.clusters.cores"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span> <span class="attr">name</span>=<span class="string">"cpu.speeds.cluster0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>299000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>442000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>598000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>819000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1040000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1170000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1300000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1443000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span> <span class="attr">name</span>=<span class="string">"cpu.active.cluster0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>90.1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>110.2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>130.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>160.4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>190.5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>220.6<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>250.7<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>280.8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"cpu.idle"</span>&gt;</span>4.8<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"cpu.awake"</span>&gt;</span>21.1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>cpu耗电的计算公式:<br>cpuPower = ratio_1 <em> cpu_time </em> cpu_ratio_1_power + … +ratio_n <em> cpu_time </em> cpu_ratio_n_power<br>其中： ratio_i = cpu_speed_time/ cpu_speeds_total_time，（i=1,2,…,N，N为CPU频点个数）  </p>
<h4 id="1-2-wakeup耗电统计"><a href="#1-2-wakeup耗电统计" class="headerlink" title="1.2 wakeup耗电统计"></a>1.2 wakeup耗电统计</h4><p>统计唤醒机制导致的耗电<br>WakelockPowerCalculator-&gt;calculateApp()<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WakelockPowerCalculator</span><span class="params">(PowerProfile profile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从电源配置文件中获取cpu.awake的值</span></span><br><span class="line">    mPowerWakelock = profile.getAveragePower(PowerProfile.POWER_CPU_AWAKE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算app在cpu处于awake状态下的耗电量</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> wakeLockTimeUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> ArrayMap&lt;String, ? extends BatteryStats.Uid.Wakelock&gt; wakelockStats =</span><br><span class="line">            u.getWakelockStats();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒锁的状态的次数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> wakelockStatsCount = wakelockStats.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将每次唤醒中以PARTIAL_WAKE_LOCK方式唤醒的时间统计出来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wakelockStatsCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> BatteryStats.Uid.Wakelock wakelock = wakelockStats.valueAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only care about partial wake locks since full wake locks</span></span><br><span class="line">        <span class="comment">// are canceled when the user turns the screen off.</span></span><br><span class="line">        <span class="comment">// 只统计PARTIAL_WAKE_LOCK.长时间运行的后台服务，例如Service等</span></span><br><span class="line">        BatteryStats.Timer timer = wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);</span><br><span class="line">        <span class="keyword">if</span> (timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wakeLockTimeUs += timer.getTotalTimeLocked(rawRealtimeUs, statsType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间单位转换</span></span><br><span class="line">    app.wakeLockTimeMs = wakeLockTimeUs / <span class="number">1000</span>; <span class="comment">// convert to millis</span></span><br><span class="line">    mTotalAppWakelockTimeMs += app.wakeLockTimeMs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add cost of holding a wake lock.</span></span><br><span class="line">    <span class="comment">// 将计算的唤醒耗电保存</span></span><br><span class="line">    app.wakeLockPowerMah = (app.wakeLockTimeMs * mPowerWakelock) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; app.wakeLockPowerMah != <span class="number">0</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": wake "</span> + app.wakeLockTimeMs</span><br><span class="line">                + <span class="string">" power="</span> + BatteryStatsHelper.makemAh(app.wakeLockPowerMah));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 统计app之外的耗电量,长时间就是cpu被唤醒,但是屏幕没有亮的耗电,该部分的耗电会被算入OS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateRemaining</span><span class="params">(BatterySipper app, BatteryStats stats, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> wakeTimeMillis = stats.getBatteryUptime(rawUptimeUs) / <span class="number">1000</span>;<span class="comment">// 返回当前电池正常运行时间</span></span><br><span class="line">    <span class="comment">// 电池运行时间 - PARTIAL_WAKE_LOCK占用的时间 + 设备在运行,屏幕亮着的时间</span></span><br><span class="line">    wakeTimeMillis -= mTotalAppWakelockTimeMs</span><br><span class="line">            + (stats.getScreenOnTime(rawRealtimeUs, statsType) / <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (wakeTimeMillis &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果有未计算在内的耗电,添加到app.wakeLockPowerMah的耗电中</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> power = (wakeTimeMillis * mPowerWakelock) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"OS wakeLockTime "</span> + wakeTimeMillis + <span class="string">" power "</span></span><br><span class="line">                    + BatteryStatsHelper.makemAh(power));</span><br><span class="line">        &#125;</span><br><span class="line">        app.wakeLockTimeMs += wakeTimeMillis;</span><br><span class="line">        app.wakeLockPowerMah += power;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PowerProfile.POWER_CPU_AWAKE:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"cpu.awake"</span>&gt;</span>21.1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>计算公式:<br>app wakeLock耗电计算公式:<br>wakeLockPowerMah = (app.wakeLockTimeMs <em> mPowerWakelock) / (10006060);<br>OS wakeLock耗电计算公式:<br>power = (wakeTimeMillis </em> mPowerWakelock) / (1000<em>60</em>60);  </p>
<p>其中: wakeTimeMillis是排除亮屏幕 和 app wakeLock 时间的电池总运行时间.<br>calculateRemaining统计的部分耗电会算入系统总耗电.  </p>
<h4 id="1-3-radio耗电统计"><a href="#1-3-radio耗电统计" class="headerlink" title="1.3 radio耗电统计"></a>1.3 radio耗电统计</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return estimated power (in mAs) of sending or receiving a packet with the mobile radio.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 估计传输一个数据包(2k)的耗电</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getMobilePowerPerPacket</span><span class="params">(<span class="keyword">long</span> rawRealtimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> MOBILE_BPS = <span class="number">200000</span>; <span class="comment">// <span class="doctag">TODO:</span> Extract average bit rates from system</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> MOBILE_POWER = mPowerRadioOn / <span class="number">3600</span>;</span><br><span class="line">    <span class="comment">// 获取发送和接受的数据总量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> mobileRx = mStats.getNetworkActivityPackets(BatteryStats.NETWORK_MOBILE_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> mobileTx = mStats.getNetworkActivityPackets(BatteryStats.NETWORK_MOBILE_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> mobileData = mobileRx + mobileTx;</span><br><span class="line">    <span class="comment">// 获取cell处于radio.active状态的总时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> radioDataUptimeMs =</span><br><span class="line">            mStats.getMobileRadioActiveTime(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 计算单位时间的传输数据量(发送 + 接受)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> mobilePps = (mobileData != <span class="number">0</span> &amp;&amp; radioDataUptimeMs != <span class="number">0</span>)</span><br><span class="line">            ? (mobileData / (<span class="keyword">double</span>)radioDataUptimeMs)</span><br><span class="line">            : (((<span class="keyword">double</span>)MOBILE_BPS) / <span class="number">8</span> / <span class="number">2048</span>);</span><br><span class="line">    <span class="keyword">return</span> (MOBILE_POWER / mobilePps) / (<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MobileRadioPowerCalculator</span><span class="params">(PowerProfile profile, BatteryStats stats)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取处于radio.active的单位耗电.注意:mPowerRadioOn是RADIO_ACTIVE,不是RADIO_ON!!!!</span></span><br><span class="line">    mPowerRadioOn = profile.getAveragePower(PowerProfile.POWER_RADIO_ACTIVE);</span><br><span class="line">    <span class="comment">// 获取不同的信号等级的单位耗电(一般是5级,4g项目是2个,第一个代表无信号,第二个代表有信号)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPowerBins.length; i++) &#123;<span class="comment">// android会进行转换，length为6,(0-5),0代表无信号,5代表信号最强</span></span><br><span class="line">        mPowerBins[i] = profile.getAveragePower(PowerProfile.POWER_RADIO_ON, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取扫描信号的单位耗电</span></span><br><span class="line">    mPowerScan = profile.getAveragePower(PowerProfile.POWER_RADIO_SCANNING);</span><br><span class="line">    mStats = stats;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计app移动通信的耗电</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Add cost of mobile traffic.</span></span><br><span class="line">    app.mobileRxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_MOBILE_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.mobileTxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_MOBILE_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    <span class="comment">// 获取处于radio.active状态的时间(ms)</span></span><br><span class="line">    app.mobileActive = u.getMobileRadioActiveTime(statsType) / <span class="number">1000</span>;</span><br><span class="line">    app.mobileActiveCount = u.getMobileRadioActiveCount(statsType);</span><br><span class="line">    app.mobileRxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_MOBILE_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.mobileTxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_MOBILE_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.mobileActive &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果统计到了处于radio.active状态的时间,用时间进行计算</span></span><br><span class="line">        <span class="comment">// We are tracking when the radio is up, so can use the active time to</span></span><br><span class="line">        <span class="comment">// determine power use.</span></span><br><span class="line">        mTotalAppMobileActiveMs += app.mobileActive;</span><br><span class="line">        app.mobileRadioPowerMah = (app.mobileActive * mPowerRadioOn) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果没有统计到时间,使用app传输的数据量来统计</span></span><br><span class="line">        <span class="comment">// We are not tracking when the radio is up, so must approximate power use</span></span><br><span class="line">        <span class="comment">// based on the number of packets.</span></span><br><span class="line">        app.mobileRadioPowerMah = (app.mobileRxPackets + app.mobileTxPackets)</span><br><span class="line">                * getMobilePowerPerPacket(rawRealtimeUs, statsType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; app.mobileRadioPowerMah != <span class="number">0</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": mobile packets "</span></span><br><span class="line">                + (app.mobileRxPackets + app.mobileTxPackets)</span><br><span class="line">                + <span class="string">" active time "</span> + app.mobileActive</span><br><span class="line">                + <span class="string">" power="</span> + BatteryStatsHelper.makemAh(app.mobileRadioPowerMah));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"radio.active"</span>&gt;</span>180.1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"radio.scanning"</span>&gt;</span>90.1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span> <span class="attr">name</span>=<span class="string">"radio.on"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>6.2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>6.2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>app使用耗电指是在radio.active的状态下,其他的参数在计算radio耗电的时候使用.<br>计算公式:<br>情况一：当追踪信号活动时间，即mobileActive &gt; 0，采用：  </p>
<p>mobileRadioPowerMah = (app.mobileActive <em> mPowerRadioOn) / (1000</em> 60* 60);  </p>
<p>情况二：当没有追踪信号活动时间，则采用：  </p>
<p>mobileRadioPowerMah = (app.mobileRxPackets + app.mobileTxPackets) * MobilePowerPerPacket  </p>
<p>其中MobilePowerPerPacket = (（mPowerRadioOn / 3600） / mobilePps) / (60*60)， mobilePps= （mobileRx + mobileTx）/radioDataUptimeMs  </p>
<h4 id="1-4-wifi-耗电"><a href="#1-4-wifi-耗电" class="headerlink" title="1.4 wifi 耗电"></a>1.4 wifi 耗电</h4><p>wifi耗电分两种: WifiPowerCalculator 和 WifiPowerEstimator.<br>WifiPowerCalculator: 通过wifi处于保持链接(wifi.controller.idle),接受数据(wifi.controller.rx),发送数据(wifi.controller.tx).三种状态来计算.<br>WifiPowerEstimator : 保持链接(wifi.on),发送或者接受数据(wifi.active),扫描周围的热点(wifi.scan)来估计(通过数据包的量).<br>使用哪个和机器有关:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// checkHasWifiPowerReporting can change if we get energy data at a later point, so</span></span><br><span class="line"><span class="comment">// always check this field.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> hasWifiPowerReporting = checkHasWifiPowerReporting(mStats, mPowerProfile);</span><br><span class="line"><span class="keyword">if</span> (mWifiPowerCalculator == <span class="keyword">null</span> || hasWifiPowerReporting != mHasWifiPowerReporting) &#123;</span><br><span class="line">    mWifiPowerCalculator = hasWifiPowerReporting ?</span><br><span class="line">            <span class="keyword">new</span> WifiPowerCalculator(mPowerProfile) :</span><br><span class="line">            <span class="keyword">new</span> WifiPowerEstimator(mPowerProfile);</span><br><span class="line">    mHasWifiPowerReporting = hasWifiPowerReporting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实还是取决于电源配置文件:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"wifi.controller.idle"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"wifi.controller.rx"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"wifi.controller.tx"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当配置为如上信息,就会使用WifiPowerEstimator类的方法进行估计.这里我们把两种方法都分析一下:  </p>
<h5 id="WifiPowerCalculator"><a href="#WifiPowerCalculator" class="headerlink" title="WifiPowerCalculator"></a>WifiPowerCalculator</h5><p>从名字看出这个类是计算,也就是底层提供数据能够普计算<br>WifiPowerCalculator.java-&gt;calculateApp()<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WifiPowerCalculator</span><span class="params">(PowerProfile profile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取三种状态的单位功耗</span></span><br><span class="line">    mIdleCurrentMa = profile.getAveragePower(PowerProfile.POWER_WIFI_CONTROLLER_IDLE);</span><br><span class="line">    mTxCurrentMa = profile.getAveragePower(PowerProfile.POWER_WIFI_CONTROLLER_TX);</span><br><span class="line">    mRxCurrentMa = profile.getAveragePower(PowerProfile.POWER_WIFI_CONTROLLER_RX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BatteryStats.ControllerActivityCounter counter = u.getWifiControllerActivity();</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取三种状态的占用时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> idleTime = counter.getIdleTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> txTime = counter.getTxTimeCounters()[<span class="number">0</span>].getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> rxTime = counter.getRxTimeCounter().getCountLocked(statsType);</span><br><span class="line">    app.wifiRunningTimeMs = idleTime + rxTime + txTime;</span><br><span class="line">    mTotalAppRunningTime += app.wifiRunningTimeMs;</span><br><span class="line">    <span class="comment">// 依据三种不同的wifi状态去计算</span></span><br><span class="line">    app.wifiPowerMah =</span><br><span class="line">            ((idleTime * mIdleCurrentMa) + (txTime * mTxCurrentMa) + (rxTime * mRxCurrentMa))</span><br><span class="line">            / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    mTotalAppPowerDrain += app.wifiPowerMah;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计数据包量 和 byte 数</span></span><br><span class="line">    app.wifiRxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_WIFI_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.wifiTxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_WIFI_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.wifiRxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_WIFI_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.wifiTxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_WIFI_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; app.wifiPowerMah != <span class="number">0</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": idle="</span> + idleTime + <span class="string">"ms rx="</span> + rxTime + <span class="string">"ms tx="</span> +</span><br><span class="line">                txTime + <span class="string">"ms power="</span> + BatteryStatsHelper.makemAh(app.wifiPowerMah));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计在wifi耗电除了app耗电被report的还有哪些耗电,也就是这里的耗电是不包括app使用wifi耗电的.</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateRemaining</span><span class="params">(BatterySipper app, BatteryStats stats, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG,<span class="string">"step into calculateRemaining"</span>);</span><br><span class="line">    <span class="keyword">final</span> BatteryStats.ControllerActivityCounter counter = stats.getWifiControllerActivity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> idleTimeMs = counter.getIdleTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> txTimeMs = counter.getTxTimeCounters()[<span class="number">0</span>].getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> rxTimeMs = counter.getRxTimeCounter().getCountLocked(statsType);</span><br><span class="line"></span><br><span class="line">    app.wifiRunningTimeMs = Math.max(<span class="number">0</span>,</span><br><span class="line">            (idleTimeMs + rxTimeMs + txTimeMs) - mTotalAppRunningTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> powerDrainMah = counter.getPowerCounter().getCountLocked(statsType)</span><br><span class="line">            / (<span class="keyword">double</span>)(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (powerDrainMah == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Some controllers do not report power drain, so we can calculate it here.</span></span><br><span class="line">        powerDrainMah = ((idleTimeMs * mIdleCurrentMa) + (txTimeMs * mTxCurrentMa)</span><br><span class="line">                + (rxTimeMs * mRxCurrentMa)) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(TAG,<span class="string">"powerDrainMah = "</span> + powerDrainMah + <span class="string">",mTotalAppPowerDrain ="</span> + mTotalAppPowerDrain);</span><br><span class="line">    app.wifiPowerMah = Math.max(<span class="number">0</span>, powerDrainMah - mTotalAppPowerDrain);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"left over WiFi power: "</span> + BatteryStatsHelper.makemAh(app.wifiPowerMah));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTotalAppPowerDrain = <span class="number">0</span>;</span><br><span class="line">    mTotalAppRunningTime = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过,在4g项目中mTxCurrentMa,mRxCurrentMa,mIdleCurrentMa在电池配置文件中都是0.<br>耗电计算公式:<br>wifiPowerMah = ((idleTime <em> mIdleCurrentMa) + (txTime </em> mTxCurrentMa) + (rxTime <em> mRxCurrentMa)) / (1000</em> 60* 60);  </p>
<h5 id="WifiPowerEstimator"><a href="#WifiPowerEstimator" class="headerlink" title="WifiPowerEstimator"></a>WifiPowerEstimator</h5><p>在4g项目中是通过该方式进行计算的,这里是进行了估算,<br>WifiPowerEstimator-&gt;calculateApp<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WifiPowerEstimator</span><span class="params">(PowerProfile profile)</span> </span>&#123;</span><br><span class="line">    mWifiPowerPerPacket = getWifiPowerPerPacket(profile);</span><br><span class="line">    mWifiPowerOn = profile.getAveragePower(PowerProfile.POWER_WIFI_ON);<span class="comment">// wifi.on</span></span><br><span class="line">    mWifiPowerScan = profile.getAveragePower(PowerProfile.POWER_WIFI_SCAN);<span class="comment">// wifi.scan</span></span><br><span class="line">    mWifiPowerBatchScan = profile.getAveragePower(PowerProfile.POWER_WIFI_BATCHED_SCAN);<span class="comment">// wifi.batchedscan</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return estimated power per Wi-Fi packet in mAh/packet where 1 packet = 2 KB.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getWifiPowerPerPacket</span><span class="params">(PowerProfile profile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wifi的bit速率</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> WIFI_BPS = <span class="number">1000000</span>; <span class="comment">// <span class="doctag">TODO:</span> Extract average bit rates from system</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> WIFI_POWER = profile.getAveragePower(PowerProfile.POWER_WIFI_ACTIVE)</span><br><span class="line">            / <span class="number">3600</span>;<span class="comment">// PowerProfile.POWER_WIFI_ACTIVE-&gt;wifi.active</span></span><br><span class="line">    <span class="keyword">return</span> WIFI_POWER / (((<span class="keyword">double</span>)WIFI_BPS) / <span class="number">8</span> / <span class="number">2048</span>);<span class="comment">// 计算每一个数据包的耗电量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    app.wifiRxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_WIFI_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.wifiTxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_WIFI_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.wifiRxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_WIFI_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.wifiTxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_WIFI_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    <span class="comment">// 计算收发数据包的耗电量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> wifiPacketPower = (app.wifiRxPackets + app.wifiTxPackets)</span><br><span class="line">            * mWifiPowerPerPacket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算wifi保持连接的功耗</span></span><br><span class="line">    app.wifiRunningTimeMs = u.getWifiRunningTime(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">    mTotalAppWifiRunningTimeMs += app.wifiRunningTimeMs;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> wifiLockPower = (app.wifiRunningTimeMs * mWifiPowerOn) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算wifi扫描时候的功耗</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> wifiScanTimeMs = u.getWifiScanTime(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> wifiScanPower = (wifiScanTimeMs * mWifiPowerScan) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算wifi批量扫描的功耗</span></span><br><span class="line">    <span class="keyword">double</span> wifiBatchScanPower = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> bin = <span class="number">0</span>; bin &lt; BatteryStats.Uid.NUM_WIFI_BATCHED_SCAN_BINS; bin++) &#123;<span class="comment">// BatteryStats.Uid.NUM_WIFI_BATCHED_SCAN_BINS = 5</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> batchScanTimeMs =</span><br><span class="line">                u.getWifiBatchedScanTime(bin, rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> batchScanPower = (batchScanTimeMs * mWifiPowerBatchScan) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">        wifiBatchScanPower += batchScanPower;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将四种耗电累加</span></span><br><span class="line">    app.wifiPowerMah = wifiPacketPower + wifiLockPower + wifiScanPower + wifiBatchScanPower;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; app.wifiPowerMah != <span class="number">0</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": power="</span> +</span><br><span class="line">                BatteryStatsHelper.makemAh(app.wifiPowerMah));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过估计传输一个数据包的耗电来估计app使用wifi时的耗电.<br>计算公式:<br>wifiPowerMah = wifiPacketPower + wifiLockPower + wifiScanPower + wifiBatchScanPower;  </p>
<p>其中:wifiPacketPower = (wifiRxPackets + wifiTxPackets) <em> mWifiPowerPerPacket; wifiLockPower =<br>        (wifiRunningTimeMs </em> mWifiPowerOn) / (1000<em> 60</em> 60); wifiScanPower = (wifiScanTimeMs <em> mWifiPowerScan) / (1000</em> 60* 60);  </p>
<p>wifiBatchScanPower = ∑ (batchScanTimeMs <em> mWifiPowerBatchScan) / (1000</em> 60* 60) ，5次相加。  </p>
<h4 id="1-5-bluetooth耗电统计"><a href="#1-5-bluetooth耗电统计" class="headerlink" title="1.5 bluetooth耗电统计"></a>1.5 bluetooth耗电统计</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BluetoothPowerCalculator</span><span class="params">(PowerProfile profile)</span> </span>&#123;</span><br><span class="line">    mIdleMa = profile.getAveragePower(PowerProfile.POWER_BLUETOOTH_CONTROLLER_IDLE);</span><br><span class="line">    mRxMa = profile.getAveragePower(PowerProfile.POWER_BLUETOOTH_CONTROLLER_RX);</span><br><span class="line">    mTxMa = profile.getAveragePower(PowerProfile.POWER_BLUETOOTH_CONTROLLER_TX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前没有配置POWER_BLUETOOTH_CONTROLLER_IDLE,POWER_BLUETOOTH_CONTROLLER_RX,POWER_BLUETOOTH_CONTROLLER_TX.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.ControllerActivityCounter counter = u.getBluetoothControllerActivity();</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> idleTimeMs = counter.getIdleTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> rxTimeMs = counter.getRxTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> txTimeMs = counter.getTxTimeCounters()[<span class="number">0</span>].getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> totalTimeMs = idleTimeMs + txTimeMs + rxTimeMs;</span><br><span class="line">    <span class="comment">// 通过获取bluetooth的耗电,转换单位</span></span><br><span class="line">    <span class="keyword">double</span> powerMah = counter.getPowerCounter().getCountLocked(statsType)<span class="comment">// 具体怎么获取的不知道.....</span></span><br><span class="line">            / (<span class="keyword">double</span>)(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (powerMah == <span class="number">0</span>) &#123;</span><br><span class="line">        powerMah = ((idleTimeMs * mIdleMa) + (rxTimeMs * mRxMa) + (txTimeMs * mTxMa))</span><br><span class="line">                / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.bluetoothPowerMah = powerMah;</span><br><span class="line">    app.bluetoothRunningTimeMs = totalTimeMs;</span><br><span class="line">    app.btRxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_BT_RX_DATA, statsType);</span><br><span class="line">    app.btTxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_BT_TX_DATA, statsType);</span><br><span class="line"></span><br><span class="line">    mAppTotalPowerMah += powerMah;</span><br><span class="line">    mAppTotalTimeMs += totalTimeMs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计算公式:<br>powerMah = counter.getPowerCounter().getCountLocked(statsType)/ (double)(1000<em>60</em>60);// 获bluetooth的总耗电,转换单位<br>如果获取的是0使用以下方式计算:<br>powerMah = ((idleTimeMs <em> mIdleMa) + (rxTimeMs </em> mRxMa) + (txTimeMs <em> mTxMa)) / (1000</em>60*60);<br>不过在4g中,这么计算是0.  </p>
<h4 id="1-6-传感器耗电"><a href="#1-6-传感器耗电" class="headerlink" title="1.6 传感器耗电"></a>1.6 传感器耗电</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SensorPowerCalculator</span><span class="params">(PowerProfile profile, SensorManager sensorManager)</span> </span>&#123;</span><br><span class="line">    mSensors = sensorManager.getSensorList(Sensor.TYPE_ALL);<span class="comment">//获取sensor的列表</span></span><br><span class="line">    mGpsPowerOn = profile.getAveragePower(PowerProfile.POWER_GPS_ON);<span class="comment">//GPS耗电统计放在Sensor耗电中统计</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Process Sensor usage</span></span><br><span class="line">    <span class="keyword">final</span> SparseArray&lt;? extends BatteryStats.Uid.Sensor&gt; sensorStats = u.getSensorStats();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NSE = sensorStats.size();<span class="comment">//获取总的sensor数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ise = <span class="number">0</span>; ise &lt; NSE; ise++) &#123;<span class="comment">// 计算每个sensor的耗电</span></span><br><span class="line">        <span class="keyword">final</span> BatteryStats.Uid.Sensor sensor = sensorStats.valueAt(ise);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> sensorHandle = sensorStats.keyAt(ise);</span><br><span class="line">        <span class="keyword">final</span> BatteryStats.Timer timer = sensor.getSensorTime();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> sensorTime = timer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">switch</span> (sensorHandle) &#123;</span><br><span class="line">            <span class="keyword">case</span> BatteryStats.Uid.Sensor.GPS:</span><br><span class="line">                app.gpsTimeMs = sensorTime;</span><br><span class="line">                app.gpsPowerMah = (app.gpsTimeMs * mGpsPowerOn) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="comment">// 除了GPS的sensor都在这计算</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> sensorsCount = mSensors.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sensorsCount; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Sensor s = mSensors.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (s.getHandle() == sensorHandle) &#123;</span><br><span class="line">                        app.sensorPowerMah += (sensorTime * s.getPower()) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于传感器的配置文件:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"gps.on"</span>&gt;</span>40.8<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>GPS功耗计算公式:<br>gpsPowerMah = (app.gpsTimeMs <em> mGpsPowerOn) / (1000</em> 60<em> 60);<br>sensorPowerMah = ∑ (sensorTime </em> s.getPower()) / (1000<em>60</em>60);</p>
<h4 id="1-7-Camera耗电统计"><a href="#1-7-Camera耗电统计" class="headerlink" title="1.7 Camera耗电统计"></a>1.7 Camera耗电统计</h4><p>此块耗电并没有算入之前定义的DrainType.CAMERA.不知道google是还没完善还是处于什么考虑<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CameraPowerCalculator</span><span class="params">(PowerProfile profile)</span> </span>&#123;</span><br><span class="line">    mCameraPowerOnAvg = profile.getAveragePower(PowerProfile.POWER_CAMERA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate camera power usage.  Right now, this is a (very) rough estimate based on the</span></span><br><span class="line">    <span class="comment">// average power usage for a typical camera application.</span></span><br><span class="line">    <span class="comment">// 用Camera打开的时间 * 单位时间功耗</span></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.Timer timer = u.getCameraTurnedOnTimer();</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> totalTime = timer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">        app.cameraTimeMs = totalTime;</span><br><span class="line">        app.cameraPowerMah = (totalTime * mCameraPowerOnAvg) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app.cameraTimeMs = <span class="number">0</span>;</span><br><span class="line">        app.cameraPowerMah = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PowerProfile.POWER_CAMERA:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"camera.avg"</span>&gt;</span>401.2<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>计算公式:<br>cameraPowerMah = (totalTime <em> mCameraPowerOnAvg) / (1000 </em> 60 * 60)  </p>
<h4 id="1-8-Flashlight耗电统计"><a href="#1-8-Flashlight耗电统计" class="headerlink" title="1.8 Flashlight耗电统计"></a>1.8 Flashlight耗电统计</h4><p>该耗电并没有算入DrainType.FLASHLIGHT.情况同Camera.统计闪光灯模块耗电,eg:拍照闪光灯,手电筒<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FlashlightPowerCalculator</span><span class="params">(PowerProfile profile)</span> </span>&#123;</span><br><span class="line">    mFlashlightPowerOnAvg = profile.getAveragePower(PowerProfile.POWER_FLASHLIGHT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate flashlight power usage.  Right now, this is based on the average power draw</span></span><br><span class="line">    <span class="comment">// of the flash unit when kept on over a short period of time.</span></span><br><span class="line">    <span class="comment">// android 中亮度只有一个,iOS中有多个,所以这里就是: 时间 * 单位耗电</span></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.Timer timer = u.getFlashlightTurnedOnTimer();</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> totalTime = timer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">        app.flashlightTimeMs = totalTime;</span><br><span class="line">        app.flashlightPowerMah = (totalTime * mFlashlightPowerOnAvg) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app.flashlightTimeMs = <span class="number">0</span>;</span><br><span class="line">        app.flashlightPowerMah = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PowerProfile.POWER_FLASHLIGHT:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"camera.flashlight"</span>&gt;</span>239.6<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>计算公式:<br>flashlightPowerMah = (totalTime <em> mFlashlightPowerOnAvg) / (1000</em>60*60)  </p>
<h4 id="1-9-OS耗电"><a href="#1-9-OS耗电" class="headerlink" title="1.9 OS耗电"></a>1.9 OS耗电</h4><p>统计的过程中用osSipper保存系统耗电<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// osSipper被初始化过,也就是上面统计的uid里面有系统的uid,下面把系统的耗电累加起来</span></span><br><span class="line"><span class="keyword">if</span> (osSipper != <span class="keyword">null</span>) &#123;<span class="comment">// 长时间cpu唤醒,但是屏幕没有亮,该部分的耗算入OS耗电</span></span><br><span class="line">    <span class="comment">// The device has probably been awake for longer than the screen on</span></span><br><span class="line">    <span class="comment">// time and application wake lock time would account for.  Assign</span></span><br><span class="line">    <span class="comment">// this remainder to the OS, if possible.</span></span><br><span class="line">    <span class="comment">// 该部分在上面分析过</span></span><br><span class="line">    mWakelockPowerCalculator.calculateRemaining(osSipper, mStats, mRawRealtimeUs,</span><br><span class="line">            mRawUptimeUs, mStatsType);</span><br><span class="line">    <span class="comment">// OS耗电求和</span></span><br><span class="line">    osSipper.sumPower();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是app的耗电,没有统计屏幕耗电.</p>
<hr>
<h3 id="2-硬件电量统计"><a href="#2-硬件电量统计" class="headerlink" title="2 硬件电量统计"></a>2 硬件电量统计</h3><h4 id="BatteryStatsHelper-java–-gt-processMiscUsage"><a href="#BatteryStatsHelper-java–-gt-processMiscUsage" class="headerlink" title="BatteryStatsHelper.java–&gt;processMiscUsage()"></a>BatteryStatsHelper.java–&gt;processMiscUsage()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processMiscUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    addUserUsage();</span><br><span class="line">    addPhoneUsage();</span><br><span class="line">    addScreenUsage();</span><br><span class="line">    addWiFiUsage();</span><br><span class="line">    addBluetoothUsage();</span><br><span class="line">    addMemoryUsage();</span><br><span class="line">    addIdleUsage(); <span class="comment">// Not including cellular idle power</span></span><br><span class="line">    <span class="comment">// Don't compute radio usage if it's a wifi-only device</span></span><br><span class="line">    <span class="keyword">if</span> (!mWifiOnly) &#123;</span><br><span class="line">        addRadioUsage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-user耗电统计"><a href="#2-1-user耗电统计" class="headerlink" title="2.1 user耗电统计"></a>2.1 user耗电统计</h4><p>属于BatterySipper.DrainType.USER<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addUserUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mUserSippers.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = mUserSippers.keyAt(i);</span><br><span class="line">        BatterySipper bs = <span class="keyword">new</span> BatterySipper(DrainType.USER, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">        bs.userId = userId;</span><br><span class="line">        <span class="comment">// 将每个user用户的耗电求和</span></span><br><span class="line">        aggregateSippers(bs, mUserSippers.valueAt(i), <span class="string">"User"</span>);</span><br><span class="line">        mUsageList.add(bs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>aggregateSippers:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void aggregateSippers(BatterySipper bs, List&lt;BatterySipper&gt; from, String tag) &#123;</span><br><span class="line">    for (int i = 0; i &lt; from.size(); i++) &#123;</span><br><span class="line">        BatterySipper wbs = from.get(i);</span><br><span class="line">        if (DEBUG) Log.d(TAG, tag + &quot; adding sipper &quot; + wbs + &quot;: cpu=&quot; + wbs.cpuTimeMs);</span><br><span class="line">        bs.add(wbs);</span><br><span class="line">    &#125;</span><br><span class="line">    bs.computeMobilemspp();</span><br><span class="line">    bs.sumPower();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计算公式:<br>user_power = user_1_power + user_2_power + … +　user_n_power; (n为所有的user的总数)  </p>
<h4 id="2-2-Phone耗电统计"><a href="#2-2-Phone耗电统计" class="headerlink" title="2.2 Phone耗电统计"></a>2.2 Phone耗电统计</h4><p>属于:BatterySipper.DrainType.PHONE.计算通话耗电量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void addPhoneUsage() &#123;</span><br><span class="line">    long phoneOnTimeMs = mStats.getPhoneOnTime(mRawRealtimeUs, mStatsType) / 1000;</span><br><span class="line">    // Phone的耗电也采用POWER_RADIO_ACTIVE,后面的radio的耗电统计也用到这个单位耗电量</span><br><span class="line">    // 计算功耗</span><br><span class="line">    double phoneOnPower = mPowerProfile.getAveragePower(PowerProfile.POWER_RADIO_ACTIVE)</span><br><span class="line">            * phoneOnTimeMs / (60*60*1000);</span><br><span class="line">    // 保存</span><br><span class="line">    if (phoneOnPower != 0) &#123;</span><br><span class="line">        addEntry(BatterySipper.DrainType.PHONE, phoneOnTimeMs, phoneOnPower);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PowerProfile.POWER_RADIO_ACTIVE :<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"radio.active"</span>&gt;</span>180.1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>计算公式:<br>phone_powers = (phoneOnTimeMs <em> phoneOnPower) / (60</em> 60* 1000)  </p>
<h4 id="2-3-屏幕耗电统计"><a href="#2-3-屏幕耗电统计" class="headerlink" title="2.3 屏幕耗电统计"></a>2.3 屏幕耗电统计</h4><p>属于:BatterySipper.DrainType.SCREEN.屏幕耗电是单独算的,没有算入app耗电<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Screen power is the additional power the screen takes while the device is running.</span><br><span class="line"> */</span><br><span class="line">private void addScreenUsage() &#123;</span><br><span class="line">    double power = 0;</span><br><span class="line">    // 计算屏幕处于POWER_SCREEN_ON状态的功耗</span><br><span class="line">    long screenOnTimeMs = mStats.getScreenOnTime(mRawRealtimeUs, mStatsType) / 1000;</span><br><span class="line">    power += screenOnTimeMs * mPowerProfile.getAveragePower(PowerProfile.POWER_SCREEN_ON);</span><br><span class="line">    // 获取屏幕最高亮度的单位耗电</span><br><span class="line">    final double screenFullPower =</span><br><span class="line">            mPowerProfile.getAveragePower(PowerProfile.POWER_SCREEN_FULL);</span><br><span class="line">    // 计算不同亮度等级的耗电量,并进行统计.</span><br><span class="line">    for (int i = 0; i &lt; BatteryStats.NUM_SCREEN_BRIGHTNESS_BINS; i++) &#123;// 5个亮度等级</span><br><span class="line">        double screenBinPower = screenFullPower * (i + 0.5f)</span><br><span class="line">                / BatteryStats.NUM_SCREEN_BRIGHTNESS_BINS;</span><br><span class="line">        long brightnessTime = mStats.getScreenBrightnessTime(i, mRawRealtimeUs, mStatsType)</span><br><span class="line">                / 1000;</span><br><span class="line">        double p = screenBinPower * brightnessTime;</span><br><span class="line">        if (DEBUG &amp;&amp; p != 0) &#123;</span><br><span class="line">            Log.d(TAG, &quot;Screen bin #&quot; + i + &quot;: time=&quot; + brightnessTime</span><br><span class="line">                    + &quot; power=&quot; + makemAh(p / (60 * 60 * 1000)));</span><br><span class="line">        &#125;</span><br><span class="line">        power += p;</span><br><span class="line">    &#125;</span><br><span class="line">    power /= (60 * 60 * 1000); // To hours</span><br><span class="line">    if (power != 0) &#123;</span><br><span class="line">        addEntry(BatterySipper.DrainType.SCREEN, screenOnTimeMs, power);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>POWER_SCREEN_ON 和 POWER_SCREEN_FULL对应的值:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"screen.on"</span>&gt;</span>21.7<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"screen.full"</span>&gt;</span>304.3<span class="tag">&lt;/<span class="name">item</span>&gt;</span>// 不是最大亮度耗电,比最大亮度功耗大10%</span><br></pre></td></tr></table></figure></p>
<p>屏幕亮度的等级:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCREEN_BRIGHTNESS_DARK = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCREEN_BRIGHTNESS_DIM = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCREEN_BRIGHTNESS_MEDIUM = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCREEN_BRIGHTNESS_LIGHT = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCREEN_BRIGHTNESS_BRIGHT = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] SCREEN_BRIGHTNESS_NAMES = &#123;</span><br><span class="line">    <span class="string">"dark"</span>, <span class="string">"dim"</span>, <span class="string">"medium"</span>, <span class="string">"light"</span>, <span class="string">"bright"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] SCREEN_BRIGHTNESS_SHORT_NAMES = &#123;</span><br><span class="line">    <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_SCREEN_BRIGHTNESS_BINS = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p>计算公式:<br>公式：screen_power = screenOnTimeMs * screenOnPower + backlight_power</p>
<p>其中：backlight_power = 0.1 <em> dark_brightness_time </em> screenFullPower + 0.3 <em> dim_brightness_time </em> screenFullPower  </p>
<pre><code>+ 0.5 * medium_brightness_time * screenFullPower + 0.7 * light_brightness_time  
+ 0.9 * bright_brightness_time * screenFullPower;
</code></pre><h4 id="2-4-wifi耗电统计"><a href="#2-4-wifi耗电统计" class="headerlink" title="2.4 wifi耗电统计"></a>2.4 wifi耗电统计</h4><p>属于 BatterySipper.DrainType.WIFI,每个app使用wifi的耗电计算了,这里统计的是所有app在wifi上耗电总和实际wifi运行耗电的差值.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * We do per-app blaming of WiFi activity. If energy info is reported from the controller,</span></span><br><span class="line"><span class="comment"> * then only the WiFi process gets blamed here since we normalize power calculations and</span></span><br><span class="line"><span class="comment"> * assign all the power drain to apps. If energy info is not reported, we attribute the</span></span><br><span class="line"><span class="comment"> * difference between total running time of WiFi for all apps and the actual running time</span></span><br><span class="line"><span class="comment"> * of WiFi to the WiFi subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWiFiUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BatterySipper bs = <span class="keyword">new</span> BatterySipper(DrainType.WIFI, <span class="keyword">null</span>, <span class="number">0</span>);<span class="comment">// DrainType.WIFI就是BatterySipper.DrainType.WIFI</span></span><br><span class="line">    mWifiPowerCalculator.calculateRemaining(bs, mStats, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">            mStatsType);</span><br><span class="line">    aggregateSippers(bs, mWifiSippers, <span class="string">"WIFI"</span>);</span><br><span class="line">    <span class="keyword">if</span> (bs.totalPowerMah &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mUsageList.add(bs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在我们的项目中使用的是WifiPowerEstimator.calculateRemaining():<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void calculateRemaining(BatterySipper app, BatteryStats stats, long rawRealtimeUs,</span><br><span class="line">                               long rawUptimeUs, int statsType) &#123;</span><br><span class="line">    // 获取毫秒级的wifi运行的总时间</span><br><span class="line">    final long totalRunningTimeMs = stats.getGlobalWifiRunningTime(rawRealtimeUs, statsType)</span><br><span class="line">            / 1000;</span><br><span class="line">    // 这里的耗电是以保持连接计算的</span><br><span class="line">    final double powerDrain = ((totalRunningTimeMs - mTotalAppWifiRunningTimeMs) * mWifiPowerOn)</span><br><span class="line">            / (1000*60*60);</span><br><span class="line">    app.wifiRunningTimeMs = totalRunningTimeMs;</span><br><span class="line">    app.wifiPowerMah = Math.max(0, powerDrain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mWifiPowerOn:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"wifi.on"</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这块的功耗还是比较低的.</p>
<h4 id="2-5-蓝牙耗电统计"><a href="#2-5-蓝牙耗电统计" class="headerlink" title="2.5 蓝牙耗电统计"></a>2.5 蓝牙耗电统计</h4><p>属于BatterySipper.DrainType.BLUETOOTH于此处统计的Bluetooth耗电是指app耗电之外的蓝牙耗电<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bluetooth usage is not attributed to any apps yet, so the entire blame goes to the</span></span><br><span class="line"><span class="comment"> * Bluetooth Category.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBluetoothUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BatterySipper bs = <span class="keyword">new</span> BatterySipper(BatterySipper.DrainType.BLUETOOTH, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    mBluetoothPowerCalculator.calculateRemaining(bs, mStats, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">            mStatsType);</span><br><span class="line">    <span class="comment">// 对mBluetoothSippers里的统计量,进行求和,都算入Bluetooth</span></span><br><span class="line">    aggregateSippers(bs, mBluetoothSippers, <span class="string">"Bluetooth"</span>);</span><br><span class="line">    <span class="keyword">if</span> (bs.totalPowerMah &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mUsageList.add(bs);<span class="comment">// 保存到所有app的耗电统计结果清单中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看下具体计算:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BluetoothPowerCalculator</span><span class="params">(PowerProfile profile)</span> </span>&#123;</span><br><span class="line">    mIdleMa = profile.getAveragePower(PowerProfile.POWER_BLUETOOTH_CONTROLLER_IDLE);</span><br><span class="line">    mRxMa = profile.getAveragePower(PowerProfile.POWER_BLUETOOTH_CONTROLLER_RX);</span><br><span class="line">    mTxMa = profile.getAveragePower(PowerProfile.POWER_BLUETOOTH_CONTROLLER_TX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可是在电源配置文件中没有这三个值,使用默认值是0.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateRemaining</span><span class="params">(BatterySipper app, BatteryStats stats, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BatteryStats.ControllerActivityCounter counter =</span><br><span class="line">            stats.getBluetoothControllerActivity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> idleTimeMs = counter.getIdleTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> txTimeMs = counter.getTxTimeCounters()[<span class="number">0</span>].getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> rxTimeMs = counter.getRxTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> totalTimeMs = idleTimeMs + txTimeMs + rxTimeMs;</span><br><span class="line">    <span class="keyword">double</span> powerMah = counter.getPowerCounter().getCountLocked(statsType)</span><br><span class="line">             / (<span class="keyword">double</span>)(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (powerMah == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Some devices do not report the power, so calculate it.</span></span><br><span class="line">        powerMah = ((idleTimeMs * mIdleMa) + (rxTimeMs * mRxMa) + (txTimeMs * mTxMa))</span><br><span class="line">                / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subtract what the apps used, but clamp to 0.</span></span><br><span class="line">    powerMah = Math.max(<span class="number">0</span>, powerMah - mAppTotalPowerMah);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; powerMah != <span class="number">0</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Bluetooth active: time="</span> + (totalTimeMs)</span><br><span class="line">                + <span class="string">" power="</span> + BatteryStatsHelper.makemAh(powerMah));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.bluetoothPowerMah = powerMah;</span><br><span class="line">    app.bluetoothRunningTimeMs = Math.max(<span class="number">0</span>, totalTimeMs - mAppTotalTimeMs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"bluetooth.active"</span>&gt;</span>49.8<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"bluetooth.on"</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也就是说bluetooth.active 和 bluetooth.on并没有使用.那么岂不是bluetooth耗电是0?<br>不是的,在统计app耗电的时候,当app的uid是Process.BLUETOOTH_UID就将其耗电计入到mBluetoothSippers.统计bluetooth耗电就将这些值求和.<br>后续该模块google可能还要修改.  </p>
<h4 id="2-6-内存耗电统计"><a href="#2-6-内存耗电统计" class="headerlink" title="2.6 内存耗电统计"></a>2.6 内存耗电统计</h4><p>属于BatterySipper.DrainType.MEMORY,这部分是android O才添加的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void addMemoryUsage() &#123;</span><br><span class="line">    BatterySipper memory = new BatterySipper(DrainType.MEMORY, null, 0);</span><br><span class="line">    mMemoryPowerCalculator.calculateRemaining(memory, mStats, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">            mStatsType);</span><br><span class="line">    // 汇总一下,和os耗电统计的sumPower()是同一个方法</span><br><span class="line">    memory.sumPower();</span><br><span class="line">    // 添加到app耗电的列表中</span><br><span class="line">    if (memory.totalPowerMah &gt; 0) &#123;</span><br><span class="line">        mUsageList.add(memory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>MemoryPowerCalculator.calculateRemaining():<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public MemoryPowerCalculator(PowerProfile profile) &#123;</span><br><span class="line">    int numBuckets = profile.getNumElements(PowerProfile.POWER_MEMORY);</span><br><span class="line">    powerAverages = new double[numBuckets];</span><br><span class="line">    for (int i = 0; i &lt; numBuckets; i++) &#123;// 4g只有一个等级</span><br><span class="line">        powerAverages[i] = profile.getAveragePower(PowerProfile.POWER_MEMORY, i);</span><br><span class="line">        if (powerAverages[i] == 0 &amp;&amp; DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, &quot;Problem with PowerProfile. Received 0 value in MemoryPowerCalculator&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// app使用Memory的耗电还是空方法,看来google在耗电统计方面还在做努力</span><br><span class="line">@Override</span><br><span class="line">public void calculateApp(BatterySipper app, BatteryStats.Uid u, long rawRealtimeUs,</span><br><span class="line">        long rawUptimeUs, int statsType) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 计算Memory的耗电</span><br><span class="line">@Override</span><br><span class="line">public void calculateRemaining(BatterySipper app, BatteryStats stats, long rawRealtimeUs,</span><br><span class="line">        long rawUptimeUs, int statsType) &#123;</span><br><span class="line">    double totalMah = 0;</span><br><span class="line">    long totalTimeMs = 0;</span><br><span class="line">    // 获取kernel使用memery耗电的时间片段统计</span><br><span class="line">    LongSparseArray&lt;? extends BatteryStats.Timer&gt; timers = stats.getKernelMemoryStats();</span><br><span class="line">    for (int i = 0; i &lt; timers.size() &amp;&amp; i &lt; powerAverages.length; i++) &#123;</span><br><span class="line">        // 获取单位时间片段的单位耗电</span><br><span class="line">        double mAatRail = powerAverages[(int) timers.keyAt(i)];</span><br><span class="line">        // 获取该时间片段的时长</span><br><span class="line">        long timeMs = timers.valueAt(i).getTotalTimeLocked(rawRealtimeUs, statsType);</span><br><span class="line">        double mAm = (mAatRail * timeMs) / (1000*60);</span><br><span class="line">        if(DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, &quot;Calculating mAh for bucket &quot; + timers.keyAt(i) + &quot; while unplugged&quot;);</span><br><span class="line">            Log.d(TAG, &quot;Converted power profile number from &quot;</span><br><span class="line">                    + powerAverages[(int) timers.keyAt(i)] + &quot; into &quot; + mAatRail);</span><br><span class="line">            Log.d(TAG, &quot;Calculated mAm &quot; + mAm);</span><br><span class="line">        &#125;</span><br><span class="line">        totalMah += mAm/60;</span><br><span class="line">        totalTimeMs += timeMs;</span><br><span class="line">    &#125;</span><br><span class="line">    app.usagePowerMah = totalMah;</span><br><span class="line">    app.usageTimeMs = totalTimeMs;</span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        Log.d(TAG, String.format(&quot;Calculated total mAh for memory %f while unplugged %d &quot;,</span><br><span class="line">                totalMah, totalTimeMs));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>PowerProfile.POWER_MEMORY:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">array</span> <span class="attr">name</span>=<span class="string">"memory.bandwidths"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>22.7<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>计算公式:<br>totalMah = ∑ (mAatRail <em> timeMs) / (1000</em>60)  </p>
<h4 id="2-7-手机空闲耗电统计"><a href="#2-7-手机空闲耗电统计" class="headerlink" title="2.7 手机空闲耗电统计"></a>2.7 手机空闲耗电统计</h4><p>统计的是基准功率的功耗,统计cpu在idle和awake的情况下,处于低电量状态时,只有idle状态的耗电,<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Calculate the baseline power usage for the device when it is in suspend and idle.</span><br><span class="line"> * The device is drawing POWER_CPU_IDLE power at its lowest power state.</span><br><span class="line"> * The device is drawing POWER_CPU_IDLE + POWER_CPU_AWAKE power when a wakelock is held.</span><br><span class="line"> */</span><br><span class="line">private void addIdleUsage() &#123;</span><br><span class="line">    // 获取处于suspend状态的时间</span><br><span class="line">    final double suspendPowerMaMs = (mTypeBatteryRealtimeUs / 1000) *</span><br><span class="line">            mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_IDLE);</span><br><span class="line">    // 从android 7开始算入POWER_CPU_AWAKE状态的耗电</span><br><span class="line">    final double idlePowerMaMs = (mTypeBatteryUptimeUs / 1000) *</span><br><span class="line">            mPowerProfile.getAveragePower(PowerProfile.POWER_CPU_AWAKE);</span><br><span class="line">    final double totalPowerMah = (suspendPowerMaMs + idlePowerMaMs) / (60 * 60 * 1000);</span><br><span class="line">    if (DEBUG &amp;&amp; totalPowerMah != 0) &#123;</span><br><span class="line">        Log.d(TAG, &quot;Suspend: time=&quot; + (mTypeBatteryRealtimeUs / 1000)</span><br><span class="line">                + &quot; power=&quot; + makemAh(suspendPowerMaMs / (60 * 60 * 1000)));</span><br><span class="line">        Log.d(TAG, &quot;Idle: time=&quot; + (mTypeBatteryUptimeUs / 1000)</span><br><span class="line">                + &quot; power=&quot; + makemAh(idlePowerMaMs / (60 * 60 * 1000)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (totalPowerMah != 0) &#123;</span><br><span class="line">        addEntry(BatterySipper.DrainType.IDLE, mTypeBatteryRealtimeUs / 1000, totalPowerMah);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PowerProfile.POWER_CPU_IDLE 和 PowerProfile.POWER_CPU_AWAKE对应的值:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"cpu.idle"</span>&gt;</span>4.8<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"cpu.awake"</span>&gt;</span>21.1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>计算公式:<br>idlePower = (idleTimeMs <em> cpuIdlePower + awakeTimeMs </em> cpuAwakePower) / (60<em> 60</em> 1000)  </p>
<p>值得注意的是: 该模块并不包括手机处于cell网络下的idle状态耗电.  </p>
<h4 id="2-8-Radio耗电统计"><a href="#2-8-Radio耗电统计" class="headerlink" title="2.8 Radio耗电统计"></a>2.8 Radio耗电统计</h4><p>如果只有wifi的设备就不统计.addRadioUsage():<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void addRadioUsage() &#123;</span><br><span class="line">    BatterySipper radio = new BatterySipper(BatterySipper.DrainType.CELL, null, 0);</span><br><span class="line">    mMobileRadioPowerCalculator.calculateRemaining(radio, mStats, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">            mStatsType);</span><br><span class="line">    radio.sumPower();</span><br><span class="line">    if (radio.totalPowerMah &gt; 0) &#123;</span><br><span class="line">        mUsageList.add(radio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看下MobileRadioPowerCalculator.calculateRemaining()方法是怎么计算的:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void calculateRemaining(BatterySipper app, BatteryStats stats, long rawRealtimeUs,</span><br><span class="line">                               long rawUptimeUs, int statsType) &#123;</span><br><span class="line">    double power = 0;// 统计radio的最终耗电</span><br><span class="line">    long signalTimeMs = 0;// 和cell连接的总时长</span><br><span class="line">    long noCoverageTimeMs = 0;// 没有信号的时间长度</span><br><span class="line">    for (int i = 0; i &lt; mPowerBins.length; i++) &#123;// 实测该模块这部分耗电最大,由于时间大.</span><br><span class="line">        long strengthTimeMs = stats.getPhoneSignalStrengthTime(i, rawRealtimeUs, statsType)</span><br><span class="line">                / 1000;</span><br><span class="line">        final double p = (strengthTimeMs * mPowerBins[i]) / (60*60*1000);</span><br><span class="line">        if (DEBUG &amp;&amp; p != 0) &#123;</span><br><span class="line">            Log.d(TAG, &quot;Cell strength #&quot; + i + &quot;: time=&quot; + strengthTimeMs + &quot; power=&quot;</span><br><span class="line">                    + BatteryStatsHelper.makemAh(p));</span><br><span class="line">        &#125;</span><br><span class="line">        power += p;</span><br><span class="line">        signalTimeMs += strengthTimeMs;</span><br><span class="line">        if (i == 0) &#123;// i = 0是代表没有信号的时间长度(none)</span><br><span class="line">            noCoverageTimeMs = strengthTimeMs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算扫描时的耗电</span><br><span class="line">    final long scanningTimeMs = stats.getPhoneSignalScanningTime(rawRealtimeUs, statsType)</span><br><span class="line">            / 1000;</span><br><span class="line">    final double p = (scanningTimeMs * mPowerScan) / (60*60*1000);</span><br><span class="line">    if (DEBUG &amp;&amp; p != 0) &#123;</span><br><span class="line">        Log.d(TAG, &quot;Cell radio scanning: time=&quot; + scanningTimeMs</span><br><span class="line">                + &quot; power=&quot; + BatteryStatsHelper.makemAh(p));</span><br><span class="line">    &#125;</span><br><span class="line">    power += p;</span><br><span class="line">    // 计算Active状态的耗电,排除app使用cell的耗电</span><br><span class="line">    long radioActiveTimeMs = mStats.getMobileRadioActiveTime(rawRealtimeUs, statsType) / 1000;</span><br><span class="line">    // 排除统计了的app使用耗电,app的cell耗电,只统计处于active状态下的耗电</span><br><span class="line">    long remainingActiveTimeMs = radioActiveTimeMs - mTotalAppMobileActiveMs;</span><br><span class="line">    if (remainingActiveTimeMs &gt; 0) &#123;</span><br><span class="line">        power += (mPowerRadioOn * remainingActiveTimeMs) / (1000*60*60);</span><br><span class="line">    &#125;</span><br><span class="line">    // 保存</span><br><span class="line">    if (power != 0) &#123;</span><br><span class="line">        if (signalTimeMs != 0) &#123;// 无信号百分比</span><br><span class="line">            app.noCoveragePercent = noCoverageTimeMs * 100.0 / signalTimeMs;</span><br><span class="line">        &#125;</span><br><span class="line">        app.mobileActive = remainingActiveTimeMs;// radio活动,除app</span><br><span class="line">        app.mobileActiveCount = stats.getMobileRadioActiveUnknownCount(statsType);// 获取radio的活跃次数</span><br><span class="line">        app.mobileRadioPowerMah = power;// 获取连接cell的功耗</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计算公式:<br>mobileRadioPowerMah = strengthOnPower + scanningPower + remainingActivePower  </p>
<p>其中： strengthOnPower = none_strength_Ms <em> none_strength_Power + poor_strength_Ms </em> poor_strength_Power  </p>
<pre><code>+ moderate_strength_Ms * moderate_strength_Power + good_strength_Ms * good_strength_Power  
+ great_strength_Ms * great_strength_Power；  
</code></pre><p>scanningPower = scanningTimeMs * mPowerScan；  </p>
<p>remainingActivePower = （radioActiveTimeMs - mTotalAppMobileActiveMs）* mPowerRadioOn；<br>该模块统计是排除了app的使用网络造成的耗电.</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Michael</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lqktz.github.io/2019/04/10/Android-O-耗电统计/">https://lqktz.github.io/2019/04/10/Android-O-耗电统计/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lqktz.github.io">Michael Blog</a>！</span></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/10/Android-SystemServer/"><i class="fa fa-chevron-left">  </i><span>Android SystemServer学习笔记</span></a></div><div class="next-post pull-right"><a href="/2019/04/02/Android从驱动到应用(2)测试freg驱动的功能内置C程程序/"><span>Android从驱动到应用(2)测试freg驱动的功能内置C程程序</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Michael</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to Michael <a href="http://lqktz.github.io/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>