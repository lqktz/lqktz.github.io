<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="简介在Android P 中针对电源管理,添加了应用分组功能.依据应用使用的频率和最近一次使用时间，对其资源请求进行优先级排序。应用待机分组一共有五个分组，系统会根据每个应用的使用情况，将其划分至五个优先分组中的一个，而每个分组对设备资源的调度各有不同的限制。">
<meta name="keywords" content="Android,Android P">
<meta property="og:type" content="article">
<meta property="og:title" content="Android P 应用分组介绍">
<meta property="og:url" content="http://yoursite.com/2019/04/10/App_Standby_Bucket/index.html">
<meta property="og:site_name" content="Michael&#39;s Home">
<meta property="og:description" content="简介在Android P 中针对电源管理,添加了应用分组功能.依据应用使用的频率和最近一次使用时间，对其资源请求进行优先级排序。应用待机分组一共有五个分组，系统会根据每个应用的使用情况，将其划分至五个优先分组中的一个，而每个分组对设备资源的调度各有不同的限制。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://raw.githubusercontent.com/lqktz/document/master/res/app_standby_bucket_001.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lqktz/document/master/res/getAppStandbyBucket.png">
<meta property="og:updated_time" content="2019-05-28T14:46:07.423Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android P 应用分组介绍">
<meta name="twitter:description" content="简介在Android P 中针对电源管理,添加了应用分组功能.依据应用使用的频率和最近一次使用时间，对其资源请求进行优先级排序。应用待机分组一共有五个分组，系统会根据每个应用的使用情况，将其划分至五个优先分组中的一个，而每个分组对设备资源的调度各有不同的限制。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/lqktz/document/master/res/app_standby_bucket_001.png">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/04/10/App_Standby_Bucket/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Android P 应用分组介绍 | Michael's Home</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Michael's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Android | Tensorflow</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-Android" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/10/App_Standby_Bucket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Michael">
      <meta itemprop="description" content="爱技术，爱生活">
      <meta itemprop="image" content="/images/Michael.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Michael's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android P 应用分组介绍

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-10 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-10T00:00:00+08:00">2019-04-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-05-28 22:46:07" itemprop="dateModified" datetime="2019-05-28T22:46:07+08:00">2019-05-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Android P 中针对电源管理,添加了应用分组功能.依据应用使用的频率和最近一次使用时间，对其资源请求进行优先级排序。<br>应用待机分组一共有五个分组，系统会根据每个应用的使用情况，将其划分至五个优先分组中的一个，而每个分组对设备资源的调度各有不同的限制。</p>
<a id="more"></a>
<h2 id="1-优先分组"><a href="#1-优先分组" class="headerlink" title="1 优先分组"></a>1 优先分组</h2><p>系统动态的分配应用到不同的组,在不同的组会有不同的限制.应用活跃度越高，所处分组的优先级就越高，也就相应地更容易获取设备资源。尤其是，应用所处的的群组决定了其所安排的任务 (job)，触发标准闹铃以及接受高优先级Firebase Cloud Messagesing信息的频率。这些限制只有在非充电状态才有效(adb shell dumpsys battery unplug),在跑Monkey时,也不会影响动态的分组,在充电状态下应用的行为不会受到限制.</p>
<p>至于如何分组,要看手机厂商制定什么规则,默认的规则是根据应用的近期使用情况进行等级划分。厂商也可以使用机器学习对应用的使用情况进行预测,将应用放在不同优先级的组.</p>
<h3 id="1-1-组的介绍"><a href="#1-1-组的介绍" class="headerlink" title="1.1 组的介绍"></a>1.1 组的介绍</h3><p>在<a href="https://developer.android.google.cn/topic/performance/power/power-details" target="_blank" rel="noopener">Power management restrictions</a>中,对不同的组有相关的介绍.</p>
<p><img src="https://raw.githubusercontent.com/lqktz/document/master/res/app_standby_bucket_001.png" alt="app_standby_bucket"></p>
<p>主要将应用分成4各组:</p>
<ul>
<li><strong>活跃 (Active)</strong>: 应用正在被使用</li>
<li><strong>工作 (Working set)</strong>: 应用使用频率很高</li>
<li><strong>常用 (Frequent)</strong>: 应用经常但不是每天被使用</li>
<li><strong>极少 (Rare)</strong>: 应用偶尔被使用</li>
</ul>
<p><strong>活跃 (Active)</strong></p>
<p>活跃应用的定义:</p>
<ul>
<li>应用启动了一个Activity；</li>
<li>应用正在运行前台服务；</li>
<li>另一个前台应用已关联至该应用 (通过同步适配器与前台应用的内容提供器相关联)；</li>
<li>用户点击了应用的推送</li>
</ul>
<p>在任务、标准闹铃以及FCM信息的资源调用上，活跃群组应用免受任何系统限制。</p>
<p><strong>工作 (Working set)</strong></p>
<p>工作组定义:</p>
<ul>
<li>若应用的运行频率很高，但目前并未处于“活跃”状态，它就会被划分至工作群组，例如用户常用的社交媒体应用。</li>
<li>该群组还包括了那些被间接使用的应用。</li>
</ul>
<p>工作分组内的应用会在任务 (job) 运行和闹铃触发方面受到部分系统限制.</p>
<p><strong>豁免(Exempted)</strong></p>
<p>豁免组的定义:</p>
<ul>
<li>应用在whitelist中,永远不会进入standby状态,所有的行为也不会被限制</li>
</ul>
<p><strong>常用 (Frequent)</strong></p>
<p>常用组的定义:</p>
<ul>
<li>常用应用指用户经常使用但不是每天使用的应用，比如用户在健身房使用的打卡应用可能就属于这一群组。</li>
</ul>
<p>系统对常用分组采用的限制更强，应用运行任务(job)和触发闹铃的能力都会受到影响，而且接受的高优先性FCM消息也有数量上限.</p>
<p><strong>极少 (Rare)</strong></p>
<p>极少组的定义:</p>
<ul>
<li>若应用的使用频率很低，它就会被划分至该分组，酒店应用就是一个很好的例子——用户只有在下榻这个酒店的时候才会打开此应用。</li>
</ul>
<p>该群组下的应用在任务 (job)、闹铃和高优先性FCM消息的资源调用上都会受到严格的限制。此外，网络访问能力也会受到影响。</p>
<p><strong>从不(Never)</strong></p>
<ul>
<li>应用安装后从来没有打开过</li>
</ul>
<h3 id="1-2-查看与设置应用分组"><a href="#1-2-查看与设置应用分组" class="headerlink" title="1.2 查看与设置应用分组"></a>1.2 查看与设置应用分组</h3><h4 id="1-2-1-应用代码里查看自身当前所在的分组"><a href="#1-2-1-应用代码里查看自身当前所在的分组" class="headerlink" title="1.2.1 应用代码里查看自身当前所在的分组"></a>1.2.1 应用代码里查看自身当前所在的分组</h4><p>APP在代码里查看自身所在的分组,使用接口<code>UsageStatsManager.getAppStandbyBucket()</code>. 该接口调用的是源码里面的<br><code>AOSP/frameworks/base/core/java/android/app/usage/UsageStatsManager.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the current standby bucket of the calling app. The system determines the standby</span><br><span class="line"> * state of the app based on app usage patterns. Standby buckets determine how much an app will</span><br><span class="line"> * be restricted from running background tasks such as jobs and alarms.</span><br><span class="line"> * &lt;p&gt;Restrictions increase progressively from &#123;@link #STANDBY_BUCKET_ACTIVE&#125; to</span><br><span class="line"> * &#123;@link #STANDBY_BUCKET_RARE&#125;, with &#123;@link #STANDBY_BUCKET_ACTIVE&#125; being the least</span><br><span class="line"> * restrictive. The battery level of the device might also affect the restrictions.</span><br><span class="line"> * &lt;p&gt;Apps in buckets &amp;le; &#123;@link #STANDBY_BUCKET_ACTIVE&#125; have no standby restrictions imposed.</span><br><span class="line"> * Apps in buckets &amp;gt; &#123;@link #STANDBY_BUCKET_FREQUENT&#125; may have network access restricted when</span><br><span class="line"> * running in the background.                                           </span><br><span class="line"> * &lt;p&gt;The standby state of an app can change at any time either due to a user interaction or a</span><br><span class="line"> * system interaction or some algorithm determining that the app can be restricted for a period</span><br><span class="line"> * of time before the user has a need for it.</span><br><span class="line"> * &lt;p&gt;You can also query the recent history of standby bucket changes by calling</span><br><span class="line"> * &#123;@link #queryEventsForSelf(long, long)&#125; and searching for</span><br><span class="line"> * &#123;@link UsageEvents.Event#STANDBY_BUCKET_CHANGED&#125;.</span><br><span class="line"> *                           </span><br><span class="line"> * @return the current standby bucket of the calling app. One of STANDBY_BUCKET_* constants.</span><br><span class="line"> */                                      </span><br><span class="line">public @StandbyBuckets int getAppStandbyBucket() &#123;</span><br><span class="line">    try &#123;                           </span><br><span class="line">        return mService.getAppStandbyBucket(mContext.getOpPackageName(),</span><br><span class="line">                mContext.getOpPackageName(),</span><br><span class="line">                mContext.getUserId());  </span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">    &#125;                    </span><br><span class="line">    return STANDBY_BUCKET_ACTIVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码里显示,通过<code>mService</code>(对应的是UsageStatsService, 源码在<code>AOSP/frameworks/base/services/usage/java/com/android/server/usage/UsageStatsService.java</code>),<br>获取the calling app的所在分组,如果获取失败,就返回<code>STANDBY_BUCKET_ACTIVE</code>, 也就是认为应用是活跃的,不会对其进行限制.从源码角度,我们看到app侧只能查看自身所<br>处的分组,而不能查看其他分组.</p>
<h4 id="1-2-2-使用-am-命令查看和设置app的分组"><a href="#1-2-2-使用-am-命令查看和设置app的分组" class="headerlink" title="1.2.2 使用 am 命令查看和设置app的分组"></a>1.2.2 使用 am 命令查看和设置app的分组</h4><p>使用<code>am</code>命令可以设置和查看app的分组, 命令使用说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set-standby-bucket [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt; active|working_set|frequent|rare</span><br><span class="line">Puts an app in the standby bucket.</span><br><span class="line">get-standby-bucket [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt;</span><br><span class="line">Returns the standby bucket of an app.</span><br></pre></td></tr></table></figure>
<p>获取所有的应用的分组:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">am get-standby-bucket</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.android.wallpaperbackup: 5</span><br><span class="line">com.android.providers.blockednumber: 40</span><br><span class="line">com.android.providers.userdictionary: 40</span><br><span class="line">com.google.vr.apps.ornament: 40</span><br><span class="line">com.android.emergency: 40</span><br><span class="line">com.google.android.inputmethod.japanese: 40</span><br><span class="line">com.android.location.fused: 5</span><br><span class="line">com.android.systemui: 30</span><br></pre></td></tr></table></figure>
<p>active|working_set|frequent|rare 分别对应 10|20|30|40 , 至于里面不是这4个数字的,是属于系统内部的分组, 不涉及三方apk分组.</p>
<p>除了<code>set-standby-bucket</code>, 和<code>get-standby-bucket</code>,还有两个am命令,也会更改app的分组:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set-inactive [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt; true|false</span><br><span class="line">Sets the inactive state of an app.</span><br><span class="line">get-inactive [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt;</span><br><span class="line">Returns the inactive state of an app.</span><br></pre></td></tr></table></figure>
<p>设置<code>set-inactive [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt; true</code> , 会将<package>设置为40.<br>设置<code>set-inactive [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt; false</code> , 会将<package>设置为10.</package></package></p>
<p>由此,可以看出,android P中将原来一刀切形式的 app standby 合并到了应用分组中了.</p>
<h3 id="2-系统层面的源码实现"><a href="#2-系统层面的源码实现" class="headerlink" title="2 系统层面的源码实现"></a>2 系统层面的源码实现</h3><p>前面,我们已经提到系统动态的调整app的组,接下来我们分析一下, 看系统层面是怎样实现的.</p>
<h4 id="2-1-设置app的bucket"><a href="#2-1-设置app的bucket" class="headerlink" title="2.1 设置app的bucket"></a>2.1 设置app的bucket</h4><p>设置app的bucket,经过层层调用,最终都调用到AppStandbyController中的reportEvent函数. 在ActivityManagerService/NotificationManagerService中都有调用到.</p>
<p>在NotificationManagerService中的调用;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private UsageStatsManagerInternal mAppUsageStats;</span><br><span class="line"></span><br><span class="line">mAppUsageStats.reportEvent(r.sbn.getPackageName(),</span><br><span class="line">               getRealUserId(r.sbn.getUserId()),</span><br><span class="line">               UsageEvents.Event.USER_INTERACTION);</span><br></pre></td></tr></table></figure>
<p>在AMS中有调用代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UsageStatsManagerInternal mUsageStatsService;</span><br><span class="line"></span><br><span class="line">mUsageStatsService.reportEvent(component.realActivity, component.userId,</span><br><span class="line">                                        UsageEvents.Event.MOVE_TO_FOREGROUND);</span><br></pre></td></tr></table></figure>
<p>这里我们以ActivityManagerService的调用为分析线路.</p>
<p>来看<code>frameworks/base/core/java/android/app/usage/UsageStatsManagerInternal.java</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public abstract class UsageStatsManagerInternal &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Reports an event to the UsageStatsManager.</span><br><span class="line">     *</span><br><span class="line">     * @param component The component for which this event occurred.</span><br><span class="line">     * @param userId The user id to which the component belongs to.</span><br><span class="line">     * @param eventType The event that occurred. Valid values can be found at</span><br><span class="line">     * &#123;@link UsageEvents&#125;</span><br><span class="line">     */</span><br><span class="line">    public abstract void reportEvent(ComponentName component, @UserIdInt int userId, int eventType);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Reports an event to the UsageStatsManager.</span><br><span class="line">     *</span><br><span class="line">     * @param packageName The package for which this event occurred.</span><br><span class="line">     * @param userId The user id to which the component belongs to.</span><br><span class="line">     * @param eventType The event that occurred. Valid values can be found at</span><br><span class="line">     * &#123;@link UsageEvents&#125;</span><br><span class="line">     */</span><br><span class="line">    public abstract void reportEvent(String packageName, @UserIdInt int userId, int eventType);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是一个抽象的接口,具体实现在<code>frameworks/base/services/usage/java/com/android/server/usage/UsageStatsService.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This local service implementation is primarily used by ActivityManagerService.</span><br><span class="line"> * ActivityManagerService will call these methods holding the &apos;am&apos; lock, which means we</span><br><span class="line"> * shouldn&apos;t be doing any IO work or other long running tasks in these methods.</span><br><span class="line"> */</span><br><span class="line">private final class LocalService extends UsageStatsManagerInternal &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">        public void reportEvent(ComponentName component, int userId, int eventType) &#123;</span><br><span class="line">            if (component == null) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Event reported without a component name&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UsageEvents.Event event = new UsageEvents.Event();</span><br><span class="line">            event.mPackage = component.getPackageName();</span><br><span class="line">            event.mClass = component.getClassName();</span><br><span class="line"></span><br><span class="line">            // This will later be converted to system time.</span><br><span class="line">            event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">            event.mEventType = eventType;</span><br><span class="line">            mHandler.obtainMessage(MSG_REPORT_EVENT, userId, 0, event).sendToTarget();// 重点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">        public void reportEvent(String packageName, int userId, int eventType) &#123;</span><br><span class="line">            if (packageName == null) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Event reported without a package name&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UsageEvents.Event event = new UsageEvents.Event();</span><br><span class="line">            event.mPackage = packageName;</span><br><span class="line"></span><br><span class="line">            // This will later be converted to system time.</span><br><span class="line">            event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">            event.mEventType = eventType;</span><br><span class="line">            mHandler.obtainMessage(MSG_REPORT_EVENT, userId, 0, event).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mHandler.obtainMessage(MSG_REPORT_EVENT, userId, 0, event).sendToTarget()</code>, 调用到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Called by the Binder stub.</span><br><span class="line"> */</span><br><span class="line">void reportEvent(UsageEvents.Event event, int userId) &#123;</span><br><span class="line">    // SPRD: bug702053, cancel event record while monkey test.</span><br><span class="line">    ActivityManagerService am = (ActivityManagerService)ActivityManager.getService();</span><br><span class="line">    if (am.isUserAMonkeyNoCheck()) &#123;</span><br><span class="line">        if (DEBUG) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;-&gt;reportEvent event:&quot; + event + &quot;, userId:&quot; + userId</span><br><span class="line">                    + &quot;, monkey test return directly&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        final long timeNow = checkAndGetTimeLocked();</span><br><span class="line">        final long elapsedRealtime = SystemClock.elapsedRealtime();</span><br><span class="line">        convertToSystemTimeLocked(event);</span><br><span class="line"></span><br><span class="line">        if (event.getPackageName() != null</span><br><span class="line">                &amp;&amp; mPackageManagerInternal.isPackageEphemeral(userId, event.getPackageName())) &#123;</span><br><span class="line">            event.mFlags |= Event.FLAG_IS_PACKAGE_INSTANT_APP;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final UserUsageStatsService service =</span><br><span class="line">            getUserDataAndInitializeIfNeededLocked(userId, timeNow);</span><br><span class="line">        service.reportEvent(event); //　检查app的bucket，详见2.3</span><br><span class="line"></span><br><span class="line">        // NOTE: Bug #627645 low power Feature BEG--&gt;</span><br><span class="line">        if (mPowerControllerHelper != null) &#123;</span><br><span class="line">            mPowerControllerHelper.reportEvent(event, userId, elapsedRealtime);</span><br><span class="line">        &#125;</span><br><span class="line">        // &lt;-- NOTE: Bug #627645 low power Feature END</span><br><span class="line"></span><br><span class="line">        mAppStandby.reportEvent(event, elapsedRealtime, userId); // 重点</span><br><span class="line">        switch (event.mEventType) &#123;</span><br><span class="line">            case Event.MOVE_TO_FOREGROUND:</span><br><span class="line">                mAppTimeLimit.moveToForeground(event.getPackageName(), event.getClassName(),</span><br><span class="line">                        userId);</span><br><span class="line">                break;</span><br><span class="line">            case Event.MOVE_TO_BACKGROUND:</span><br><span class="line">                mAppTimeLimit.moveToBackground(event.getPackageName(), event.getClassName(),</span><br><span class="line">                        userId);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mAppStandby.reportEvent</code>, 就调用到 <code>frameworks/base/services/usage/java/com/android/server/usage/AppStandbyController.java</code>AppStandbyController是应用分组功能的核心部件,用于控制应用分组的, 系统默认的动态分组的规则就在该部件中.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void reportEvent(UsageEvents.Event event, long elapsedRealtime, int userId) &#123;                      </span><br><span class="line">    if (!mAppIdleEnabled) return; // mAppIdleEnabled 是使能应用分组功能的开关</span><br><span class="line">    synchronized (mAppIdleLock) &#123;                                                                                                            </span><br><span class="line">        // TODO: Ideally this should call isAppIdleFiltered() to avoid calling back                                                          </span><br><span class="line">        // about apps that are on some kind of whitelist anyway.                                                                             </span><br><span class="line">        final boolean previouslyIdle = mAppIdleHistory.isIdle(                                                                               </span><br><span class="line">                event.mPackage, userId, elapsedRealtime);                                                                                    </span><br><span class="line">        // Inform listeners if necessary                                                                                                     </span><br><span class="line">        if ((event.mEventType == UsageEvents.Event.MOVE_TO_FOREGROUND  // 表示一个组件移动到前台                                                                      </span><br><span class="line">                    || event.mEventType == UsageEvents.Event.MOVE_TO_BACKGROUND // 标示一个组件移动到后台                                                 </span><br><span class="line">                    || event.mEventType == UsageEvents.Event.SYSTEM_INTERACTION // 该package以某种方式在和系统交互</span><br><span class="line">                    || event.mEventType == UsageEvents.Event.USER_INTERACTION // 该package以某种方式和用户交互                               </span><br><span class="line">                    || event.mEventType == UsageEvents.Event.NOTIFICATION_SEEN // 一个可见的通知                                   </span><br><span class="line">                    || event.mEventType == UsageEvents.Event.SLICE_PINNED  // slice 是android P的新特性, 被一个app 钉住的slice</span><br><span class="line">                    || event.mEventType == UsageEvents.Event.SLICE_PINNED_PRIV)) &#123;  // 一个slice被默认的launcher或者assistant钉住</span><br><span class="line"></span><br><span class="line">            final AppUsageHistory appHistory = mAppIdleHistory.getAppUsageHistory( // AppUsageHistory 存储了该用户使用该包一些数据</span><br><span class="line">                    event.mPackage, userId, elapsedRealtime);             </span><br><span class="line">            final int prevBucket = appHistory.currentBucket;                                                                                 </span><br><span class="line">            final int prevBucketReason = appHistory.bucketingReason;                                                                         </span><br><span class="line">            final long nextCheckTime;                                                                                                        </span><br><span class="line">            final int subReason = usageEventToSubReason(event.mEventType);                                                                   </span><br><span class="line">            final int reason = REASON_MAIN_USAGE | subReason;                                                                                </span><br><span class="line">            if (event.mEventType == UsageEvents.Event.NOTIFICATION_SEEN                                                                      </span><br><span class="line">                    || event.mEventType == UsageEvents.Event.SLICE_PINNED) &#123;                                                                 </span><br><span class="line">                // Mild usage elevates to WORKING_SET but doesn&apos;t change usage time. // 不改变usage  time 什么意思???</span><br><span class="line">                // mAppIdleHistory.reportUsage 作用是改变app的组, 如果要改变的新组别优先级比原来低, 就不会修改</span><br><span class="line">                mAppIdleHistory.reportUsage(appHistory, event.mPackage,</span><br><span class="line">                        STANDBY_BUCKET_WORKING_SET, subReason,// 提升到STANDBY_BUCKET_WORKING_SET</span><br><span class="line">                        0, elapsedRealtime + mNotificationSeenTimeoutMillis);</span><br><span class="line">                nextCheckTime = mNotificationSeenTimeoutMillis; // 12 小时</span><br><span class="line">            &#125; else if (event.mEventType == UsageEvents.Event.SYSTEM_INTERACTION) &#123;</span><br><span class="line">                mAppIdleHistory.reportUsage(appHistory, event.mPackage,</span><br><span class="line">                        STANDBY_BUCKET_ACTIVE, subReason,// 提升到 STANDBY_BUCKET_ACTIVE                                            </span><br><span class="line">                        0, elapsedRealtime + mSystemInteractionTimeoutMillis);</span><br><span class="line">                nextCheckTime = mSystemInteractionTimeoutMillis;// 10 分钟</span><br><span class="line">            &#125; else &#123; // 除了以上 3 种情况, 其他情况在此设置nextCheckTime</span><br><span class="line">                mAppIdleHistory.reportUsage(appHistory, event.mPackage,                                                                      </span><br><span class="line">                        STANDBY_BUCKET_ACTIVE, subReason,                                                                     </span><br><span class="line">                        elapsedRealtime, elapsedRealtime + mStrongUsageTimeoutMillis);</span><br><span class="line">                nextCheckTime = mStrongUsageTimeoutMillis; // 1 小时                                                       </span><br><span class="line">            &#125;                                                                                                                                </span><br><span class="line">            mHandler.sendMessageDelayed(mHandler.obtainMessage                                                                               </span><br><span class="line">                    (MSG_CHECK_PACKAGE_IDLE_STATE, userId, -1, event.mPackage),                                                              </span><br><span class="line">                    nextCheckTime); // 延时进行idle状态的检测和更新</span><br><span class="line">            final boolean userStartedInteracting =</span><br><span class="line">                appHistory.currentBucket == STANDBY_BUCKET_ACTIVE &amp;&amp;</span><br><span class="line">                prevBucket != appHistory.currentBucket &amp;&amp;</span><br><span class="line">                (prevBucketReason &amp; REASON_MAIN_MASK) != REASON_MAIN_USAGE;</span><br><span class="line">            maybeInformListeners(event.mPackage, userId, elapsedRealtime,</span><br><span class="line">                    appHistory.currentBucket, reason, userStartedInteracting);</span><br><span class="line"></span><br><span class="line">            if (previouslyIdle) &#123;</span><br><span class="line">                notifyBatteryStats(event.mPackage, userId, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先说一下mAppIdleEnabled, 找到设置该值的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void setAppIdleEnabled(boolean enabled) &#123;</span><br><span class="line">    mAppIdleEnabled = enabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用该方法的位置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Check if app_idle_enabled has changed                                                                                                                     </span><br><span class="line">setAppIdleEnabled(mInjector.isAppIdleEnabled());</span><br></pre></td></tr></table></figure>
<p>mInjector的类型是Injector, 这是一个AppStandbyController.java里的static class,isAppIdleEnabled实现在下面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boolean isAppIdleEnabled() &#123;                                                                                                                                     </span><br><span class="line">    final boolean buildFlag = mContext.getResources().getBoolean(                                                                                                </span><br><span class="line">            com.android.internal.R.bool.config_enableAutoPowerModes);                                                                                            </span><br><span class="line">    final boolean runtimeFlag = Global.getInt(mContext.getContentResolver(),                                                                                     </span><br><span class="line">            Global.APP_STANDBY_ENABLED, 1) == 1                                                                                                                  </span><br><span class="line">        &amp;&amp; Global.getInt(mContext.getContentResolver(),                                                                                                      </span><br><span class="line">                Global.ADAPTIVE_BATTERY_MANAGEMENT_ENABLED, 1) == 1;                                                                                                 </span><br><span class="line">    return buildFlag &amp;&amp; runtimeFlag;                                                                                                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mAppIdleEnabled是否为true(打开bucket功能), 要看config_enableAutoPowerModes 和 Global.ADAPTIVE_BATTERY_MANAGEMENT_ENABLED来决定.<br>buildFlag获取的是资源文件里的配置config_enableAutoPowerModes, 该配置在<code>frameworks/base/core/res/res/values/config.xml</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Set this to true to enable the platform&apos;s auto-power-save modes like doze and                                                                                   </span><br><span class="line">app standby.  These are not enabled by default because they require a standard                                                                                  </span><br><span class="line">cloud-to-device messaging service for apps to interact correctly with the modes                                                                                 </span><br><span class="line">(such as to be able to deliver an instant message to the device even when it is                                                                                 </span><br><span class="line"> dozing).  This should be enabled if you have such services and expect apps to                                                                                   </span><br><span class="line">correctly use them when installed on your device.  Otherwise, keep this disabled                                                                                </span><br><span class="line">so that applications can still use their own mechanisms. --&gt;                                                                                                    </span><br><span class="line">&lt;bool name=&quot;config_enableAutoPowerModes&quot;&gt;false&lt;/bool&gt;</span><br></pre></td></tr></table></figure>
<p>ADAPTIVE_BATTERY_MANAGEMENT_ENABLED和省电模式相关, 在android P中在省电模式下,所有的后台运行的app都将受到限制.</p>
<p>回到reportEvent的的异步消息处理,<code>MSG_CHECK_PACKAGE_IDLE_STATE</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case MSG_CHECK_PACKAGE_IDLE_STATE:</span><br><span class="line">        checkAndUpdateStandbyState((String) msg.obj, msg.arg1, msg.arg2,</span><br><span class="line">                   mInjector.elapsedRealtime());</span><br></pre></td></tr></table></figure>
<p>调用了checkAndUpdateStandbyState方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/** Check if we need to update the standby state of a specific app. */</span><br><span class="line">private void checkAndUpdateStandbyState(String packageName, @UserIdInt int userId,</span><br><span class="line">        int uid, long elapsedRealtime) &#123;</span><br><span class="line">    // 包是由于一些原因在白名单,那么isAppSpecial会返回true, 包将不会进入standby状态</span><br><span class="line">    final boolean isSpecial = isAppSpecial(packageName,</span><br><span class="line">            UserHandle.getAppId(uid),</span><br><span class="line">            userId);</span><br><span class="line"></span><br><span class="line">    if (isSpecial) &#123; // 对于豁免的app, 做特别的处理</span><br><span class="line">        synchronized (mAppIdleLock) &#123;</span><br><span class="line">            // STANDBY_BUCKET_EXEMPTED 的值是5, 使用am get-standby-bucket 命令查看,</span><br><span class="line">            // 一些package显示是5,就是说明是在whitelist</span><br><span class="line">            mAppIdleHistory.setAppStandbyBucket(packageName, userId, elapsedRealtime,</span><br><span class="line">                    STANDBY_BUCKET_EXEMPTED, REASON_MAIN_DEFAULT);</span><br><span class="line">        &#125;</span><br><span class="line">        // 通知监听者, 这是一个豁免的package</span><br><span class="line">        maybeInformListeners(packageName, userId, elapsedRealtime,</span><br><span class="line">                STANDBY_BUCKET_EXEMPTED, REASON_MAIN_DEFAULT, false);</span><br><span class="line">    &#125; else &#123; // 没有在白名单里的app走的分支</span><br><span class="line">        synchronized (mAppIdleLock) &#123;</span><br><span class="line">            final AppIdleHistory.AppUsageHistory app =</span><br><span class="line">                mAppIdleHistory.getAppUsageHistory(packageName,</span><br><span class="line">                        userId, elapsedRealtime);</span><br><span class="line">            int reason = app.bucketingReason;</span><br><span class="line">            final int oldMainReason = reason &amp; REASON_MAIN_MASK;</span><br><span class="line"></span><br><span class="line">            // If the bucket was forced by the user/developer, leave it alone.</span><br><span class="line">            // A usage event will be the only way to bring it out of this forced state</span><br><span class="line">            // 如果的bucket的设置原因是被用户或者开发者,强制设置的,将不会改变它的组别</span><br><span class="line">            if (oldMainReason == REASON_MAIN_FORCED) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            final int oldBucket = app.currentBucket;</span><br><span class="line">            // 动态调整buncket, 最高等级只能设置到 10 , 也就是STANDBY_BUCKET_ACTIVE</span><br><span class="line">            int newBucket = Math.max(oldBucket, STANDBY_BUCKET_ACTIVE); // Undo EXEMPTED</span><br><span class="line">            boolean predictionLate = predictionTimedOut(app, elapsedRealtime);</span><br><span class="line">            // Compute age-based bucket</span><br><span class="line">            if (oldMainReason == REASON_MAIN_DEFAULT</span><br><span class="line">                    || oldMainReason == REASON_MAIN_USAGE</span><br><span class="line">                    || oldMainReason == REASON_MAIN_TIMEOUT</span><br><span class="line">                    || predictionLate) &#123;</span><br><span class="line"></span><br><span class="line">                if (!predictionLate &amp;&amp; app.lastPredictedBucket &gt;= STANDBY_BUCKET_ACTIVE</span><br><span class="line">                        &amp;&amp; app.lastPredictedBucket &lt;= STANDBY_BUCKET_RARE) &#123;</span><br><span class="line">                    newBucket = app.lastPredictedBucket;</span><br><span class="line">                    reason = REASON_MAIN_PREDICTED | REASON_SUB_PREDICTED_RESTORED;</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        Slog.d(TAG, &quot;Restored predicted newBucket = &quot; + newBucket);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123; </span><br><span class="line">                    // 获取package应该在的新组, 这里不是当前的组, 而是将来的应该在的组别</span><br><span class="line">                    // getBucketForLocked 是一个核心的方法</span><br><span class="line">                    newBucket = getBucketForLocked(packageName, userId,</span><br><span class="line">                            elapsedRealtime);</span><br><span class="line">                    if (DEBUG) &#123;</span><br><span class="line">                        Slog.d(TAG, &quot;Evaluated AOSP newBucket = &quot; + newBucket);</span><br><span class="line">                    &#125;</span><br><span class="line">                    reason = REASON_MAIN_TIMEOUT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Check if the app is within one of the timeouts for forced bucket elevation</span><br><span class="line">            final long elapsedTimeAdjusted = mAppIdleHistory.getElapsedTime(elapsedRealtime);</span><br><span class="line">            if (newBucket &gt;= STANDBY_BUCKET_ACTIVE</span><br><span class="line">                    &amp;&amp; app.bucketActiveTimeoutTime &gt; elapsedTimeAdjusted) &#123;</span><br><span class="line">                newBucket = STANDBY_BUCKET_ACTIVE;</span><br><span class="line">                reason = app.bucketingReason;</span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line">                    Slog.d(TAG, &quot;    Keeping at ACTIVE due to min timeout&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (newBucket &gt;= STANDBY_BUCKET_WORKING_SET</span><br><span class="line">                    &amp;&amp; app.bucketWorkingSetTimeoutTime &gt; elapsedTimeAdjusted) &#123;</span><br><span class="line">                newBucket = STANDBY_BUCKET_WORKING_SET;</span><br><span class="line">                // If it was already there, keep the reason, else assume timeout to WS</span><br><span class="line">                reason = (newBucket == oldBucket)</span><br><span class="line">                    ? app.bucketingReason</span><br><span class="line">                    : REASON_MAIN_USAGE | REASON_SUB_USAGE_ACTIVE_TIMEOUT;</span><br><span class="line">                if (DEBUG) &#123;</span><br><span class="line">                    Slog.d(TAG, &quot;    Keeping at WORKING_SET due to min timeout&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                Slog.d(TAG, &quot;     Old bucket=&quot; + oldBucket</span><br><span class="line">                        + &quot;, newBucket=&quot; + newBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            if (oldBucket &lt; newBucket || predictionLate) &#123; // 注意 这里的oldBucket &lt; newBucket, 说明新的组是降优先级的组别</span><br><span class="line">                mAppIdleHistory.setAppStandbyBucket(packageName, userId, // 设置新的bucket</span><br><span class="line">                        elapsedRealtime, newBucket, reason);</span><br><span class="line">                maybeInformListeners(packageName, userId, elapsedRealtime,</span><br><span class="line">                        newBucket, reason, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>checkAndUpdateStandbyState 方法的作用就是,找出真正需要设置新的buncket的app,然后调用getBucketForLocked,获取新的bucket名称,<br>再调用mAppIdleHistory.setAppStandbyBucket 改变package的bucket, 并通知所有的监听者.</p>
<p>在这个方法里, 还要继续探究的就是getBucketForLocked 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Evaluates next bucket based on time since last used and the bucketing thresholds.</span><br><span class="line"> * @param packageName the app</span><br><span class="line"> * @param userId the user</span><br><span class="line"> * @param elapsedRealtime as the name suggests, current elapsed time</span><br><span class="line"> * @return the bucket for the app, based on time since last used</span><br><span class="line"> */</span><br><span class="line">@GuardedBy(&quot;mAppIdleLock&quot;)</span><br><span class="line">@StandbyBuckets int getBucketForLocked(String packageName, int userId,</span><br><span class="line">        long elapsedRealtime) &#123;</span><br><span class="line">    int bucketIndex = mAppIdleHistory.getThresholdIndex(packageName, userId,</span><br><span class="line">            elapsedRealtime, mAppStandbyScreenThresholds, mAppStandbyElapsedThresholds);</span><br><span class="line">    return THRESHOLD_BUCKETS[bucketIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>THRESHOLD_BUCKETS的定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final int[] THRESHOLD_BUCKETS = &#123;</span><br><span class="line">    STANDBY_BUCKET_ACTIVE,</span><br><span class="line">    STANDBY_BUCKET_WORKING_SET,</span><br><span class="line">    STANDBY_BUCKET_FREQUENT,</span><br><span class="line">    STANDBY_BUCKET_RARE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从mAppIdleHistory.getThresholdIndex获取一个index,让后在THRESHOLD_BUCKETS查找到对应的组别.在<code>getThresholdIndex(
packageName, userId, elapsedRealtime, mAppStandbyScreenThresholds, mAppStandbyElapsedThresholds);</code>中,有两个Threshold:<br><code>mAppStandbyScreenThresholds</code> 和 <code>mAppStandbyElapsedThresholds</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">long[] mAppStandbyScreenThresholds = SCREEN_TIME_THRESHOLDS;</span><br><span class="line">long[] mAppStandbyElapsedThresholds = ELAPSED_TIME_THRESHOLDS;</span><br><span class="line"></span><br><span class="line">static final boolean COMPRESS_TIME = false;</span><br><span class="line">private static final long ONE_MINUTE = 60 * 1000;</span><br><span class="line">private static final long ONE_HOUR = ONE_MINUTE * 60;</span><br><span class="line">private static final long ONE_DAY = ONE_HOUR * 24;</span><br><span class="line"></span><br><span class="line">static final long[] SCREEN_TIME_THRESHOLDS = &#123;</span><br><span class="line">    0,</span><br><span class="line">    0,</span><br><span class="line">    COMPRESS_TIME ? 120 * 1000 : 1 * ONE_HOUR,</span><br><span class="line">    COMPRESS_TIME ? 240 * 1000 : 2 * ONE_HOUR</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static final long[] ELAPSED_TIME_THRESHOLDS = &#123;</span><br><span class="line">    0,</span><br><span class="line">    COMPRESS_TIME ?  1 * ONE_MINUTE : 12 * ONE_HOUR,</span><br><span class="line">    COMPRESS_TIME ?  4 * ONE_MINUTE : 24 * ONE_HOUR,</span><br><span class="line">    COMPRESS_TIME ? 16 * ONE_MINUTE : 48 * ONE_HOUR</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来分析getThresholdIndex函数的具体实现, 该方法在<code>frameworks/base/services/usage/java/com/android/server/usage/AppIdleHistory.java</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the index in the arrays of screenTimeThresholds and elapsedTimeThresholds</span><br><span class="line"> * that corresponds to how long since the app was used.</span><br><span class="line"> * @param packageName</span><br><span class="line"> * @param userId</span><br><span class="line"> * @param elapsedRealtime current time</span><br><span class="line"> * @param screenTimeThresholds Array of screen times, in ascending order, first one is 0</span><br><span class="line"> * @param elapsedTimeThresholds Array of elapsed time, in ascending order, first one is 0</span><br><span class="line"> * @return The index whose values the app&apos;s used time exceeds (in both arrays)</span><br><span class="line"> */</span><br><span class="line">int getThresholdIndex(String packageName, int userId, long elapsedRealtime,</span><br><span class="line">        long[] screenTimeThresholds, long[] elapsedTimeThresholds) &#123;</span><br><span class="line">    ArrayMap&lt;String, AppUsageHistory&gt; userHistory = getUserHistory(userId);</span><br><span class="line">    AppUsageHistory appUsageHistory = getPackageHistory(userHistory, packageName,</span><br><span class="line">            elapsedRealtime, false);</span><br><span class="line">    // If we don&apos;t have any state for the app, assume never used</span><br><span class="line">    // 对于从来没有使用过的app , 就设置成最低级别的bucket, STANDBY_BUCKET_RARE</span><br><span class="line">    if (appUsageHistory == null) return screenTimeThresholds.length - 1;</span><br><span class="line">    // getScreenOnTime(elapsedRealtime) 获取设备的总亮屏时间(有记录在案的时间)</span><br><span class="line">    // appUsageHistory.lastUsedScreenTime app最后一次亮屏时间点,基于ScreenOn basetime</span><br><span class="line">    // screenOnDelta 计算出来就是app最后一次亮屏使用,到现在,已经有多久的亮屏时间</span><br><span class="line">    // getElapsedTime(elapsedRealtime) 获取是被从bron开始现在的时间</span><br><span class="line">    // appUsageHistory.lastUsedElapsedTime 基于ElapsedTime该package最后一次使用的时间点</span><br><span class="line">    // elapsedDelta 计算出来就是app最后一次使用到现在的时间点</span><br><span class="line">    long screenOnDelta = getScreenOnTime(elapsedRealtime) - appUsageHistory.lastUsedScreenTime;</span><br><span class="line">    long elapsedDelta = getElapsedTime(elapsedRealtime) - appUsageHistory.lastUsedElapsedTime;</span><br><span class="line"></span><br><span class="line">    if (DEBUG) Slog.d(TAG, packageName</span><br><span class="line">            + &quot; lastUsedScreen=&quot; + appUsageHistory.lastUsedScreenTime</span><br><span class="line">            + &quot; lastUsedElapsed=&quot; + appUsageHistory.lastUsedElapsedTime);</span><br><span class="line">    if (DEBUG) Slog.d(TAG, packageName + &quot; screenOn=&quot; + screenOnDelta</span><br><span class="line">            + &quot;, elapsed=&quot; + elapsedDelta);</span><br><span class="line">    for (int i = screenTimeThresholds.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        if (screenOnDelta &gt;= screenTimeThresholds[i]</span><br><span class="line">                &amp;&amp; elapsedDelta &gt;= elapsedTimeThresholds[i]) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; // 对应STANDBY_BUCKET_ACTIVE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算出screenOnDelta 和 elapsedDelta ,从for循环的便利顺序来看: </p>
<ul>
<li>screenOnDelta超过2小时, elapsedDelta超过48小时bucket为RARE</li>
<li>screenOnDelta超过1小时, elapsedDelta超过24小时bucket为FREQUENT</li>
<li>elapsedDelta超过12小时bucket为working_set</li>
</ul>
<p>虽然从for循环的顺序是上面的判断顺序,但是从时间轴的角度来看,package满足了<strong>screenOnDelta超过2小时, elapsedDelta超过48小时</strong>,一定在某个时间点也会满足<strong>screenOnDelta超过1小时, elapsedDelta超过24小时</strong>, 在满足了<strong>screenOnDelta超过1小时, elapsedDelta超过24小时</strong>,那么在某个时间点一定也就满足了<strong>elapsedDelta超过12小时</strong>. 这么来说,一个package如果是在active 的bucket, 则会先到<code>working_set</code>,再到<code>FREQUENT</code>,再到<code>RARE</code>.</p>
<h4 id="2-2-获取app的bucket"><a href="#2-2-获取app的bucket" class="headerlink" title="2.2 获取app的bucket"></a>2.2 获取app的bucket</h4><p>获取app的bucket流程比较简单:</p>
<p><img src="https://raw.githubusercontent.com/lqktz/document/master/res/getAppStandbyBucket.png" alt="获取app的bucket流程图"></p>
<p>在<code>AppIdleHistory.java</code>中的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int getAppStandbyBucket(String packageName, int userId, long elapsedRealtime) &#123;</span><br><span class="line">    ArrayMap&lt;String, AppUsageHistory&gt; userHistory = getUserHistory(userId);</span><br><span class="line">    AppUsageHistory appUsageHistory =</span><br><span class="line">        getPackageHistory(userHistory, packageName, elapsedRealtime, true);</span><br><span class="line">    return appUsageHistory.currentBucket; // 在AppUsageHistory 中获取currentBucket就是所在的组别</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-检查app的bucket"><a href="#2-3-检查app的bucket" class="headerlink" title="2.3 检查app的bucket"></a>2.3 检查app的bucket</h4><p>在前面介绍reportEvent的过程中, 有一下一段调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final UserUsageStatsService service =</span><br><span class="line">getUserDataAndInitializeIfNeededLocked(userId, timeNow);</span><br><span class="line">service.reportEvent(event); //　检查app的bucket，详见2.3</span><br></pre></td></tr></table></figure>
<p>调用了UserUsageStatsService 的report方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void reportEvent(UsageEvents.Event event) &#123;</span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, mLogPrefix + &quot;Got usage event for &quot; + event.mPackage</span><br><span class="line">                + &quot;[&quot; + event.mTimeStamp + &quot;]: &quot;</span><br><span class="line">                + eventToString(event.mEventType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // event.mTimeStamp 指该event发生的时间点,到机器开机的时间</span><br><span class="line">    // mDailyExpiryDate.getTimeInMillis() 获取的是mTime值, 该值在mDailyExpiryDate.addDays(1) 中设置为一天</span><br><span class="line">    // 此处代码逻辑是event的发生时间点在一天以上,则触发rolloverStats</span><br><span class="line">    if (event.mTimeStamp &gt;= mDailyExpiryDate.getTimeInMillis()) &#123;</span><br><span class="line">        // Need to rollover</span><br><span class="line">        rolloverStats(event.mTimeStamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      ......</span><br></pre></td></tr></table></figure>
<p>rolloverStats函数中会调用loadActiveStats函数，loadActiveStats函数会调用mListener.onStatsReloaded函数，而这个mLisener正是UsageStatsService。而UsageStatsService的onStatsReloaded函数，是调用了AppStandbyController的postOneTimeCheckIdleStates，这个函数如下，因为这个时候已经开机，因此发送了一个<code>MSG_ONE_TIME_CHECK_IDLE_STATES</code>消息. 通过该异步消息会调用到checkIdleStates, 该方法最后会调用到checkAndUpdateStandbyState,<br>调用的方式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; runningUserIds.length; i++) &#123;                                                                                                                </span><br><span class="line">    final int userId = runningUserIds[i];                                                                                                                        </span><br><span class="line">    if (checkUserId != UserHandle.USER_ALL &amp;&amp; checkUserId != userId) &#123;                                                                                           </span><br><span class="line">        continue;                                                                                                                                                </span><br><span class="line">    &#125;                                                                                                                                                            </span><br><span class="line">    if (DEBUG) &#123;                                                                                                                                                 </span><br><span class="line">        Slog.d(TAG, &quot;Checking idle state for user &quot; + userId);                                                                                                   </span><br><span class="line">    &#125;                                                                                                                                                            </span><br><span class="line">    List&lt;PackageInfo&gt; packages = mPackageManager.getInstalledPackagesAsUser(                                                                                     </span><br><span class="line">            PackageManager.MATCH_DISABLED_COMPONENTS,                                                                                                            </span><br><span class="line">            userId);                                                                                                                                             </span><br><span class="line">    final int packageCount = packages.size();                                                                                                                    </span><br><span class="line">    for (int p = 0; p &lt; packageCount; p++) &#123;                                                                                                                     </span><br><span class="line">        final PackageInfo pi = packages.get(p);                                                                                                                  </span><br><span class="line">        final String packageName = pi.packageName;                                                                                                               </span><br><span class="line">        checkAndUpdateStandbyState(packageName, userId, pi.applicationInfo.uid,                                                                                  </span><br><span class="line">                elapsedRealtime);                                                                                                                                </span><br><span class="line">    &#125;                                                                                                                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是对每个用户,每个包进行checkAndUpdateStandbyState,来更新状态.</p>
<p>在AppStandbyController里的 onBootPhase 阶段也会调用postOneTimeCheckIdleStates, 这意味着,开机会检测更新一次,之后每隔一天会检测更新一次.</p>
<p>从代码可以看出,应用待机分组和app 是否使用android P 的 SDK 开发没有关系, 所有app, 只要是安装到android P的设备上都会受到系统的限制.</p>
<h2 id="3-应用待机模式"><a href="#3-应用待机模式" class="headerlink" title="3 应用待机模式"></a>3 应用待机模式</h2><p>在android M 版本上添加了Doze  和 app standby模式, 长时间没有在前台使用, app 的行为也会受到限制,详情可见<a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby" target="_blank" rel="noopener">Optimize for Doze and App Standby</a>.<br>该功能就是将app设置为是否idle状态来进行限制, 处于idle状态的app 的网络,JobScheduler等都会限制住. 在android P中,由于添加了应用待机分组功能,app的行为被限制的更加精细化.</p>
<p>在P上的<code>AppIdleHistory.java</code>中的setIdle方法设置为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Returns the new standby bucket the app is assigned to */                                                                                                          </span><br><span class="line">public int setIdle(String packageName, int userId, boolean idle, long elapsedRealtime) &#123;                                                                             </span><br><span class="line">    ArrayMap&lt;String, AppUsageHistory&gt; userHistory = getUserHistory(userId);                                                                                          </span><br><span class="line">    AppUsageHistory appUsageHistory = getPackageHistory(userHistory, packageName,                                                                                    </span><br><span class="line">            elapsedRealtime, true);                                                                                                                                  </span><br><span class="line">    if (idle) &#123;                                                                                                                                                      </span><br><span class="line">        appUsageHistory.currentBucket = STANDBY_BUCKET_RARE;                                                                                                         </span><br><span class="line">        appUsageHistory.bucketingReason = REASON_MAIN_FORCED;                                                                                                        </span><br><span class="line">    &#125; else &#123;                                                                                                                                                         </span><br><span class="line">        appUsageHistory.currentBucket = STANDBY_BUCKET_ACTIVE;                                                                     </span><br><span class="line">        // This is to pretend that the app was just used, don&apos;t freeze the state anymore.</span><br><span class="line">        appUsageHistory.bucketingReason = REASON_MAIN_USAGE | REASON_SUB_USAGE_USER_INTERACTION;</span><br><span class="line">    &#125;                                                                                                                                                                </span><br><span class="line">    return appUsageHistory.currentBucket;                                                                                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比之前的android 版本的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void setIdle(String packageName, int userId, long elapsedRealtime) &#123;</span><br><span class="line">    ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistory(userId);</span><br><span class="line">    PackageHistory packageHistory = getPackageHistory(userHistory, packageName,</span><br><span class="line">            elapsedRealtime);</span><br><span class="line"></span><br><span class="line">    shiftHistoryToNow(userHistory, elapsedRealtime);</span><br><span class="line"></span><br><span class="line">    packageHistory.recent[HISTORY_SIZE - 1] &amp;= ~FLAG_LAST_STATE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>android P 已经把原来的standby 功能合并到了新添加的应用待机分组功能.如果是idle状态就是对应<code>STANDBY_BUCKET_RARE</code>组,不是idle就是<code>STANDBY_BUCKET_ACTIVE</code>组.</p>
<h2 id="4-限制相关源码分析"><a href="#4-限制相关源码分析" class="headerlink" title="4 限制相关源码分析"></a>4 限制相关源码分析</h2><h3 id="4-1-监听的类型"><a href="#4-1-监听的类型" class="headerlink" title="4.1 监听的类型"></a>4.1 监听的类型</h3><p>前面分析了大段的代码, 这些代码将不同的app分到了不同的组别, 每次更新组别, 都会去通知监听者,在 checkAndUpdateStandbyState 中,最后会调用<br>maybeInformListeners 来通知监听者:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** Inform listeners if the bucket has changed since it was last reported to listeners */</span><br><span class="line">private void maybeInformListeners(String packageName, int userId,</span><br><span class="line">        long elapsedRealtime, int bucket, int reason, boolean userStartedInteracting) &#123;                                                                              </span><br><span class="line">    synchronized (mAppIdleLock) &#123;</span><br><span class="line">        if (mAppIdleHistory.shouldInformListeners(packageName, userId,                                                                                               </span><br><span class="line">                    elapsedRealtime, bucket)) &#123;                                                                                                                          </span><br><span class="line">            final StandbyUpdateRecord r = StandbyUpdateRecord.obtain(packageName, userId,                                                                            </span><br><span class="line">                    bucket, reason, userStartedInteracting);                                                                                                         </span><br><span class="line">            if (DEBUG) Slog.d(TAG, &quot;Standby bucket for &quot; + packageName + &quot;=&quot; + bucket);                                                                              </span><br><span class="line">            mHandler.sendMessage(mHandler.obtainMessage(MSG_INFORM_LISTENERS, r));                                                                                   </span><br><span class="line">        &#125;                                                                                                                                                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MSG_INFORM_LISTENERS</code> 异步消息进过调用,informListeners</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case MSG_INFORM_LISTENERS:</span><br><span class="line">    StandbyUpdateRecord r = (StandbyUpdateRecord) msg.obj;</span><br><span class="line">    informListeners(r.packageName, r.userId, r.bucket, r.reason,</span><br><span class="line">        r.isUserInteraction);                                                                                                                        </span><br><span class="line">    r.recycle();</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>
<p>进入informListeners: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void informListeners(String packageName, int userId, int bucket, int reason,</span><br><span class="line">        boolean userInteraction) &#123;                                                                                                                                   </span><br><span class="line">    // app所处的buncket的优先级在RARE以及RARE之下,标记为idle</span><br><span class="line">    final boolean idle = bucket &gt;= STANDBY_BUCKET_RARE;</span><br><span class="line">    synchronized (mPackageAccessListeners) &#123;</span><br><span class="line">        for (AppIdleStateChangeListener listener : mPackageAccessListeners) &#123;</span><br><span class="line">            // onAppIdleStateChanged 用于通知监听者</span><br><span class="line">            listener.onAppIdleStateChanged(packageName, userId, idle, bucket, reason);                                                                               </span><br><span class="line">            // 用户与package交互才导致的更改bucket, 则userInteraction为true,</span><br><span class="line">            if (userInteraction) &#123;                                                                                                                                   </span><br><span class="line">                listener.onUserInteractionStarted(packageName, userId);                                                                                              </span><br><span class="line">            &#125;                                                                                                                                                        </span><br><span class="line">        &#125;                                                                                                                                                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从mPackageAccessListeners取出listener, 调用其方法onUserInteractionStarted. 重点就在分析清楚mPackageAccessListeners的结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import android.app.usage.UsageStatsManagerInternal.AppIdleStateChangeListener;</span><br><span class="line"></span><br><span class="line">@GuardedBy(&quot;mPackageAccessListeners&quot;)</span><br><span class="line">private ArrayList&lt;AppIdleStateChangeListener&gt;</span><br><span class="line">mPackageAccessListeners = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">void addListener(AppIdleStateChangeListener listener) &#123;</span><br><span class="line">    synchronized (mPackageAccessListeners) &#123;</span><br><span class="line">        if (!mPackageAccessListeners.contains(listener)) &#123;                                                                                                           </span><br><span class="line">            mPackageAccessListeners.add(listener);                                                                                                                   </span><br><span class="line">        &#125;                                                                                                                                                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void removeListener(AppIdleStateChangeListener listener) &#123;</span><br><span class="line">    synchronized (mPackageAccessListeners) &#123;</span><br><span class="line">        mPackageAccessListeners.remove(listener);                                                                                                                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的listener, 就是AppIdleStateChangeListener 类型, 而AppIdleStateChangeListener又定义在UsageStatsManagerInternal.java中: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static abstract class AppIdleStateChangeListener &#123;</span><br><span class="line"></span><br><span class="line">    /** Callback to inform listeners that the idle state has changed to a new bucket. */</span><br><span class="line">    public abstract void onAppIdleStateChanged(String packageName, @UserIdInt int userId,</span><br><span class="line">            boolean idle, int bucket, int reason);                                                                                                                   </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Callback to inform listeners that the parole state has changed. This means apps are</span><br><span class="line">     * allowed to do work even if they&apos;re idle or in a low bucket.</span><br><span class="line">     */</span><br><span class="line">    public abstract void onParoleStateChanged(boolean isParoleOn);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Optional callback to inform the listener that the app has transitioned into</span><br><span class="line">     * an active state due to user interaction.</span><br><span class="line">     */</span><br><span class="line">    public void onUserInteractionStarted(String packageName, @UserIdInt int userId) &#123;</span><br><span class="line">        // No-op by default                                                                                                                                          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是个AppIdleStateChangeListener的接口, listener对应的就是其真正的实现类:</p>
<ul>
<li>NetworkPolicyManagerService.java里的私有类AppIdleStateChangeListener</li>
<li>AlarmManagerService.java里的final类AppStandbyTracker</li>
<li>JobSchedulerService.java里的final类StandbyTracker</li>
</ul>
<p><strong>感觉这几个Listener不是同一个人写的, 命名不一致</strong></p>
<p>从接口的实现看, package在不同的组别, 将在 Network, Alarm, JobScheduler 三个方面受到限制.接下来就从三个方面分析其源码实现.<br>在<code>informListeners</code> 源码中, 调用到了<code>onAppIdleStateChanged</code> 和 <code>onUserInteractionStarted</code> 两个接口. 对于<code>onUserInteractionStarted</code><br>只有在JobScheduler中才真正的实现.<code>onAppIdleStateChanged</code> 在三个AppIdleStateChangeListener接口的实现类里都有实现.</p>
<h3 id="4-2-Network的限制"><a href="#4-2-Network的限制" class="headerlink" title="4.2 Network的限制"></a>4.2 Network的限制</h3><p><code>frameworks/base/services/core/java/com/android/server/net/NetworkPolicyManagerService.java</code> 的内部类<code>AppIdleStateChangeListener</code>定义如下:<br>这个类名和抽象类的名称一样,别搞混了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private class AppIdleStateChangeListener</span><br><span class="line">extends UsageStatsManagerInternal.AppIdleStateChangeListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">        public void onAppIdleStateChanged(String packageName, int userId, boolean idle, int bucket,                                                                      </span><br><span class="line">                int reason) &#123;                                                                                                                                            </span><br><span class="line">            try &#123;                                                                                                                                                        </span><br><span class="line">                final int uid = mContext.getPackageManager().getPackageUidAsUser(packageName,                                                                            </span><br><span class="line">                        PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);                                                                                              </span><br><span class="line">                synchronized (mUidRulesFirstLock) &#123;                                                                                                                      </span><br><span class="line">                    mLogger.appIdleStateChanged(uid, idle);                                                                                                              </span><br><span class="line">                    updateRuleForAppIdleUL(uid);                                                                                                                         </span><br><span class="line">                    updateRulesForPowerRestrictionsUL(uid);                                                                                                              </span><br><span class="line">                &#125;                                                                                                                                                        </span><br><span class="line">            &#125; catch (NameNotFoundException nnfe) &#123;                                                                                                                       </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line">        &#125;                                                                                                                                                                </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">        public void onParoleStateChanged(boolean isParoleOn) &#123;                                                                                                           </span><br><span class="line">            synchronized (mUidRulesFirstLock) &#123;                                                                                                                          </span><br><span class="line">                mLogger.paroleStateChanged(isParoleOn);                                                                                                                  </span><br><span class="line">                updateRulesForAppIdleParoleUL();                                                                                                                         </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line">        &#125;                                                                                                                                                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-Alarm的限制"><a href="#4-3-Alarm的限制" class="headerlink" title="4.3 Alarm的限制"></a>4.3 Alarm的限制</h3><p>AlarmManagerService.java里的final类AppStandbyTracker:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Tracking of app assignments to standby buckets</span><br><span class="line"> */</span><br><span class="line">final class AppStandbyTracker extends UsageStatsManagerInternal.AppIdleStateChangeListener &#123;</span><br><span class="line"></span><br><span class="line">    public void onAppIdleStateChanged(final String packageName, final @UserIdInt int userId,</span><br><span class="line">            boolean idle, int bucket, int reason) &#123;                                                                                                                  </span><br><span class="line">        mHandler.removeMessages(AlarmHandler.APP_STANDBY_BUCKET_CHANGED);                                                                                            </span><br><span class="line">        mHandler.obtainMessage(AlarmHandler.APP_STANDBY_BUCKET_CHANGED, userId, -1, packageName)                                                                     </span><br><span class="line">            .sendToTarget();                                                                                                                                     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onParoleStateChanged(boolean isParoleOn) &#123;</span><br><span class="line">        mHandler.removeMessages(AlarmHandler.APP_STANDBY_BUCKET_CHANGED);                                                                                            </span><br><span class="line">        mHandler.removeMessages(AlarmHandler.APP_STANDBY_PAROLE_CHANGED);                                                                                            </span><br><span class="line">        mHandler.obtainMessage(AlarmHandler.APP_STANDBY_PAROLE_CHANGED,                                                                                              </span><br><span class="line">                Boolean.valueOf(isParoleOn)).sendToTarget();                                                                                                         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于alarm的延时定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Keys for specifying throttling delay based on app standby bucketing</span><br><span class="line">private final String[] KEYS_APP_STANDBY_DELAY = &#123;</span><br><span class="line">        &quot;standby_active_delay&quot;,</span><br><span class="line">        &quot;standby_working_delay&quot;,</span><br><span class="line">        &quot;standby_frequent_delay&quot;,</span><br><span class="line">        &quot;standby_rare_delay&quot;,</span><br><span class="line">        &quot;standby_never_delay&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private static final long DEFAULT_MIN_FUTURITY = 5 * 1000;</span><br><span class="line">private static final long DEFAULT_MIN_INTERVAL = 60 * 1000;</span><br><span class="line">private static final long DEFAULT_MAX_INTERVAL = 365 * DateUtils.DAY_IN_MILLIS;</span><br><span class="line">private static final long DEFAULT_ALLOW_WHILE_IDLE_SHORT_TIME = DEFAULT_MIN_FUTURITY;</span><br><span class="line">private static final long DEFAULT_ALLOW_WHILE_IDLE_LONG_TIME = 9*60*1000;</span><br><span class="line">private static final long DEFAULT_ALLOW_WHILE_IDLE_WHITELIST_DURATION = 10*1000;</span><br><span class="line">private static final long DEFAULT_LISTENER_TIMEOUT = 5 * 1000;</span><br><span class="line">private final long[] DEFAULT_APP_STANDBY_DELAYS = &#123;</span><br><span class="line">        0,                       // Active</span><br><span class="line">        6 * 60_000,              // Working</span><br><span class="line">        30 * 60_000,             // Frequent</span><br><span class="line">        2 * 60 * 60_000,         // Rare</span><br><span class="line">        10 * 24 * 60 * 60_000    // Never</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>AlarmManagerService-&gt;setImplLocked</li>
<li>AlarmManagerSerivice-&gt;adjustDeliveryTimeBasedOnStandbyBucketLocked </li>
<li>AlarmManagerService-&gt;getMinDelayForBucketLocked<br>由于对alarm不熟悉,就先到这.</li>
</ul>
<h3 id="4-4-JobScheduler的限制"><a href="#4-4-JobScheduler的限制" class="headerlink" title="4.4 JobScheduler的限制"></a>4.4 JobScheduler的限制</h3><p>JobScheduler 监听实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Tracking of app assignments to standby buckets</span><br><span class="line"> */</span><br><span class="line">final class StandbyTracker extends AppIdleStateChangeListener &#123;</span><br><span class="line"></span><br><span class="line">    // AppIdleStateChangeListener interface for live updates</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">        public void onAppIdleStateChanged(final String packageName, final @UserIdInt int userId,                                                                         </span><br><span class="line">                boolean idle, int bucket, int reason) &#123;                                                                                                                  </span><br><span class="line">            final int uid = mLocalPM.getPackageUid(packageName,                                                                                                          </span><br><span class="line">                    PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);                                                                                                  </span><br><span class="line">            if (uid &lt; 0) &#123;                                                                                                                                               </span><br><span class="line">                if (DEBUG_STANDBY) &#123;                                                                                                                                     </span><br><span class="line">                    Slog.i(TAG, &quot;App idle state change for unknown app &quot;                                                                                                 </span><br><span class="line">                            + packageName + &quot;/&quot; + userId);                                                                                                               </span><br><span class="line">                &#125;                                                                                                                                                        </span><br><span class="line">                return;                                                                                                                                                  </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line"></span><br><span class="line">            final int bucketIndex = standbyBucketToBucketIndex(bucket);                                                                                                  </span><br><span class="line">            // update job bookkeeping out of band                                                                                                                        </span><br><span class="line">            BackgroundThread.getHandler().post(() -&gt; &#123;                                                                                                                   </span><br><span class="line">                    if (DEBUG_STANDBY) &#123;                                                                                                                                     </span><br><span class="line">                    Slog.i(TAG, &quot;Moving uid &quot; + uid + &quot; to bucketIndex &quot; + bucketIndex);                                                                                 </span><br><span class="line">                    &#125;                                                                                                                                                        </span><br><span class="line">                    synchronized (mLock) &#123;                                                                                                                                   </span><br><span class="line">                    mJobs.forEachJobForSourceUid(uid, job -&gt; &#123;                                                                                                           </span><br><span class="line">                        // double-check uid vs package name to disambiguate shared uids                                                                                  </span><br><span class="line">                        if (packageName.equals(job.getSourcePackageName())) &#123;                                                                                            </span><br><span class="line">                        job.setStandbyBucket(bucketIndex);  // 在JobStatus.java中修改job的app所在的bucket</span><br><span class="line">                        &#125;                                                                                                                                                </span><br><span class="line">                        &#125;);                                                                                                                                                  </span><br><span class="line">                    onControllerStateChanged();  //重点分析</span><br><span class="line">                    &#125;                                                                                                                                                        </span><br><span class="line">                    &#125;);                                                                                                                                                          </span><br><span class="line">        &#125;                                                                                                                                                                </span><br><span class="line">    @Override</span><br><span class="line">        public void onParoleStateChanged(boolean isParoleOn) &#123;                                                                                                           </span><br><span class="line">            if (DEBUG_STANDBY) &#123;                                                                                                                                         </span><br><span class="line">                Slog.i(TAG, &quot;Global parole state now &quot; + (isParoleOn ? &quot;ON&quot; : &quot;OFF&quot;));                                                                                   </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line">            mInParole = isParoleOn;                                                                                                                                      </span><br><span class="line">        &#125;                                                                                                                                                                </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">        public void onUserInteractionStarted(String packageName, int userId) &#123;                                                                                           </span><br><span class="line">            final int uid = mLocalPM.getPackageUid(packageName,                                                                                                          </span><br><span class="line">                    PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);                                                                                                  </span><br><span class="line">            if (uid &lt; 0) &#123;                                                                                                                                               </span><br><span class="line">                // Quietly ignore; the case is already logged elsewhere                                                                                                  </span><br><span class="line">                return;                                                                                                                                                  </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line"></span><br><span class="line">            long sinceLast = mUsageStats.getTimeSinceLastJobRun(packageName, userId);                                                                                    </span><br><span class="line">            if (sinceLast &gt; 2 * DateUtils.DAY_IN_MILLIS) &#123;                                                                                                               </span><br><span class="line">                // Too long ago, not worth logging                                                                                                                       </span><br><span class="line">                sinceLast = 0L;                                                                                                                                          </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line">            final DeferredJobCounter counter = new DeferredJobCounter();                                                                                                 </span><br><span class="line">            synchronized (mLock) &#123;                                                                                                                                       </span><br><span class="line">                mJobs.forEachJobForSourceUid(uid, counter);                                                                                                              </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line">            if (counter.numDeferred() &gt; 0 || sinceLast &gt; 0) &#123;                                                                                                            </span><br><span class="line">                BatteryStatsInternal mBatteryStatsInternal = LocalServices.getService                                                                                    </span><br><span class="line">                    (BatteryStatsInternal.class);                                                                                                                    </span><br><span class="line">                mBatteryStatsInternal.noteJobsDeferred(uid, counter.numDeferred(), sinceLast);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JobSchedulerService 创建的时候就添加Listener：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Set up the app standby bucketing tracker</span><br><span class="line">mStandbyTracker = new StandbyTracker();</span><br><span class="line">mUsageStats = LocalServices.getService(UsageStatsManagerInternal.class);</span><br><span class="line">mUsageStats.addAppIdleStateChangeListener(mStandbyTracker);</span><br></pre></td></tr></table></figure>
<p><code>onControllerStateChanged()</code>发送了异步消息<code>MSG_CHECK_JOB</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case MSG_CHECK_JOB:</span><br><span class="line">if (mReportedActive) &#123;</span><br><span class="line">    // if jobs are currently being run, queue all ready jobs for execution.</span><br><span class="line">    // job 正在执行执行，让其2执行完</span><br><span class="line">    queueReadyJobsForExecutionLocked();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // Check the list of jobs and run some of them if we feel inclined.</span><br><span class="line">    maybeQueueReadyJobsForExecutionLocked();</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure>
<p><code>maybeQueueReadyJobsForExecutionLocked()</code> 的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void maybeQueueReadyJobsForExecutionLocked() &#123;</span><br><span class="line">    if (DEBUG) Slog.d(TAG, &quot;Maybe queuing ready jobs...&quot;);                                                                            </span><br><span class="line">                                                                                                                                      </span><br><span class="line">    noteJobsNonpending(mPendingJobs);                                                                                                 </span><br><span class="line">    mPendingJobs.clear();                                                                                                             </span><br><span class="line">    stopNonReadyActiveJobsLocked();                                                                                                   </span><br><span class="line">    mJobs.forEachJob(mMaybeQueueFunctor);  // 会调用到MaybeReadyJobQueueFunctor的accept()方法</span><br><span class="line">                                                                        </span><br><span class="line">    mMaybeQueueFunctor.postProcess();  // mPendingJobs.addAll(runnableJobs)</span><br><span class="line">                                                                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MaybeReadyJobQueueFunctor</code> 的 accept() 会调用到isReadyToBeExecutedLocked(job):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">   /**</span><br><span class="line">    * Criteria for moving a job into the pending queue:</span><br><span class="line">    *      - It&apos;s ready.</span><br><span class="line">    *      - It&apos;s not pending.</span><br><span class="line">    *      - It&apos;s not already running on a JSC.</span><br><span class="line">    *      - The user that requested the job is running.</span><br><span class="line">    *      - The job&apos;s standby bucket has come due to be runnable.</span><br><span class="line">    *      - The component is enabled and runnable.</span><br><span class="line">    */</span><br><span class="line">   private boolean isReadyToBeExecutedLocked(JobStatus job) &#123;</span><br><span class="line">	.....</span><br><span class="line">       // If the app is in a non-active standby bucket, make sure we&apos;ve waited</span><br><span class="line">       // an appropriate amount of time since the last invocation.  During device-</span><br><span class="line">       // wide parole, standby bucketing is ignored.</span><br><span class="line">       //</span><br><span class="line">       // Jobs in &apos;active&apos; apps are not subject to standby, nor are jobs that are</span><br><span class="line">       // specifically marked as exempt.</span><br><span class="line">       if (DEBUG_STANDBY) &#123;</span><br><span class="line">           Slog.v(TAG, &quot;isReadyToBeExecutedLocked: &quot; + job.toShortString()</span><br><span class="line">                   + &quot; parole=&quot; + mInParole + &quot; active=&quot; + job.uidActive</span><br><span class="line">                   + &quot; exempt=&quot; + job.getJob().isExemptedFromAppStandby());</span><br><span class="line">       &#125;</span><br><span class="line">       if (!mInParole</span><br><span class="line">               &amp;&amp; !job.uidActive</span><br><span class="line">               &amp;&amp; !job.getJob().isExemptedFromAppStandby()) &#123;</span><br><span class="line">           final int bucket = job.getStandbyBucket();</span><br><span class="line">           if (DEBUG_STANDBY) &#123;</span><br><span class="line">               Slog.v(TAG, &quot;  bucket=&quot; + bucket + &quot; heartbeat=&quot; + mHeartbeat</span><br><span class="line">                       + &quot; next=&quot; + mNextBucketHeartbeat[bucket]);</span><br><span class="line">           &#125;</span><br><span class="line">           if (mHeartbeat &lt; mNextBucketHeartbeat[bucket]) &#123;</span><br><span class="line">               // Only skip this job if the app is still waiting for the end of its nominal</span><br><span class="line">               // bucket interval.  Once it&apos;s waited that long, we let it go ahead and clear.</span><br><span class="line">               // The final (NEVER) bucket is special; we never age those apps&apos; jobs into</span><br><span class="line">               // runnability.</span><br><span class="line">               final long appLastRan = heartbeatWhenJobsLastRun(job);</span><br><span class="line">               if (bucket &gt;= mConstants.STANDBY_BEATS.length</span><br><span class="line">                       || (mHeartbeat &gt; appLastRan</span><br><span class="line">                               &amp;&amp; mHeartbeat &lt; appLastRan + mConstants.STANDBY_BEATS[bucket])) &#123;</span><br><span class="line">                   // TODO: log/trace that we&apos;re deferring the job due to bucketing if we hit this</span><br><span class="line">                   if (job.getWhenStandbyDeferred() == 0) &#123;</span><br><span class="line">                       if (DEBUG_STANDBY) &#123;</span><br><span class="line">                           Slog.v(TAG, &quot;Bucket deferral: &quot; + mHeartbeat + &quot; &lt; &quot;</span><br><span class="line">                                   + (appLastRan + mConstants.STANDBY_BEATS[bucket])</span><br><span class="line">                                   + &quot; for &quot; + job);</span><br><span class="line">                       &#125;</span><br><span class="line">                       job.setWhenStandbyDeferred(sElapsedRealtimeClock.millis());</span><br><span class="line">                   &#125;</span><br><span class="line">                   return false;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   if (DEBUG_STANDBY) &#123;</span><br><span class="line">                       Slog.v(TAG, &quot;Bucket deferred job aged into runnability at &quot;</span><br><span class="line">                               + mHeartbeat + &quot; : &quot; + job);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>STANDBY_BEATS</code> 的定义<code>JobSchedulerService.java</code> 中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_STANDBY_WORKING_BEATS = 11;  // ~ 2 hours, with 11min beats</span><br><span class="line">private static final int DEFAULT_STANDBY_FREQUENT_BEATS = 43; // ~ 8 hours</span><br><span class="line">private static final int DEFAULT_STANDBY_RARE_BEATS = 130; // ~ 24 hours</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Mapping: standby bucket -&gt; number of heartbeats between each sweep of that</span><br><span class="line"> * bucket&apos;s jobs.</span><br><span class="line"> *</span><br><span class="line"> * Bucket assignments as recorded in the JobStatus objects are normalized to be</span><br><span class="line"> * indices into this array, rather than the raw constants used</span><br><span class="line"> * by AppIdleHistory.</span><br><span class="line"> */</span><br><span class="line">final int[] STANDBY_BEATS = &#123;</span><br><span class="line">        0,</span><br><span class="line">        DEFAULT_STANDBY_WORKING_BEATS,</span><br><span class="line">        DEFAULT_STANDBY_FREQUENT_BEATS,</span><br><span class="line">        DEFAULT_STANDBY_RARE_BEATS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经过一系列的计算,不同bucket的心跳是不一样的,这样就实现了延时实现不同bucket的JS.心跳的计算是在:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Heartbeat tracking.  The heartbeat alarm is intentionally non-wakeup.</span><br><span class="line"> */</span><br><span class="line">class HeartbeatAlarmListener implements AlarmManager.OnAlarmListener &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAlarm() &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            final long sinceLast = sElapsedRealtimeClock.millis() - mLastHeartbeatTime;</span><br><span class="line">            final long beatsElapsed = sinceLast / mConstants.STANDBY_HEARTBEAT_TIME;</span><br><span class="line">            if (beatsElapsed &gt; 0) &#123;</span><br><span class="line">                mLastHeartbeatTime += beatsElapsed * mConstants.STANDBY_HEARTBEAT_TIME;</span><br><span class="line">                advanceHeartbeatLocked(beatsElapsed); // 不让触发alarm, 就是延时</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setNextHeartbeatAlarm(); // 设置下一次alarm 时间</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块代码,具体没有研究透彻,先告一段落.</p>
<p>参考blog:</p>
<ul>
<li><a href="https://www.codetd.com/article/2898647" target="_blank" rel="noopener">Android9.0 应用待机群组</a></li>
<li><a href="https://blog.csdn.net/jilrvrtrc/article/details/81369918" target="_blank" rel="noopener">Android P 电量管理</a></li>
<li><a href="https://developer.android.google.cn/topic/performance/power/power-details" target="_blank" rel="noopener">Power management restrictions</a></li>
<li><a href="https://blog.csdn.net/weixin_42963076/article/details/82689172" target="_blank" rel="noopener">Android P新特性 —应用待机群组（#####笔记#####）</a></li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/Android-P/" rel="tag"># Android P</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/02/Android从驱动到应用(2)测试freg驱动的功能内置C程程序/" rel="next" title="Android从驱动到应用(2)测试freg驱动的功能内置C程程序">
                <i class="fa fa-chevron-left"></i> Android从驱动到应用(2)测试freg驱动的功能内置C程程序
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/10/Android-SystemServer/" rel="prev" title="Android SystemServer学习笔记">
                Android SystemServer学习笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/Michael.jpeg" alt="Michael">
            
              <p class="site-author-name" itemprop="name">Michael</p>
              <div class="site-description motion-element" itemprop="description">爱技术，爱生活</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-优先分组"><span class="nav-number">2.</span> <span class="nav-text">1 优先分组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-组的介绍"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 组的介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-查看与设置应用分组"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 查看与设置应用分组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-应用代码里查看自身当前所在的分组"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.2.1 应用代码里查看自身当前所在的分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-使用-am-命令查看和设置app的分组"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.2.2 使用 am 命令查看和设置app的分组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-系统层面的源码实现"><span class="nav-number">2.3.</span> <span class="nav-text">2 系统层面的源码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-设置app的bucket"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.1 设置app的bucket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-获取app的bucket"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.2 获取app的bucket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-检查app的bucket"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3 检查app的bucket</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-应用待机模式"><span class="nav-number">3.</span> <span class="nav-text">3 应用待机模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-限制相关源码分析"><span class="nav-number">4.</span> <span class="nav-text">4 限制相关源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-监听的类型"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 监听的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Network的限制"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 Network的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Alarm的限制"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 Alarm的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-JobScheduler的限制"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 JobScheduler的限制</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Michael</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
