<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android P 应用分组介绍"><meta name="keywords" content="Android,Android P"><meta name="author" content="Michael"><meta name="copyright" content="Michael"><title>Android P 应用分组介绍 | Michael Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-优先分组"><span class="toc-text">1 优先分组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-组的介绍"><span class="toc-text">1.1 组的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-查看与设置应用分组"><span class="toc-text">1.2 查看与设置应用分组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-应用代码里查看自身当前所在的分组"><span class="toc-text">1.2.1 应用代码里查看自身当前所在的分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-使用-am-命令查看和设置app的分组"><span class="toc-text">1.2.2 使用 am 命令查看和设置app的分组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-系统层面的源码实现"><span class="toc-text">2 系统层面的源码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-设置app的bucket"><span class="toc-text">2.1 设置app的bucket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-获取app的bucket"><span class="toc-text">2.2 获取app的bucket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-检查app的bucket"><span class="toc-text">2.3 检查app的bucket</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-应用待机模式"><span class="toc-text">3 应用待机模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-限制相关源码分析"><span class="toc-text">4 限制相关源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-监听的类型"><span class="toc-text">4.1 监听的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Network的限制"><span class="toc-text">4.2 Network的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Alarm的限制"><span class="toc-text">4.3 Alarm的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-JobScheduler的限制"><span class="toc-text">4.4 JobScheduler的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考blog"><span class="toc-text">参考blog:</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars2.githubusercontent.com/u/15813289?s=460&amp;v=4"></div><div class="author-info__name text-center">Michael</div><div class="author-info__description text-center">Android性能优化</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">18</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Michael Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">目录</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Android P 应用分组介绍</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/"> Android</a></div><div class="article-container" id="post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Android P 中针对电源管理,添加了应用分组功能.依据应用使用的频率和最近一次使用时间，对其资源请求进行优先级排序。<br>应用待机分组一共有五个分组，系统会根据每个应用的使用情况，将其划分至五个优先分组中的一个，而每个分组对设备资源的调度各有不同的限制。</p>
<h2 id="1-优先分组"><a href="#1-优先分组" class="headerlink" title="1 优先分组"></a>1 优先分组</h2><p>系统动态的分配应用到不同的组,在不同的组会有不同的限制.应用活跃度越高，所处分组的优先级就越高，也就相应地更容易获取设备资源。尤其是，应用所处的的群组决定了其所安排的任务 (job)，触发标准闹铃以及接受高优先级Firebase Cloud Messagesing信息的频率。这些限制只有在非充电状态才有效(adb shell dumpsys battery unplug),在跑Monkey时,也不会影响动态的分组,在充电状态下应用的行为不会受到限制.</p>
<p>至于如何分组,要看手机厂商制定什么规则,默认的规则是根据应用的近期使用情况进行等级划分。厂商也可以使用机器学习对应用的使用情况进行预测,将应用放在不同优先级的组.</p>
<h3 id="1-1-组的介绍"><a href="#1-1-组的介绍" class="headerlink" title="1.1 组的介绍"></a>1.1 组的介绍</h3><p>在<a href="https://developer.android.google.cn/topic/performance/power/power-details" target="_blank" rel="noopener">Power management restrictions</a>中,对不同的组有相关的介绍.</p>
<p><img src="https://raw.githubusercontent.com/lqktz/document/master/res/app_standby_bucket_001.png" alt="app_standby_bucket"></p>
<p>主要将应用分成4各组:</p>
<ul>
<li><strong>活跃 (Active)</strong>: 应用正在被使用</li>
<li><strong>工作 (Working set)</strong>: 应用使用频率很高</li>
<li><strong>常用 (Frequent)</strong>: 应用经常但不是每天被使用</li>
<li><strong>极少 (Rare)</strong>: 应用偶尔被使用</li>
</ul>
<p><strong>活跃 (Active)</strong></p>
<p>活跃应用的定义:</p>
<ul>
<li>应用启动了一个Activity；</li>
<li>应用正在运行前台服务；</li>
<li>另一个前台应用已关联至该应用 (通过同步适配器与前台应用的内容提供器相关联)；</li>
<li>用户点击了应用的推送</li>
</ul>
<p>在任务、标准闹铃以及FCM信息的资源调用上，活跃群组应用免受任何系统限制。</p>
<p><strong>工作 (Working set)</strong></p>
<p>工作组定义:</p>
<ul>
<li>若应用的运行频率很高，但目前并未处于“活跃”状态，它就会被划分至工作群组，例如用户常用的社交媒体应用。</li>
<li>该群组还包括了那些被间接使用的应用。</li>
</ul>
<p>工作分组内的应用会在任务 (job) 运行和闹铃触发方面受到部分系统限制.</p>
<p><strong>豁免(Exempted)</strong></p>
<p>豁免组的定义:</p>
<ul>
<li>应用在whitelist中,永远不会进入standby状态,所有的行为也不会被限制</li>
</ul>
<p><strong>常用 (Frequent)</strong></p>
<p>常用组的定义:</p>
<ul>
<li>常用应用指用户经常使用但不是每天使用的应用，比如用户在健身房使用的打卡应用可能就属于这一群组。</li>
</ul>
<p>系统对常用分组采用的限制更强，应用运行任务(job)和触发闹铃的能力都会受到影响，而且接受的高优先性FCM消息也有数量上限.</p>
<p><strong>极少 (Rare)</strong></p>
<p>极少组的定义:</p>
<ul>
<li>若应用的使用频率很低，它就会被划分至该分组，酒店应用就是一个很好的例子——用户只有在下榻这个酒店的时候才会打开此应用。</li>
</ul>
<p>该群组下的应用在任务 (job)、闹铃和高优先性FCM消息的资源调用上都会受到严格的限制。此外，网络访问能力也会受到影响。</p>
<p><strong>从不(Never)</strong></p>
<ul>
<li>应用安装后从来没有打开过</li>
</ul>
<h3 id="1-2-查看与设置应用分组"><a href="#1-2-查看与设置应用分组" class="headerlink" title="1.2 查看与设置应用分组"></a>1.2 查看与设置应用分组</h3><h4 id="1-2-1-应用代码里查看自身当前所在的分组"><a href="#1-2-1-应用代码里查看自身当前所在的分组" class="headerlink" title="1.2.1 应用代码里查看自身当前所在的分组"></a>1.2.1 应用代码里查看自身当前所在的分组</h4><p>APP在代码里查看自身所在的分组,使用接口<code>UsageStatsManager.getAppStandbyBucket()</code>. 该接口调用的是源码里面的<br><code>AOSP/frameworks/base/core/java/android/app/usage/UsageStatsManager.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the current standby bucket of the calling app. The system determines the standby</span></span><br><span class="line"><span class="comment"> * state of the app based on app usage patterns. Standby buckets determine how much an app will</span></span><br><span class="line"><span class="comment"> * be restricted from running background tasks such as jobs and alarms.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Restrictions increase progressively from &#123;<span class="doctag">@link</span> #STANDBY_BUCKET_ACTIVE&#125; to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #STANDBY_BUCKET_RARE&#125;, with &#123;<span class="doctag">@link</span> #STANDBY_BUCKET_ACTIVE&#125; being the least</span></span><br><span class="line"><span class="comment"> * restrictive. The battery level of the device might also affect the restrictions.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Apps in buckets &amp;le; &#123;<span class="doctag">@link</span> #STANDBY_BUCKET_ACTIVE&#125; have no standby restrictions imposed.</span></span><br><span class="line"><span class="comment"> * Apps in buckets &amp;gt; &#123;<span class="doctag">@link</span> #STANDBY_BUCKET_FREQUENT&#125; may have network access restricted when</span></span><br><span class="line"><span class="comment"> * running in the background.                                           </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The standby state of an app can change at any time either due to a user interaction or a</span></span><br><span class="line"><span class="comment"> * system interaction or some algorithm determining that the app can be restricted for a period</span></span><br><span class="line"><span class="comment"> * of time before the user has a need for it.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;You can also query the recent history of standby bucket changes by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #queryEventsForSelf(long, long)&#125; and searching for</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> UsageEvents.Event#STANDBY_BUCKET_CHANGED&#125;.</span></span><br><span class="line"><span class="comment"> *                           </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current standby bucket of the calling app. One of STANDBY_BUCKET_* constants.</span></span><br><span class="line"><span class="comment"> */</span>                                      </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@StandbyBuckets</span> <span class="function"><span class="keyword">int</span> <span class="title">getAppStandbyBucket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;                           </span><br><span class="line">        <span class="keyword">return</span> mService.getAppStandbyBucket(mContext.getOpPackageName(),</span><br><span class="line">                mContext.getOpPackageName(),</span><br><span class="line">                mContext.getUserId());  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;                    </span><br><span class="line">    <span class="keyword">return</span> STANDBY_BUCKET_ACTIVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码里显示,通过<code>mService</code>(对应的是UsageStatsService, 源码在<code>AOSP/frameworks/base/services/usage/java/com/android/server/usage/UsageStatsService.java</code>),<br>获取the calling app的所在分组,如果获取失败,就返回<code>STANDBY_BUCKET_ACTIVE</code>, 也就是认为应用是活跃的,不会对其进行限制.从源码角度,我们看到app侧只能查看自身所<br>处的分组,而不能查看其他分组.</p>
<h4 id="1-2-2-使用-am-命令查看和设置app的分组"><a href="#1-2-2-使用-am-命令查看和设置app的分组" class="headerlink" title="1.2.2 使用 am 命令查看和设置app的分组"></a>1.2.2 使用 am 命令查看和设置app的分组</h4><p>使用<code>am</code>命令可以设置和查看app的分组, 命令使用说明:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set-standby-bucket [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt; active|working_set|frequent|rare</span><br><span class="line">Puts an app in the standby bucket.</span><br><span class="line">get-standby-bucket [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt;</span><br><span class="line">Returns the standby bucket of an app.</span><br></pre></td></tr></table></figure>
<p>获取所有的应用的分组:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">am get-standby-bucket</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.android.wallpaperbackup: 5</span><br><span class="line">com.android.providers.blockednumber: 40</span><br><span class="line">com.android.providers.userdictionary: 40</span><br><span class="line">com.google.vr.apps.ornament: 40</span><br><span class="line">com.android.emergency: 40</span><br><span class="line">com.google.android.inputmethod.japanese: 40</span><br><span class="line">com.android.location.fused: 5</span><br><span class="line">com.android.systemui: 30</span><br></pre></td></tr></table></figure>
<p>active|working_set|frequent|rare 分别对应 10|20|30|40 , 至于里面不是这4个数字的,是属于系统内部的分组, 不涉及三方apk分组.</p>
<p>除了<code>set-standby-bucket</code>, 和<code>get-standby-bucket</code>,还有两个am命令,也会更改app的分组:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set-inactive [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt; true|false</span><br><span class="line">Sets the inactive state of an app.</span><br><span class="line">get-inactive [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt;</span><br><span class="line">Returns the inactive state of an app.</span><br></pre></td></tr></table></figure>
<p>设置<code>set-inactive [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt; true</code> , 会将<package>设置为40.<br>设置<code>set-inactive [--user &lt;USER_ID&gt;] &lt;PACKAGE&gt; false</code> , 会将<package>设置为10.</package></package></p>
<p>由此,可以看出,android P中将原来一刀切形式的 app standby 合并到了应用分组中了.</p>
<h2 id="2-系统层面的源码实现"><a href="#2-系统层面的源码实现" class="headerlink" title="2 系统层面的源码实现"></a>2 系统层面的源码实现</h2><p>前面,我们已经提到系统动态的调整app的组,接下来我们分析一下, 看系统层面是怎样实现的.</p>
<h3 id="2-1-设置app的bucket"><a href="#2-1-设置app的bucket" class="headerlink" title="2.1 设置app的bucket"></a>2.1 设置app的bucket</h3><p>设置app的bucket,经过层层调用,最终都调用到AppStandbyController中的reportEvent函数. 在ActivityManagerService/NotificationManagerService中都有调用到.</p>
<p>在NotificationManagerService中的调用;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UsageStatsManagerInternal mAppUsageStats;</span><br><span class="line"></span><br><span class="line">mAppUsageStats.reportEvent(r.sbn.getPackageName(),</span><br><span class="line">               getRealUserId(r.sbn.getUserId()),</span><br><span class="line">               UsageEvents.Event.USER_INTERACTION);</span><br></pre></td></tr></table></figure>
<p>在AMS中有调用代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UsageStatsManagerInternal mUsageStatsService;</span><br><span class="line"></span><br><span class="line">mUsageStatsService.reportEvent(component.realActivity, component.userId,</span><br><span class="line">                                        UsageEvents.Event.MOVE_TO_FOREGROUND);</span><br></pre></td></tr></table></figure>
<p>这里我们以ActivityManagerService的调用为分析线路.</p>
<p>来看<code>frameworks/base/core/java/android/app/usage/UsageStatsManagerInternal.java</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageStatsManagerInternal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reports an event to the UsageStatsManager.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> component The component for which this event occurred.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId The user id to which the component belongs to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventType The event that occurred. Valid values can be found at</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> UsageEvents&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(ComponentName component, @UserIdInt <span class="keyword">int</span> userId, <span class="keyword">int</span> eventType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reports an event to the UsageStatsManager.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName The package for which this event occurred.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId The user id to which the component belongs to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventType The event that occurred. Valid values can be found at</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> UsageEvents&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(String packageName, @UserIdInt <span class="keyword">int</span> userId, <span class="keyword">int</span> eventType)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是一个抽象的接口,具体实现在<code>frameworks/base/services/usage/java/com/android/server/usage/UsageStatsService.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This local service implementation is primarily used by ActivityManagerService.</span></span><br><span class="line"><span class="comment"> * ActivityManagerService will call these methods holding the 'am' lock, which means we</span></span><br><span class="line"><span class="comment"> * shouldn't be doing any IO work or other long running tasks in these methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">UsageStatsManagerInternal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(ComponentName component, <span class="keyword">int</span> userId, <span class="keyword">int</span> eventType)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Event reported without a component name"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UsageEvents.Event event = <span class="keyword">new</span> UsageEvents.Event();</span><br><span class="line">            event.mPackage = component.getPackageName();</span><br><span class="line">            event.mClass = component.getClassName();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This will later be converted to system time.</span></span><br><span class="line">            event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">            event.mEventType = eventType;</span><br><span class="line">            mHandler.obtainMessage(MSG_REPORT_EVENT, userId, <span class="number">0</span>, event).sendToTarget();<span class="comment">// 重点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">int</span> eventType)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Event reported without a package name"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UsageEvents.Event event = <span class="keyword">new</span> UsageEvents.Event();</span><br><span class="line">            event.mPackage = packageName;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This will later be converted to system time.</span></span><br><span class="line">            event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">            event.mEventType = eventType;</span><br><span class="line">            mHandler.obtainMessage(MSG_REPORT_EVENT, userId, <span class="number">0</span>, event).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mHandler.obtainMessage(MSG_REPORT_EVENT, userId, 0, event).sendToTarget()</code>, 调用到:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called by the Binder stub.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(UsageEvents.Event event, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// SPRD: bug702053, cancel event record while monkey test.</span></span><br><span class="line">    ActivityManagerService am = (ActivityManagerService)ActivityManager.getService();</span><br><span class="line">    <span class="keyword">if</span> (am.isUserAMonkeyNoCheck()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"-&gt;reportEvent event:"</span> + event + <span class="string">", userId:"</span> + userId</span><br><span class="line">                    + <span class="string">", monkey test return directly"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeNow = checkAndGetTimeLocked();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> elapsedRealtime = SystemClock.elapsedRealtime();</span><br><span class="line">        convertToSystemTimeLocked(event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event.getPackageName() != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageManagerInternal.isPackageEphemeral(userId, event.getPackageName())) &#123;</span><br><span class="line">            event.mFlags |= Event.FLAG_IS_PACKAGE_INSTANT_APP;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> UserUsageStatsService service =</span><br><span class="line">            getUserDataAndInitializeIfNeededLocked(userId, timeNow);</span><br><span class="line">        service.reportEvent(event); <span class="comment">//　检查app的bucket，详见2.3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Bug #627645 low power Feature BEG--&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (mPowerControllerHelper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPowerControllerHelper.reportEvent(event, userId, elapsedRealtime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &lt;-- <span class="doctag">NOTE:</span> Bug #627645 low power Feature END</span></span><br><span class="line"></span><br><span class="line">        mAppStandby.reportEvent(event, elapsedRealtime, userId); <span class="comment">// 重点</span></span><br><span class="line">        <span class="keyword">switch</span> (event.mEventType) &#123;</span><br><span class="line">            <span class="keyword">case</span> Event.MOVE_TO_FOREGROUND:</span><br><span class="line">                mAppTimeLimit.moveToForeground(event.getPackageName(), event.getClassName(),</span><br><span class="line">                        userId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Event.MOVE_TO_BACKGROUND:</span><br><span class="line">                mAppTimeLimit.moveToBackground(event.getPackageName(), event.getClassName(),</span><br><span class="line">                        userId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mAppStandby.reportEvent</code>, 就调用到 <code>frameworks/base/services/usage/java/com/android/server/usage/AppStandbyController.java</code>AppStandbyController是应用分组功能的核心部件,用于控制应用分组的, 系统默认的动态分组的规则就在该部件中.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(UsageEvents.Event event, <span class="keyword">long</span> elapsedRealtime, <span class="keyword">int</span> userId)</span> </span>&#123;                      </span><br><span class="line">    <span class="keyword">if</span> (!mAppIdleEnabled) <span class="keyword">return</span>; <span class="comment">// mAppIdleEnabled 是使能应用分组功能的开关</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mAppIdleLock) &#123;                                                                                                            </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Ideally this should call isAppIdleFiltered() to avoid calling back                                                          </span></span><br><span class="line">        <span class="comment">// about apps that are on some kind of whitelist anyway.                                                                             </span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> previouslyIdle = mAppIdleHistory.isIdle(                                                                               </span><br><span class="line">                event.mPackage, userId, elapsedRealtime);                                                                                    </span><br><span class="line">        <span class="comment">// Inform listeners if necessary                                                                                                     </span></span><br><span class="line">        <span class="keyword">if</span> ((event.mEventType == UsageEvents.Event.MOVE_TO_FOREGROUND  <span class="comment">// 表示一个组件移动到前台                                                                      </span></span><br><span class="line">                    || event.mEventType == UsageEvents.Event.MOVE_TO_BACKGROUND <span class="comment">// 标示一个组件移动到后台                                                 </span></span><br><span class="line">                    || event.mEventType == UsageEvents.Event.SYSTEM_INTERACTION <span class="comment">// 该package以某种方式在和系统交互</span></span><br><span class="line">                    || event.mEventType == UsageEvents.Event.USER_INTERACTION <span class="comment">// 该package以某种方式和用户交互                               </span></span><br><span class="line">                    || event.mEventType == UsageEvents.Event.NOTIFICATION_SEEN <span class="comment">// 一个可见的通知                                   </span></span><br><span class="line">                    || event.mEventType == UsageEvents.Event.SLICE_PINNED  <span class="comment">// slice 是android P的新特性, 被一个app 钉住的slice</span></span><br><span class="line">                    || event.mEventType == UsageEvents.Event.SLICE_PINNED_PRIV)) &#123;  <span class="comment">// 一个slice被默认的launcher或者assistant钉住</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> AppUsageHistory appHistory = mAppIdleHistory.getAppUsageHistory( <span class="comment">// AppUsageHistory 存储了该用户使用该包一些数据</span></span><br><span class="line">                    event.mPackage, userId, elapsedRealtime);             </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevBucket = appHistory.currentBucket;                                                                                 </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> prevBucketReason = appHistory.bucketingReason;                                                                         </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextCheckTime;                                                                                                        </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> subReason = usageEventToSubReason(event.mEventType);                                                                   </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> reason = REASON_MAIN_USAGE | subReason;                                                                                </span><br><span class="line">            <span class="keyword">if</span> (event.mEventType == UsageEvents.Event.NOTIFICATION_SEEN                                                                      </span><br><span class="line">                    || event.mEventType == UsageEvents.Event.SLICE_PINNED) &#123;                                                                 </span><br><span class="line">                <span class="comment">// Mild usage elevates to WORKING_SET but doesn't change usage time. // 不改变usage  time 什么意思???</span></span><br><span class="line">                <span class="comment">// mAppIdleHistory.reportUsage 作用是改变app的组, 如果要改变的新组别优先级比原来低, 就不会修改</span></span><br><span class="line">                mAppIdleHistory.reportUsage(appHistory, event.mPackage,</span><br><span class="line">                        STANDBY_BUCKET_WORKING_SET, subReason,<span class="comment">// 提升到STANDBY_BUCKET_WORKING_SET</span></span><br><span class="line">                        <span class="number">0</span>, elapsedRealtime + mNotificationSeenTimeoutMillis);</span><br><span class="line">                nextCheckTime = mNotificationSeenTimeoutMillis; <span class="comment">// 12 小时</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.mEventType == UsageEvents.Event.SYSTEM_INTERACTION) &#123;</span><br><span class="line">                mAppIdleHistory.reportUsage(appHistory, event.mPackage,</span><br><span class="line">                        STANDBY_BUCKET_ACTIVE, subReason,<span class="comment">// 提升到 STANDBY_BUCKET_ACTIVE                                            </span></span><br><span class="line">                        <span class="number">0</span>, elapsedRealtime + mSystemInteractionTimeoutMillis);</span><br><span class="line">                nextCheckTime = mSystemInteractionTimeoutMillis;<span class="comment">// 10 分钟</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 除了以上 3 种情况, 其他情况在此设置nextCheckTime</span></span><br><span class="line">                mAppIdleHistory.reportUsage(appHistory, event.mPackage,                                                                      </span><br><span class="line">                        STANDBY_BUCKET_ACTIVE, subReason,                                                                     </span><br><span class="line">                        elapsedRealtime, elapsedRealtime + mStrongUsageTimeoutMillis);</span><br><span class="line">                nextCheckTime = mStrongUsageTimeoutMillis; <span class="comment">// 1 小时                                                       </span></span><br><span class="line">            &#125;                                                                                                                                </span><br><span class="line">            mHandler.sendMessageDelayed(mHandler.obtainMessage                                                                               </span><br><span class="line">                    (MSG_CHECK_PACKAGE_IDLE_STATE, userId, -<span class="number">1</span>, event.mPackage),                                                              </span><br><span class="line">                    nextCheckTime); <span class="comment">// 延时进行idle状态的检测和更新</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> userStartedInteracting =</span><br><span class="line">                appHistory.currentBucket == STANDBY_BUCKET_ACTIVE &amp;&amp;</span><br><span class="line">                prevBucket != appHistory.currentBucket &amp;&amp;</span><br><span class="line">                (prevBucketReason &amp; REASON_MAIN_MASK) != REASON_MAIN_USAGE;</span><br><span class="line">            maybeInformListeners(event.mPackage, userId, elapsedRealtime,</span><br><span class="line">                    appHistory.currentBucket, reason, userStartedInteracting);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (previouslyIdle) &#123;</span><br><span class="line">                notifyBatteryStats(event.mPackage, userId, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先说一下mAppIdleEnabled, 找到设置该值的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAppIdleEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">    mAppIdleEnabled = enabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用该方法的位置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check if app_idle_enabled has changed                                                                                                                     </span></span><br><span class="line">setAppIdleEnabled(mInjector.isAppIdleEnabled());</span><br></pre></td></tr></table></figure>
<p>mInjector的类型是Injector, 这是一个AppStandbyController.java里的static class,isAppIdleEnabled实现在下面:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAppIdleEnabled</span><span class="params">()</span> </span>&#123;                                                                                                                                     </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> buildFlag = mContext.getResources().getBoolean(                                                                                                </span><br><span class="line">            com.android.internal.R.bool.config_enableAutoPowerModes);                                                                                            </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> runtimeFlag = Global.getInt(mContext.getContentResolver(),                                                                                     </span><br><span class="line">            Global.APP_STANDBY_ENABLED, <span class="number">1</span>) == <span class="number">1</span>                                                                                                                  </span><br><span class="line">        &amp;&amp; Global.getInt(mContext.getContentResolver(),                                                                                                      </span><br><span class="line">                Global.ADAPTIVE_BATTERY_MANAGEMENT_ENABLED, <span class="number">1</span>) == <span class="number">1</span>;                                                                                                 </span><br><span class="line">    <span class="keyword">return</span> buildFlag &amp;&amp; runtimeFlag;                                                                                                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mAppIdleEnabled是否为true(打开bucket功能), 要看config_enableAutoPowerModes 和 Global.ADAPTIVE_BATTERY_MANAGEMENT_ENABLED来决定.<br>buildFlag获取的是资源文件里的配置config_enableAutoPowerModes, 该配置在<code>frameworks/base/core/res/res/values/config.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Set this to true to enable the platform's auto-power-save modes like doze and                                                                                   </span></span><br><span class="line"><span class="comment">app standby.  These are not enabled by default because they require a standard                                                                                  </span></span><br><span class="line"><span class="comment">cloud-to-device messaging service for apps to interact correctly with the modes                                                                                 </span></span><br><span class="line"><span class="comment">(such as to be able to deliver an instant message to the device even when it is                                                                                 </span></span><br><span class="line"><span class="comment"> dozing).  This should be enabled if you have such services and expect apps to                                                                                   </span></span><br><span class="line"><span class="comment">correctly use them when installed on your device.  Otherwise, keep this disabled                                                                                </span></span><br><span class="line"><span class="comment">so that applications can still use their own mechanisms. --&gt;</span>                                                                                                    </span><br><span class="line"><span class="tag">&lt;<span class="name">bool</span> <span class="attr">name</span>=<span class="string">"config_enableAutoPowerModes"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ADAPTIVE_BATTERY_MANAGEMENT_ENABLED和省电模式相关, 在android P中在省电模式下,所有的后台运行的app都将受到限制.</p>
<p>回到reportEvent的的异步消息处理,<code>MSG_CHECK_PACKAGE_IDLE_STATE</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_CHECK_PACKAGE_IDLE_STATE:</span><br><span class="line">        checkAndUpdateStandbyState((String) msg.obj, msg.arg1, msg.arg2,</span><br><span class="line">                   mInjector.elapsedRealtime());</span><br></pre></td></tr></table></figure>
<p>调用了checkAndUpdateStandbyState方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Check if we need to update the standby state of a specific app. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAndUpdateStandbyState</span><span class="params">(String packageName, @UserIdInt <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> uid, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 包是由于一些原因在白名单,那么isAppSpecial会返回true, 包将不会进入standby状态</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isSpecial = isAppSpecial(packageName,</span><br><span class="line">            UserHandle.getAppId(uid),</span><br><span class="line">            userId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSpecial) &#123; <span class="comment">// 对于豁免的app, 做特别的处理</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mAppIdleLock) &#123;</span><br><span class="line">            <span class="comment">// STANDBY_BUCKET_EXEMPTED 的值是5, 使用am get-standby-bucket 命令查看,</span></span><br><span class="line">            <span class="comment">// 一些package显示是5,就是说明是在whitelist</span></span><br><span class="line">            mAppIdleHistory.setAppStandbyBucket(packageName, userId, elapsedRealtime,</span><br><span class="line">                    STANDBY_BUCKET_EXEMPTED, REASON_MAIN_DEFAULT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知监听者, 这是一个豁免的package</span></span><br><span class="line">        maybeInformListeners(packageName, userId, elapsedRealtime,</span><br><span class="line">                STANDBY_BUCKET_EXEMPTED, REASON_MAIN_DEFAULT, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有在白名单里的app走的分支</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mAppIdleLock) &#123;</span><br><span class="line">            <span class="keyword">final</span> AppIdleHistory.AppUsageHistory app =</span><br><span class="line">                mAppIdleHistory.getAppUsageHistory(packageName,</span><br><span class="line">                        userId, elapsedRealtime);</span><br><span class="line">            <span class="keyword">int</span> reason = app.bucketingReason;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> oldMainReason = reason &amp; REASON_MAIN_MASK;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the bucket was forced by the user/developer, leave it alone.</span></span><br><span class="line">            <span class="comment">// A usage event will be the only way to bring it out of this forced state</span></span><br><span class="line">            <span class="comment">// 如果的bucket的设置原因是被用户或者开发者,强制设置的,将不会改变它的组别</span></span><br><span class="line">            <span class="keyword">if</span> (oldMainReason == REASON_MAIN_FORCED) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> oldBucket = app.currentBucket;</span><br><span class="line">            <span class="comment">// 动态调整buncket, 最高等级只能设置到 10 , 也就是STANDBY_BUCKET_ACTIVE</span></span><br><span class="line">            <span class="keyword">int</span> newBucket = Math.max(oldBucket, STANDBY_BUCKET_ACTIVE); <span class="comment">// Undo EXEMPTED</span></span><br><span class="line">            <span class="keyword">boolean</span> predictionLate = predictionTimedOut(app, elapsedRealtime);</span><br><span class="line">            <span class="comment">// Compute age-based bucket</span></span><br><span class="line">            <span class="keyword">if</span> (oldMainReason == REASON_MAIN_DEFAULT</span><br><span class="line">                    || oldMainReason == REASON_MAIN_USAGE</span><br><span class="line">                    || oldMainReason == REASON_MAIN_TIMEOUT</span><br><span class="line">                    || predictionLate) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!predictionLate &amp;&amp; app.lastPredictedBucket &gt;= STANDBY_BUCKET_ACTIVE</span><br><span class="line">                        &amp;&amp; app.lastPredictedBucket &lt;= STANDBY_BUCKET_RARE) &#123;</span><br><span class="line">                    newBucket = app.lastPredictedBucket;</span><br><span class="line">                    reason = REASON_MAIN_PREDICTED | REASON_SUB_PREDICTED_RESTORED;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        Slog.d(TAG, <span class="string">"Restored predicted newBucket = "</span> + newBucket);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 获取package应该在的新组, 这里不是当前的组, 而是将来的应该在的组别</span></span><br><span class="line">                    <span class="comment">// getBucketForLocked 是一个核心的方法</span></span><br><span class="line">                    newBucket = getBucketForLocked(packageName, userId,</span><br><span class="line">                            elapsedRealtime);</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        Slog.d(TAG, <span class="string">"Evaluated AOSP newBucket = "</span> + newBucket);</span><br><span class="line">                    &#125;</span><br><span class="line">                    reason = REASON_MAIN_TIMEOUT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if the app is within one of the timeouts for forced bucket elevation</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> elapsedTimeAdjusted = mAppIdleHistory.getElapsedTime(elapsedRealtime);</span><br><span class="line">            <span class="keyword">if</span> (newBucket &gt;= STANDBY_BUCKET_ACTIVE</span><br><span class="line">                    &amp;&amp; app.bucketActiveTimeoutTime &gt; elapsedTimeAdjusted) &#123;</span><br><span class="line">                newBucket = STANDBY_BUCKET_ACTIVE;</span><br><span class="line">                reason = app.bucketingReason;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    Slog.d(TAG, <span class="string">"    Keeping at ACTIVE due to min timeout"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newBucket &gt;= STANDBY_BUCKET_WORKING_SET</span><br><span class="line">                    &amp;&amp; app.bucketWorkingSetTimeoutTime &gt; elapsedTimeAdjusted) &#123;</span><br><span class="line">                newBucket = STANDBY_BUCKET_WORKING_SET;</span><br><span class="line">                <span class="comment">// If it was already there, keep the reason, else assume timeout to WS</span></span><br><span class="line">                reason = (newBucket == oldBucket)</span><br><span class="line">                    ? app.bucketingReason</span><br><span class="line">                    : REASON_MAIN_USAGE | REASON_SUB_USAGE_ACTIVE_TIMEOUT;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    Slog.d(TAG, <span class="string">"    Keeping at WORKING_SET due to min timeout"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Slog.d(TAG, <span class="string">"     Old bucket="</span> + oldBucket</span><br><span class="line">                        + <span class="string">", newBucket="</span> + newBucket);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oldBucket &lt; newBucket || predictionLate) &#123; <span class="comment">// 注意 这里的oldBucket &lt; newBucket, 说明新的组是降优先级的组别</span></span><br><span class="line">                mAppIdleHistory.setAppStandbyBucket(packageName, userId, <span class="comment">// 设置新的bucket</span></span><br><span class="line">                        elapsedRealtime, newBucket, reason);</span><br><span class="line">                maybeInformListeners(packageName, userId, elapsedRealtime,</span><br><span class="line">                        newBucket, reason, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>checkAndUpdateStandbyState 方法的作用就是,找出真正需要设置新的buncket的app,然后调用getBucketForLocked,获取新的bucket名称,<br>再调用mAppIdleHistory.setAppStandbyBucket 改变package的bucket, 并通知所有的监听者.</p>
<p>在这个方法里, 还要继续探究的就是getBucketForLocked 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evaluates next bucket based on time since last used and the bucketing thresholds.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName the app</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId the user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elapsedRealtime as the name suggests, current elapsed time</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the bucket for the app, based on time since last used</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mAppIdleLock"</span>)</span><br><span class="line"><span class="meta">@StandbyBuckets</span> <span class="function"><span class="keyword">int</span> <span class="title">getBucketForLocked</span><span class="params">(String packageName, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bucketIndex = mAppIdleHistory.getThresholdIndex(packageName, userId,</span><br><span class="line">            elapsedRealtime, mAppStandbyScreenThresholds, mAppStandbyElapsedThresholds);</span><br><span class="line">    <span class="keyword">return</span> THRESHOLD_BUCKETS[bucketIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>THRESHOLD_BUCKETS的定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] THRESHOLD_BUCKETS = &#123;</span><br><span class="line">    STANDBY_BUCKET_ACTIVE,</span><br><span class="line">    STANDBY_BUCKET_WORKING_SET,</span><br><span class="line">    STANDBY_BUCKET_FREQUENT,</span><br><span class="line">    STANDBY_BUCKET_RARE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从mAppIdleHistory.getThresholdIndex获取一个index,让后在THRESHOLD_BUCKETS查找到对应的组别.在<code>getThresholdIndex(
packageName, userId, elapsedRealtime, mAppStandbyScreenThresholds, mAppStandbyElapsedThresholds);</code>中,有两个Threshold:<br><code>mAppStandbyScreenThresholds</code> 和 <code>mAppStandbyElapsedThresholds</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span>[] mAppStandbyScreenThresholds = SCREEN_TIME_THRESHOLDS;</span><br><span class="line"><span class="keyword">long</span>[] mAppStandbyElapsedThresholds = ELAPSED_TIME_THRESHOLDS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> COMPRESS_TIME = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ONE_MINUTE = <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ONE_HOUR = ONE_MINUTE * <span class="number">60</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ONE_DAY = ONE_HOUR * <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>[] SCREEN_TIME_THRESHOLDS = &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    COMPRESS_TIME ? <span class="number">120</span> * <span class="number">1000</span> : <span class="number">1</span> * ONE_HOUR,</span><br><span class="line">    COMPRESS_TIME ? <span class="number">240</span> * <span class="number">1000</span> : <span class="number">2</span> * ONE_HOUR</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>[] ELAPSED_TIME_THRESHOLDS = &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    COMPRESS_TIME ?  <span class="number">1</span> * ONE_MINUTE : <span class="number">12</span> * ONE_HOUR,</span><br><span class="line">    COMPRESS_TIME ?  <span class="number">4</span> * ONE_MINUTE : <span class="number">24</span> * ONE_HOUR,</span><br><span class="line">    COMPRESS_TIME ? <span class="number">16</span> * ONE_MINUTE : <span class="number">48</span> * ONE_HOUR</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来分析getThresholdIndex函数的具体实现, 该方法在<code>frameworks/base/services/usage/java/com/android/server/usage/AppIdleHistory.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the index in the arrays of screenTimeThresholds and elapsedTimeThresholds</span></span><br><span class="line"><span class="comment"> * that corresponds to how long since the app was used.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elapsedRealtime current time</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> screenTimeThresholds Array of screen times, in ascending order, first one is 0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elapsedTimeThresholds Array of elapsed time, in ascending order, first one is 0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The index whose values the app's used time exceeds (in both arrays)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getThresholdIndex</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">long</span> elapsedRealtime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span>[] screenTimeThresholds, <span class="keyword">long</span>[] elapsedTimeThresholds)</span> </span>&#123;</span><br><span class="line">    ArrayMap&lt;String, AppUsageHistory&gt; userHistory = getUserHistory(userId);</span><br><span class="line">    AppUsageHistory appUsageHistory = getPackageHistory(userHistory, packageName,</span><br><span class="line">            elapsedRealtime, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// If we don't have any state for the app, assume never used</span></span><br><span class="line">    <span class="comment">// 对于从来没有使用过的app , 就设置成最低级别的bucket, STANDBY_BUCKET_RARE</span></span><br><span class="line">    <span class="keyword">if</span> (appUsageHistory == <span class="keyword">null</span>) <span class="keyword">return</span> screenTimeThresholds.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// getScreenOnTime(elapsedRealtime) 获取设备的总亮屏时间(有记录在案的时间)</span></span><br><span class="line">    <span class="comment">// appUsageHistory.lastUsedScreenTime app最后一次亮屏时间点,基于ScreenOn basetime</span></span><br><span class="line">    <span class="comment">// screenOnDelta 计算出来就是app最后一次亮屏使用,到现在,已经有多久的亮屏时间</span></span><br><span class="line">    <span class="comment">// getElapsedTime(elapsedRealtime) 获取是被从bron开始现在的时间</span></span><br><span class="line">    <span class="comment">// appUsageHistory.lastUsedElapsedTime 基于ElapsedTime该package最后一次使用的时间点</span></span><br><span class="line">    <span class="comment">// elapsedDelta 计算出来就是app最后一次使用到现在的时间点</span></span><br><span class="line">    <span class="keyword">long</span> screenOnDelta = getScreenOnTime(elapsedRealtime) - appUsageHistory.lastUsedScreenTime;</span><br><span class="line">    <span class="keyword">long</span> elapsedDelta = getElapsedTime(elapsedRealtime) - appUsageHistory.lastUsedElapsedTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, packageName</span><br><span class="line">            + <span class="string">" lastUsedScreen="</span> + appUsageHistory.lastUsedScreenTime</span><br><span class="line">            + <span class="string">" lastUsedElapsed="</span> + appUsageHistory.lastUsedElapsedTime);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, packageName + <span class="string">" screenOn="</span> + screenOnDelta</span><br><span class="line">            + <span class="string">", elapsed="</span> + elapsedDelta);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = screenTimeThresholds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (screenOnDelta &gt;= screenTimeThresholds[i]</span><br><span class="line">                &amp;&amp; elapsedDelta &gt;= elapsedTimeThresholds[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 对应STANDBY_BUCKET_ACTIVE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算出screenOnDelta 和 elapsedDelta ,从for循环的便利顺序来看: </p>
<ul>
<li>screenOnDelta超过2小时, elapsedDelta超过48小时bucket为RARE</li>
<li>screenOnDelta超过1小时, elapsedDelta超过24小时bucket为FREQUENT</li>
<li>elapsedDelta超过12小时bucket为working_set</li>
</ul>
<p>虽然从for循环的顺序是上面的判断顺序,但是从时间轴的角度来看,package满足了<strong>screenOnDelta超过2小时, elapsedDelta超过48小时</strong>,一定在某个时间点也会满足<strong>screenOnDelta超过1小时, elapsedDelta超过24小时</strong>, 在满足了<strong>screenOnDelta超过1小时, elapsedDelta超过24小时</strong>,那么在某个时间点一定也就满足了<strong>elapsedDelta超过12小时</strong>. 这么来说,一个package如果是在active 的bucket, 则会先到<code>working_set</code>,再到<code>FREQUENT</code>,再到<code>RARE</code>.</p>
<h3 id="2-2-获取app的bucket"><a href="#2-2-获取app的bucket" class="headerlink" title="2.2 获取app的bucket"></a>2.2 获取app的bucket</h3><p>获取app的bucket流程比较简单:</p>
<p><img src="https://raw.githubusercontent.com/lqktz/document/master/res/getAppStandbyBucket.png" alt="获取app的bucket流程图"></p>
<p>在<code>AppIdleHistory.java</code>中的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAppStandbyBucket</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    ArrayMap&lt;String, AppUsageHistory&gt; userHistory = getUserHistory(userId);</span><br><span class="line">    AppUsageHistory appUsageHistory =</span><br><span class="line">        getPackageHistory(userHistory, packageName, elapsedRealtime, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> appUsageHistory.currentBucket; <span class="comment">// 在AppUsageHistory 中获取currentBucket就是所在的组别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-检查app的bucket"><a href="#2-3-检查app的bucket" class="headerlink" title="2.3 检查app的bucket"></a>2.3 检查app的bucket</h3><p>在前面介绍reportEvent的过程中, 有一下一段调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> UserUsageStatsService service =</span><br><span class="line">getUserDataAndInitializeIfNeededLocked(userId, timeNow);</span><br><span class="line">service.reportEvent(event); <span class="comment">//　检查app的bucket，详见2.3</span></span><br></pre></td></tr></table></figure>
<p>调用了UserUsageStatsService 的report方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(UsageEvents.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, mLogPrefix + <span class="string">"Got usage event for "</span> + event.mPackage</span><br><span class="line">                + <span class="string">"["</span> + event.mTimeStamp + <span class="string">"]: "</span></span><br><span class="line">                + eventToString(event.mEventType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// event.mTimeStamp 指该event发生的时间点,到机器开机的时间</span></span><br><span class="line">    <span class="comment">// mDailyExpiryDate.getTimeInMillis() 获取的是mTime值, 该值在mDailyExpiryDate.addDays(1) 中设置为一天</span></span><br><span class="line">    <span class="comment">// 此处代码逻辑是event的发生时间点在一天以上,则触发rolloverStats</span></span><br><span class="line">    <span class="keyword">if</span> (event.mTimeStamp &gt;= mDailyExpiryDate.getTimeInMillis()) &#123;</span><br><span class="line">        <span class="comment">// Need to rollover</span></span><br><span class="line">        rolloverStats(event.mTimeStamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      ......</span><br></pre></td></tr></table></figure>
<p>rolloverStats函数中会调用loadActiveStats函数，loadActiveStats函数会调用mListener.onStatsReloaded函数，而这个mLisener正是UsageStatsService。而UsageStatsService的onStatsReloaded函数，是调用了AppStandbyController的postOneTimeCheckIdleStates，这个函数如下，因为这个时候已经开机，因此发送了一个<code>MSG_ONE_TIME_CHECK_IDLE_STATES</code>消息. 通过该异步消息会调用到checkIdleStates, 该方法最后会调用到checkAndUpdateStandbyState,<br>调用的方式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; runningUserIds.length; i++) &#123;                                                                                                                </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = runningUserIds[i];                                                                                                                        </span><br><span class="line">    <span class="keyword">if</span> (checkUserId != UserHandle.USER_ALL &amp;&amp; checkUserId != userId) &#123;                                                                                           </span><br><span class="line">        <span class="keyword">continue</span>;                                                                                                                                                </span><br><span class="line">    &#125;                                                                                                                                                            </span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;                                                                                                                                                 </span><br><span class="line">        Slog.d(TAG, <span class="string">"Checking idle state for user "</span> + userId);                                                                                                   </span><br><span class="line">    &#125;                                                                                                                                                            </span><br><span class="line">    List&lt;PackageInfo&gt; packages = mPackageManager.getInstalledPackagesAsUser(                                                                                     </span><br><span class="line">            PackageManager.MATCH_DISABLED_COMPONENTS,                                                                                                            </span><br><span class="line">            userId);                                                                                                                                             </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> packageCount = packages.size();                                                                                                                    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; packageCount; p++) &#123;                                                                                                                     </span><br><span class="line">        <span class="keyword">final</span> PackageInfo pi = packages.get(p);                                                                                                                  </span><br><span class="line">        <span class="keyword">final</span> String packageName = pi.packageName;                                                                                                               </span><br><span class="line">        checkAndUpdateStandbyState(packageName, userId, pi.applicationInfo.uid,                                                                                  </span><br><span class="line">                elapsedRealtime);                                                                                                                                </span><br><span class="line">    &#125;                                                                                                                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是对每个用户,每个包进行checkAndUpdateStandbyState,来更新状态.</p>
<p>在AppStandbyController里的 onBootPhase 阶段也会调用postOneTimeCheckIdleStates, 这意味着,开机会检测更新一次,之后每隔一天会检测更新一次.</p>
<p>从代码可以看出,应用待机分组和app 是否使用android P 的 SDK 开发没有关系, 所有app, 只要是安装到android P的设备上都会受到系统的限制.</p>
<h2 id="3-应用待机模式"><a href="#3-应用待机模式" class="headerlink" title="3 应用待机模式"></a>3 应用待机模式</h2><p>在android M 版本上添加了Doze  和 app standby模式, 长时间没有在前台使用, app 的行为也会受到限制,详情可见<a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby" target="_blank" rel="noopener">Optimize for Doze and App Standby</a>.<br>该功能就是将app设置为是否idle状态来进行限制, 处于idle状态的app 的网络,JobScheduler等都会限制住. 在android P中,由于添加了应用待机分组功能,app的行为被限制的更加精细化.</p>
<p>在P上的<code>AppIdleHistory.java</code>中的setIdle方法设置为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns the new standby bucket the app is assigned to */</span>                                                                                                          </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">setIdle</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> idle, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;                                                                             </span><br><span class="line">    ArrayMap&lt;String, AppUsageHistory&gt; userHistory = getUserHistory(userId);                                                                                          </span><br><span class="line">    AppUsageHistory appUsageHistory = getPackageHistory(userHistory, packageName,                                                                                    </span><br><span class="line">            elapsedRealtime, <span class="keyword">true</span>);                                                                                                                                  </span><br><span class="line">    <span class="keyword">if</span> (idle) &#123;                                                                                                                                                      </span><br><span class="line">        appUsageHistory.currentBucket = STANDBY_BUCKET_RARE;                                                                                                         </span><br><span class="line">        appUsageHistory.bucketingReason = REASON_MAIN_FORCED;                                                                                                        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                                                                                                         </span><br><span class="line">        appUsageHistory.currentBucket = STANDBY_BUCKET_ACTIVE;                                                                     </span><br><span class="line">        <span class="comment">// This is to pretend that the app was just used, don't freeze the state anymore.</span></span><br><span class="line">        appUsageHistory.bucketingReason = REASON_MAIN_USAGE | REASON_SUB_USAGE_USER_INTERACTION;</span><br><span class="line">    &#125;                                                                                                                                                                </span><br><span class="line">    <span class="keyword">return</span> appUsageHistory.currentBucket;                                                                                                                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比之前的android 版本的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdle</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistory(userId);</span><br><span class="line">    PackageHistory packageHistory = getPackageHistory(userHistory, packageName,</span><br><span class="line">            elapsedRealtime);</span><br><span class="line"></span><br><span class="line">    shiftHistoryToNow(userHistory, elapsedRealtime);</span><br><span class="line"></span><br><span class="line">    packageHistory.recent[HISTORY_SIZE - <span class="number">1</span>] &amp;= ~FLAG_LAST_STATE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>android P 已经把原来的standby 功能合并到了新添加的应用待机分组功能.如果是idle状态就是对应<code>STANDBY_BUCKET_RARE</code>组,不是idle就是<code>STANDBY_BUCKET_ACTIVE</code>组.</p>
<h2 id="4-限制相关源码分析"><a href="#4-限制相关源码分析" class="headerlink" title="4 限制相关源码分析"></a>4 限制相关源码分析</h2><h3 id="4-1-监听的类型"><a href="#4-1-监听的类型" class="headerlink" title="4.1 监听的类型"></a>4.1 监听的类型</h3><p>前面分析了大段的代码, 这些代码将不同的app分到了不同的组别, 每次更新组别, 都会去通知监听者,在 checkAndUpdateStandbyState 中,最后会调用<br>maybeInformListeners 来通知监听者:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Inform listeners if the bucket has changed since it was last reported to listeners */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeInformListeners</span><span class="params">(String packageName, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> elapsedRealtime, <span class="keyword">int</span> bucket, <span class="keyword">int</span> reason, <span class="keyword">boolean</span> userStartedInteracting)</span> </span>&#123;                                                                              </span><br><span class="line">    <span class="keyword">synchronized</span> (mAppIdleLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAppIdleHistory.shouldInformListeners(packageName, userId,                                                                                               </span><br><span class="line">                    elapsedRealtime, bucket)) &#123;                                                                                                                          </span><br><span class="line">            <span class="keyword">final</span> StandbyUpdateRecord r = StandbyUpdateRecord.obtain(packageName, userId,                                                                            </span><br><span class="line">                    bucket, reason, userStartedInteracting);                                                                                                         </span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Standby bucket for "</span> + packageName + <span class="string">"="</span> + bucket);                                                                              </span><br><span class="line">            mHandler.sendMessage(mHandler.obtainMessage(MSG_INFORM_LISTENERS, r));                                                                                   </span><br><span class="line">        &#125;                                                                                                                                                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MSG_INFORM_LISTENERS</code> 异步消息进过调用,informListeners</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_INFORM_LISTENERS:</span><br><span class="line">    StandbyUpdateRecord r = (StandbyUpdateRecord) msg.obj;</span><br><span class="line">    informListeners(r.packageName, r.userId, r.bucket, r.reason,</span><br><span class="line">        r.isUserInteraction);                                                                                                                        </span><br><span class="line">    r.recycle();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>进入informListeners: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">informListeners</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">int</span> bucket, <span class="keyword">int</span> reason,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> userInteraction)</span> </span>&#123;                                                                                                                                   </span><br><span class="line">    <span class="comment">// app所处的buncket的优先级在RARE以及RARE之下,标记为idle</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> idle = bucket &gt;= STANDBY_BUCKET_RARE;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackageAccessListeners) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AppIdleStateChangeListener listener : mPackageAccessListeners) &#123;</span><br><span class="line">            <span class="comment">// onAppIdleStateChanged 用于通知监听者</span></span><br><span class="line">            listener.onAppIdleStateChanged(packageName, userId, idle, bucket, reason);                                                                               </span><br><span class="line">            <span class="comment">// 用户与package交互才导致的更改bucket, 则userInteraction为true,</span></span><br><span class="line">            <span class="keyword">if</span> (userInteraction) &#123;                                                                                                                                   </span><br><span class="line">                listener.onUserInteractionStarted(packageName, userId);                                                                                              </span><br><span class="line">            &#125;                                                                                                                                                        </span><br><span class="line">        &#125;                                                                                                                                                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从mPackageAccessListeners取出listener, 调用其方法onUserInteractionStarted. 重点就在分析清楚mPackageAccessListeners的结构:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.usage.UsageStatsManagerInternal.AppIdleStateChangeListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"mPackageAccessListeners"</span>)</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;AppIdleStateChangeListener&gt;</span><br><span class="line">mPackageAccessListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addListener</span><span class="params">(AppIdleStateChangeListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackageAccessListeners) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mPackageAccessListeners.contains(listener)) &#123;                                                                                                           </span><br><span class="line">            mPackageAccessListeners.add(listener);                                                                                                                   </span><br><span class="line">        &#125;                                                                                                                                                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(AppIdleStateChangeListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackageAccessListeners) &#123;</span><br><span class="line">        mPackageAccessListeners.remove(listener);                                                                                                                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的listener, 就是AppIdleStateChangeListener 类型, 而AppIdleStateChangeListener又定义在UsageStatsManagerInternal.java中: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppIdleStateChangeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Callback to inform listeners that the idle state has changed to a new bucket. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onAppIdleStateChanged</span><span class="params">(String packageName, @UserIdInt <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> idle, <span class="keyword">int</span> bucket, <span class="keyword">int</span> reason)</span></span>;                                                                                                                   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callback to inform listeners that the parole state has changed. This means apps are</span></span><br><span class="line"><span class="comment">     * allowed to do work even if they're idle or in a low bucket.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onParoleStateChanged</span><span class="params">(<span class="keyword">boolean</span> isParoleOn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Optional callback to inform the listener that the app has transitioned into</span></span><br><span class="line"><span class="comment">     * an active state due to user interaction.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUserInteractionStarted</span><span class="params">(String packageName, @UserIdInt <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// No-op by default                                                                                                                                          </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是个AppIdleStateChangeListener的接口, listener对应的就是其真正的实现类:</p>
<ul>
<li>NetworkPolicyManagerService.java里的私有类AppIdleStateChangeListener</li>
<li>AlarmManagerService.java里的final类AppStandbyTracker</li>
<li>JobSchedulerService.java里的final类StandbyTracker</li>
</ul>
<p><strong>感觉这几个Listener不是同一个人写的, 命名不一致</strong></p>
<p>从接口的实现看, package在不同的组别, 将在 Network, Alarm, JobScheduler 三个方面受到限制.接下来就从三个方面分析其源码实现.<br>在<code>informListeners</code> 源码中, 调用到了<code>onAppIdleStateChanged</code> 和 <code>onUserInteractionStarted</code> 两个接口. 对于<code>onUserInteractionStarted</code><br>只有在JobScheduler中才真正的实现.<code>onAppIdleStateChanged</code> 在三个AppIdleStateChangeListener接口的实现类里都有实现.</p>
<h3 id="4-2-Network的限制"><a href="#4-2-Network的限制" class="headerlink" title="4.2 Network的限制"></a>4.2 Network的限制</h3><p><code>frameworks/base/services/core/java/com/android/server/net/NetworkPolicyManagerService.java</code> 的内部类<code>AppIdleStateChangeListener</code>定义如下:<br>这个类名和抽象类的名称一样,别搞混了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AppIdleStateChangeListener</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">UsageStatsManagerInternal</span>.<span class="title">AppIdleStateChangeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppIdleStateChanged</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> idle, <span class="keyword">int</span> bucket,                                                                      </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> reason)</span> </span>&#123;                                                                                                                                            </span><br><span class="line">            <span class="keyword">try</span> &#123;                                                                                                                                                        </span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> uid = mContext.getPackageManager().getPackageUidAsUser(packageName,                                                                            </span><br><span class="line">                        PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);                                                                                              </span><br><span class="line">                <span class="keyword">synchronized</span> (mUidRulesFirstLock) &#123;                                                                                                                      </span><br><span class="line">                    mLogger.appIdleStateChanged(uid, idle);                                                                                                              </span><br><span class="line">                    updateRuleForAppIdleUL(uid);                                                                                                                         </span><br><span class="line">                    updateRulesForPowerRestrictionsUL(uid);                                                                                                              </span><br><span class="line">                &#125;                                                                                                                                                        </span><br><span class="line">            &#125; <span class="keyword">catch</span> (NameNotFoundException nnfe) &#123;                                                                                                                       </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line">        &#125;                                                                                                                                                                </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onParoleStateChanged</span><span class="params">(<span class="keyword">boolean</span> isParoleOn)</span> </span>&#123;                                                                                                           </span><br><span class="line">            <span class="keyword">synchronized</span> (mUidRulesFirstLock) &#123;                                                                                                                          </span><br><span class="line">                mLogger.paroleStateChanged(isParoleOn);                                                                                                                  </span><br><span class="line">                updateRulesForAppIdleParoleUL();                                                                                                                         </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line">        &#125;                                                                                                                                                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-Alarm的限制"><a href="#4-3-Alarm的限制" class="headerlink" title="4.3 Alarm的限制"></a>4.3 Alarm的限制</h3><p>AlarmManagerService.java里的final类AppStandbyTracker:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tracking of app assignments to standby buckets</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppStandbyTracker</span> <span class="keyword">extends</span> <span class="title">UsageStatsManagerInternal</span>.<span class="title">AppIdleStateChangeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppIdleStateChanged</span><span class="params">(<span class="keyword">final</span> String packageName, <span class="keyword">final</span> @UserIdInt <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> idle, <span class="keyword">int</span> bucket, <span class="keyword">int</span> reason)</span> </span>&#123;                                                                                                                  </span><br><span class="line">        mHandler.removeMessages(AlarmHandler.APP_STANDBY_BUCKET_CHANGED);                                                                                            </span><br><span class="line">        mHandler.obtainMessage(AlarmHandler.APP_STANDBY_BUCKET_CHANGED, userId, -<span class="number">1</span>, packageName)                                                                     </span><br><span class="line">            .sendToTarget();                                                                                                                                     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onParoleStateChanged</span><span class="params">(<span class="keyword">boolean</span> isParoleOn)</span> </span>&#123;</span><br><span class="line">        mHandler.removeMessages(AlarmHandler.APP_STANDBY_BUCKET_CHANGED);                                                                                            </span><br><span class="line">        mHandler.removeMessages(AlarmHandler.APP_STANDBY_PAROLE_CHANGED);                                                                                            </span><br><span class="line">        mHandler.obtainMessage(AlarmHandler.APP_STANDBY_PAROLE_CHANGED,                                                                                              </span><br><span class="line">                Boolean.valueOf(isParoleOn)).sendToTarget();                                                                                                         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于alarm的延时定义:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Keys for specifying throttling delay based on app standby bucketing</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] KEYS_APP_STANDBY_DELAY = &#123;</span><br><span class="line">        <span class="string">"standby_active_delay"</span>,</span><br><span class="line">        <span class="string">"standby_working_delay"</span>,</span><br><span class="line">        <span class="string">"standby_frequent_delay"</span>,</span><br><span class="line">        <span class="string">"standby_rare_delay"</span>,</span><br><span class="line">        <span class="string">"standby_never_delay"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_MIN_FUTURITY = <span class="number">5</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_MIN_INTERVAL = <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_MAX_INTERVAL = <span class="number">365</span> * DateUtils.DAY_IN_MILLIS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_ALLOW_WHILE_IDLE_SHORT_TIME = DEFAULT_MIN_FUTURITY;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_ALLOW_WHILE_IDLE_LONG_TIME = <span class="number">9</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_ALLOW_WHILE_IDLE_WHITELIST_DURATION = <span class="number">10</span>*<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_LISTENER_TIMEOUT = <span class="number">5</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] DEFAULT_APP_STANDBY_DELAYS = &#123;</span><br><span class="line">        <span class="number">0</span>,                       <span class="comment">// Active</span></span><br><span class="line">        <span class="number">6</span> * <span class="number">60_000</span>,              <span class="comment">// Working</span></span><br><span class="line">        <span class="number">30</span> * <span class="number">60_000</span>,             <span class="comment">// Frequent</span></span><br><span class="line">        <span class="number">2</span> * <span class="number">60</span> * <span class="number">60_000</span>,         <span class="comment">// Rare</span></span><br><span class="line">        <span class="number">10</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60_000</span>    <span class="comment">// Never</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>AlarmManagerService-&gt;setImplLocked</li>
<li>AlarmManagerSerivice-&gt;adjustDeliveryTimeBasedOnStandbyBucketLocked </li>
<li>AlarmManagerService-&gt;getMinDelayForBucketLocked<br>由于对alarm不熟悉,就先到这.</li>
</ul>
<h3 id="4-4-JobScheduler的限制"><a href="#4-4-JobScheduler的限制" class="headerlink" title="4.4 JobScheduler的限制"></a>4.4 JobScheduler的限制</h3><p>JobScheduler 监听实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tracking of app assignments to standby buckets</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandbyTracker</span> <span class="keyword">extends</span> <span class="title">AppIdleStateChangeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AppIdleStateChangeListener interface for live updates</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppIdleStateChanged</span><span class="params">(<span class="keyword">final</span> String packageName, <span class="keyword">final</span> @UserIdInt <span class="keyword">int</span> userId,                                                                         </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> idle, <span class="keyword">int</span> bucket, <span class="keyword">int</span> reason)</span> </span>&#123;                                                                                                                  </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> uid = mLocalPM.getPackageUid(packageName,                                                                                                          </span><br><span class="line">                    PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);                                                                                                  </span><br><span class="line">            <span class="keyword">if</span> (uid &lt; <span class="number">0</span>) &#123;                                                                                                                                               </span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STANDBY) &#123;                                                                                                                                     </span><br><span class="line">                    Slog.i(TAG, <span class="string">"App idle state change for unknown app "</span>                                                                                                 </span><br><span class="line">                            + packageName + <span class="string">"/"</span> + userId);                                                                                                               </span><br><span class="line">                &#125;                                                                                                                                                        </span><br><span class="line">                <span class="keyword">return</span>;                                                                                                                                                  </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> bucketIndex = standbyBucketToBucketIndex(bucket);                                                                                                  </span><br><span class="line">            <span class="comment">// update job bookkeeping out of band                                                                                                                        </span></span><br><span class="line">            BackgroundThread.getHandler().post(() -&gt; &#123;                                                                                                                   </span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_STANDBY) &#123;                                                                                                                                     </span><br><span class="line">                    Slog.i(TAG, <span class="string">"Moving uid "</span> + uid + <span class="string">" to bucketIndex "</span> + bucketIndex);                                                                                 </span><br><span class="line">                    &#125;                                                                                                                                                        </span><br><span class="line">                    <span class="keyword">synchronized</span> (mLock) &#123;                                                                                                                                   </span><br><span class="line">                    mJobs.forEachJobForSourceUid(uid, job -&gt; &#123;                                                                                                           </span><br><span class="line">                        <span class="comment">// double-check uid vs package name to disambiguate shared uids                                                                                  </span></span><br><span class="line">                        <span class="keyword">if</span> (packageName.equals(job.getSourcePackageName())) &#123;                                                                                            </span><br><span class="line">                        job.setStandbyBucket(bucketIndex);  <span class="comment">// 在JobStatus.java中修改job的app所在的bucket</span></span><br><span class="line">                        &#125;                                                                                                                                                </span><br><span class="line">                        &#125;);                                                                                                                                                  </span><br><span class="line">                    onControllerStateChanged();  <span class="comment">//重点分析</span></span><br><span class="line">                    &#125;                                                                                                                                                        </span><br><span class="line">                    &#125;);                                                                                                                                                          </span><br><span class="line">        &#125;                                                                                                                                                                </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onParoleStateChanged</span><span class="params">(<span class="keyword">boolean</span> isParoleOn)</span> </span>&#123;                                                                                                           </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STANDBY) &#123;                                                                                                                                         </span><br><span class="line">                Slog.i(TAG, <span class="string">"Global parole state now "</span> + (isParoleOn ? <span class="string">"ON"</span> : <span class="string">"OFF"</span>));                                                                                   </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line">            mInParole = isParoleOn;                                                                                                                                      </span><br><span class="line">        &#125;                                                                                                                                                                </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUserInteractionStarted</span><span class="params">(String packageName, <span class="keyword">int</span> userId)</span> </span>&#123;                                                                                           </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> uid = mLocalPM.getPackageUid(packageName,                                                                                                          </span><br><span class="line">                    PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);                                                                                                  </span><br><span class="line">            <span class="keyword">if</span> (uid &lt; <span class="number">0</span>) &#123;                                                                                                                                               </span><br><span class="line">                <span class="comment">// Quietly ignore; the case is already logged elsewhere                                                                                                  </span></span><br><span class="line">                <span class="keyword">return</span>;                                                                                                                                                  </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> sinceLast = mUsageStats.getTimeSinceLastJobRun(packageName, userId);                                                                                    </span><br><span class="line">            <span class="keyword">if</span> (sinceLast &gt; <span class="number">2</span> * DateUtils.DAY_IN_MILLIS) &#123;                                                                                                               </span><br><span class="line">                <span class="comment">// Too long ago, not worth logging                                                                                                                       </span></span><br><span class="line">                sinceLast = <span class="number">0L</span>;                                                                                                                                          </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line">            <span class="keyword">final</span> DeferredJobCounter counter = <span class="keyword">new</span> DeferredJobCounter();                                                                                                 </span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;                                                                                                                                       </span><br><span class="line">                mJobs.forEachJobForSourceUid(uid, counter);                                                                                                              </span><br><span class="line">            &#125;                                                                                                                                                            </span><br><span class="line">            <span class="keyword">if</span> (counter.numDeferred() &gt; <span class="number">0</span> || sinceLast &gt; <span class="number">0</span>) &#123;                                                                                                            </span><br><span class="line">                BatteryStatsInternal mBatteryStatsInternal = LocalServices.getService                                                                                    </span><br><span class="line">                    (BatteryStatsInternal.class);                                                                                                                    </span><br><span class="line">                mBatteryStatsInternal.noteJobsDeferred(uid, counter.numDeferred(), sinceLast);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JobSchedulerService 创建的时候就添加Listener：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set up the app standby bucketing tracker</span></span><br><span class="line">mStandbyTracker = <span class="keyword">new</span> StandbyTracker();</span><br><span class="line">mUsageStats = LocalServices.getService(UsageStatsManagerInternal.class);</span><br><span class="line">mUsageStats.addAppIdleStateChangeListener(mStandbyTracker);</span><br></pre></td></tr></table></figure>
<p><code>onControllerStateChanged()</code>发送了异步消息<code>MSG_CHECK_JOB</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_CHECK_JOB:</span><br><span class="line"><span class="keyword">if</span> (mReportedActive) &#123;</span><br><span class="line">    <span class="comment">// if jobs are currently being run, queue all ready jobs for execution.</span></span><br><span class="line">    <span class="comment">// job 正在执行执行，让其2执行完</span></span><br><span class="line">    queueReadyJobsForExecutionLocked();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Check the list of jobs and run some of them if we feel inclined.</span></span><br><span class="line">    maybeQueueReadyJobsForExecutionLocked();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><code>maybeQueueReadyJobsForExecutionLocked()</code> 的实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeQueueReadyJobsForExecutionLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Maybe queuing ready jobs..."</span>);                                                                            </span><br><span class="line">                                                                                                                                      </span><br><span class="line">    noteJobsNonpending(mPendingJobs);                                                                                                 </span><br><span class="line">    mPendingJobs.clear();                                                                                                             </span><br><span class="line">    stopNonReadyActiveJobsLocked();                                                                                                   </span><br><span class="line">    mJobs.forEachJob(mMaybeQueueFunctor);  <span class="comment">// 会调用到MaybeReadyJobQueueFunctor的accept()方法</span></span><br><span class="line">                                                                        </span><br><span class="line">    mMaybeQueueFunctor.postProcess();  <span class="comment">// mPendingJobs.addAll(runnableJobs)</span></span><br><span class="line">                                                                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MaybeReadyJobQueueFunctor</code> 的 accept() 会调用到isReadyToBeExecutedLocked(job):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Criteria for moving a job into the pending queue:</span></span><br><span class="line"><span class="comment">    *      - It's ready.</span></span><br><span class="line"><span class="comment">    *      - It's not pending.</span></span><br><span class="line"><span class="comment">    *      - It's not already running on a JSC.</span></span><br><span class="line"><span class="comment">    *      - The user that requested the job is running.</span></span><br><span class="line"><span class="comment">    *      - The job's standby bucket has come due to be runnable.</span></span><br><span class="line"><span class="comment">    *      - The component is enabled and runnable.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isReadyToBeExecutedLocked</span><span class="params">(JobStatus job)</span> </span>&#123;</span><br><span class="line">	.....</span><br><span class="line">       <span class="comment">// If the app is in a non-active standby bucket, make sure we've waited</span></span><br><span class="line">       <span class="comment">// an appropriate amount of time since the last invocation.  During device-</span></span><br><span class="line">       <span class="comment">// wide parole, standby bucketing is ignored.</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">// Jobs in 'active' apps are not subject to standby, nor are jobs that are</span></span><br><span class="line">       <span class="comment">// specifically marked as exempt.</span></span><br><span class="line">       <span class="keyword">if</span> (DEBUG_STANDBY) &#123;</span><br><span class="line">           Slog.v(TAG, <span class="string">"isReadyToBeExecutedLocked: "</span> + job.toShortString()</span><br><span class="line">                   + <span class="string">" parole="</span> + mInParole + <span class="string">" active="</span> + job.uidActive</span><br><span class="line">                   + <span class="string">" exempt="</span> + job.getJob().isExemptedFromAppStandby());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!mInParole</span><br><span class="line">               &amp;&amp; !job.uidActive</span><br><span class="line">               &amp;&amp; !job.getJob().isExemptedFromAppStandby()) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> bucket = job.getStandbyBucket();</span><br><span class="line">           <span class="keyword">if</span> (DEBUG_STANDBY) &#123;</span><br><span class="line">               Slog.v(TAG, <span class="string">"  bucket="</span> + bucket + <span class="string">" heartbeat="</span> + mHeartbeat</span><br><span class="line">                       + <span class="string">" next="</span> + mNextBucketHeartbeat[bucket]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (mHeartbeat &lt; mNextBucketHeartbeat[bucket]) &#123;</span><br><span class="line">               <span class="comment">// Only skip this job if the app is still waiting for the end of its nominal</span></span><br><span class="line">               <span class="comment">// bucket interval.  Once it's waited that long, we let it go ahead and clear.</span></span><br><span class="line">               <span class="comment">// The final (NEVER) bucket is special; we never age those apps' jobs into</span></span><br><span class="line">               <span class="comment">// runnability.</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> appLastRan = heartbeatWhenJobsLastRun(job);</span><br><span class="line">               <span class="keyword">if</span> (bucket &gt;= mConstants.STANDBY_BEATS.length</span><br><span class="line">                       || (mHeartbeat &gt; appLastRan</span><br><span class="line">                               &amp;&amp; mHeartbeat &lt; appLastRan + mConstants.STANDBY_BEATS[bucket])) &#123;</span><br><span class="line">                   <span class="comment">// <span class="doctag">TODO:</span> log/trace that we're deferring the job due to bucketing if we hit this</span></span><br><span class="line">                   <span class="keyword">if</span> (job.getWhenStandbyDeferred() == <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (DEBUG_STANDBY) &#123;</span><br><span class="line">                           Slog.v(TAG, <span class="string">"Bucket deferral: "</span> + mHeartbeat + <span class="string">" &lt; "</span></span><br><span class="line">                                   + (appLastRan + mConstants.STANDBY_BEATS[bucket])</span><br><span class="line">                                   + <span class="string">" for "</span> + job);</span><br><span class="line">                       &#125;</span><br><span class="line">                       job.setWhenStandbyDeferred(sElapsedRealtimeClock.millis());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (DEBUG_STANDBY) &#123;</span><br><span class="line">                       Slog.v(TAG, <span class="string">"Bucket deferred job aged into runnability at "</span></span><br><span class="line">                               + mHeartbeat + <span class="string">" : "</span> + job);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>STANDBY_BEATS</code> 的定义<code>JobSchedulerService.java</code> 中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_STANDBY_WORKING_BEATS = <span class="number">11</span>;  <span class="comment">// ~ 2 hours, with 11min beats</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_STANDBY_FREQUENT_BEATS = <span class="number">43</span>; <span class="comment">// ~ 8 hours</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_STANDBY_RARE_BEATS = <span class="number">130</span>; <span class="comment">// ~ 24 hours</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mapping: standby bucket -&gt; number of heartbeats between each sweep of that</span></span><br><span class="line"><span class="comment"> * bucket's jobs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Bucket assignments as recorded in the JobStatus objects are normalized to be</span></span><br><span class="line"><span class="comment"> * indices into this array, rather than the raw constants used</span></span><br><span class="line"><span class="comment"> * by AppIdleHistory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] STANDBY_BEATS = &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        DEFAULT_STANDBY_WORKING_BEATS,</span><br><span class="line">        DEFAULT_STANDBY_FREQUENT_BEATS,</span><br><span class="line">        DEFAULT_STANDBY_RARE_BEATS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>经过一系列的计算,不同bucket的心跳是不一样的,这样就实现了延时实现不同bucket的JS.心跳的计算是在:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Heartbeat tracking.  The heartbeat alarm is intentionally non-wakeup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeartbeatAlarmListener</span> <span class="keyword">implements</span> <span class="title">AlarmManager</span>.<span class="title">OnAlarmListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAlarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> sinceLast = sElapsedRealtimeClock.millis() - mLastHeartbeatTime;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> beatsElapsed = sinceLast / mConstants.STANDBY_HEARTBEAT_TIME;</span><br><span class="line">            <span class="keyword">if</span> (beatsElapsed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mLastHeartbeatTime += beatsElapsed * mConstants.STANDBY_HEARTBEAT_TIME;</span><br><span class="line">                advanceHeartbeatLocked(beatsElapsed); <span class="comment">// 不让触发alarm, 就是延时</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setNextHeartbeatAlarm(); <span class="comment">// 设置下一次alarm 时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块代码,具体没有研究透彻,先告一段落.</p>
<h2 id="参考blog"><a href="#参考blog" class="headerlink" title="参考blog:"></a>参考blog:</h2><ul>
<li><a href="https://www.codetd.com/article/2898647" target="_blank" rel="noopener">Android9.0 应用待机群组</a></li>
<li><a href="https://blog.csdn.net/jilrvrtrc/article/details/81369918" target="_blank" rel="noopener">Android P 电量管理</a></li>
<li><a href="https://developer.android.google.cn/topic/performance/power/power-details" target="_blank" rel="noopener">Power management restrictions</a></li>
<li><a href="https://blog.csdn.net/weixin_42963076/article/details/82689172" target="_blank" rel="noopener">Android P新特性 —应用待机群组（#####笔记#####）</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Michael</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lqktz.github.io/2019/04/10/App_Standby_Bucket/">https://lqktz.github.io/2019/04/10/App_Standby_Bucket/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lqktz.github.io">Michael Blog</a>！</span></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/10/Android-O-耗电统计/"><i class="fa fa-chevron-left">  </i><span>Android O电量统计</span></a></div><div class="next-post pull-right"><a href="/2019/04/02/Android从驱动到应用(4)添加JNI层/"><span>Android从驱动到应用(4)添加JNI层</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Michael</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to Michael <a href="http://lqktz.github.io/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>