<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android Classloader"><meta name="keywords" content="Android"><meta name="author" content="Michael"><meta name="copyright" content="Michael"><title>Android Classloader | Michael Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars2.githubusercontent.com/u/15813289?s=460&amp;v=4"></div><div class="author-info__name text-center">Michael</div><div class="author-info__description text-center">Android性能优化</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">18</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Michael Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">目录</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Android Classloader</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/"> Android</a></div><div class="article-container" id="post-content"><p><strong>Android N</strong></p>
<p>最近的工作遇到了运用反射来加载类,需要用到这块的知识,因此有了这篇文章.</p>
<p>##1. java类加载器<br>Java虚拟机类加载过程是把Class类文件加载到内存，并对Class文件中的数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型的过程。<br>具体过程参考&lt;&lt;深入理解java虚拟机&gt;&gt;.在加载阶段，java虚拟机需要完成以下3件事：</p>
<ul>
<li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p>
</li>
<li><p>将定义类的二进制字节流所代表的静态存储结构转换为方法区的运行时数据结构。</p>
</li>
<li><p>在java堆中生成一个代表该类的java.lang.Class对象，作为方法区数据的访问入口,一个类不管new多少实例,只有一个对应的class对象.</p>
</li>
</ul>
<p>这个加载过程是使用类加载器完成的.</p>
<p>在java里面默认的有三个类加载器:BootStrap,ExtClassLoader,AppClassLoader.类加载器也是需要加载的,BootStrap是用C++书写,直接在java虚拟机的内核里面,用于加载类加载器,<br>以及rt.jar包,ExtClassLoader是用来加载在<code>Java/jre7/lib/ext/</code>下面的jar包.</p>
<p>每个ClassLoader必须有一个父ClassLoader，在装载Class文件时，子ClassLoader会先请求父ClassLoader加载该Class文件，只有当其父ClassLoader找不到该Class文件时，<br>子ClassLoader才会继续装载该类，这是一种安全机制。叫类加载器的委托机制.</p>
<p>在使用标准Java虚拟机时，我们经常自定义继承自ClassLoader的类加载器。Android中ClassLoader的defineClass方法具体是调用VMClassLoader的defineClass本地静态方法。<br>而这个本地方法除了抛出一个“UnsupportedOperationException”之外，什么都没做，甚至连返回值都为空.所以在android中继承ClassLoader定义自己的类加载器是行不通的.<br>为了在android中实现动态的加载类,Android从ClassLoader派生出了两个类：DexClassLoader和PathClassLoader.</p>
<ul>
<li>PathClassLoader是android中的默认加载器,只能加载/data/app中的apk,即安装在手机中的apk;</li>
<li>DexClassLoader可以加载任何路径的apk/dex/jar;</li>
</ul>
<p>##2. android的类加载器</p>
<p>###2.1 DexClassLoader<br>加载器的代码在<code>libcore/dalvik/src/main/java/dalvik/system/</code>,DexClassLoader.java:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dalvik.system;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class loader that loads classes from &#123;<span class="doctag">@code</span> .jar&#125; and &#123;<span class="doctag">@code</span> .apk&#125; files</span></span><br><span class="line"><span class="comment"> * containing a &#123;<span class="doctag">@code</span> classes.dex&#125; entry. This can be used to execute code not</span></span><br><span class="line"><span class="comment"> * installed as part of an application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class loader requires an application-private, writable directory to</span></span><br><span class="line"><span class="comment"> * cache optimized classes. Use &#123;<span class="doctag">@code</span> Context.getCodeCacheDir()&#125; to create</span></span><br><span class="line"><span class="comment"> * such a directory: &lt;pre&gt;   &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *   File dexOutputDir = context.getCodeCacheDir();</span></span><br><span class="line"><span class="comment"> * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;strong&gt;Do not cache optimized classes on external storage.&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * External storage does not provide access controls necessary to protect your</span></span><br><span class="line"><span class="comment"> * application from code injection attacks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> DexClassLoader&#125; that finds interpreted and native</span></span><br><span class="line"><span class="comment">     * code.  Interpreted classes are found in a set of DEX files contained</span></span><br><span class="line"><span class="comment">     * in Jar or APK files.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The path lists are separated using the character specified by the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> path.separator&#125; system property, which defaults to &#123;<span class="doctag">@code</span> :&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dexPath the list of jar/apk files containing classes and</span></span><br><span class="line"><span class="comment">     *     resources, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;, which</span></span><br><span class="line"><span class="comment">     *     defaults to &#123;<span class="doctag">@code</span> ":"&#125; on Android</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> optimizedDirectory this parameter is deprecated and has no effect</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> librarySearchPath the list of directories containing native</span></span><br><span class="line"><span class="comment">     *     libraries, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;; may be</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent the parent class loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DexClassLoader构造器,只有dexPath,optimizedDirectory,librarySearchPath,parent:</p>
<p>###2.2 PathClassLoader<br>PathClassLoader的源码也在<code>libcore/dalvik/src/main/java/dalvik/system/</code>,PathClassLoader.java:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> PathClassLoader&#125; that operates on a given list of files</span></span><br><span class="line"><span class="comment">     * and directories. This method is equivalent to calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #PathClassLoader(String, String, ClassLoader)&#125; with a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; value for the second argument (see description there).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dexPath the list of jar/apk files containing classes and</span></span><br><span class="line"><span class="comment">     * resources, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;, which</span></span><br><span class="line"><span class="comment">     * defaults to &#123;<span class="doctag">@code</span> ":"&#125; on Android</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent the parent class loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> PathClassLoader&#125; that operates on two given</span></span><br><span class="line"><span class="comment">     * lists of files and directories. The entries of the first list</span></span><br><span class="line"><span class="comment">     * should be one of the following:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;JAR/ZIP/APK files, possibly containing a "classes.dex" file as</span></span><br><span class="line"><span class="comment">     * well as arbitrary resources.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;Raw ".dex" files (not inside a zip file).</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The entries of the second list should be directories containing</span></span><br><span class="line"><span class="comment">     * native library files.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dexPath the list of jar/apk files containing classes and</span></span><br><span class="line"><span class="comment">     * resources, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;, which</span></span><br><span class="line"><span class="comment">     * defaults to &#123;<span class="doctag">@code</span> ":"&#125; on Android</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> librarySearchPath the list of directories containing native</span></span><br><span class="line"><span class="comment">     * libraries, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;; may be</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent the parent class loader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PathClassLoader同样是继承BaseDexClassLoader类,有两个构造方法,最终都是调用BaseDexClassLoader的构造方法进行构造.但是与DexClassLoader相比,<br>没有了optimizedDirectory参数,其他都一样.原因是PathClassLoader加载的是android安装的apk的类,这些class的dex有一个固定的目录<code>/data/dalvik-cache</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Android:/data/dalvik-cache # cd arm/</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@ApplicationsProvider</span><span class="meta">@ApplicationsProvider</span>.apk<span class="meta">@classes</span>.dex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@ApplicationsProvider</span><span class="meta">@ApplicationsProvider</span>.apk<span class="meta">@classes</span>.vdex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@AtciService</span><span class="meta">@AtciService</span>.apk<span class="meta">@classes</span>.art</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@AtciService</span><span class="meta">@AtciService</span>.apk<span class="meta">@classes</span>.dex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@AtciService</span><span class="meta">@AtciService</span>.apk<span class="meta">@classes</span>.vdex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BasicDreams</span><span class="meta">@BasicDreams</span>.apk<span class="meta">@classes</span>.art</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BasicDreams</span><span class="meta">@BasicDreams</span>.apk<span class="meta">@classes</span>.dex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BasicDreams</span><span class="meta">@BasicDreams</span>.apk<span class="meta">@classes</span>.vdex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BatteryWarning</span><span class="meta">@BatteryWarning</span>.apk<span class="meta">@classes</span>.art</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BatteryWarning</span><span class="meta">@BatteryWarning</span>.apk<span class="meta">@classes</span>.dex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BatteryWarning</span><span class="meta">@BatteryWarning</span>.apk<span class="meta">@classes</span>.vdex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@Bluetooth</span><span class="meta">@Bluetooth</span>.apk<span class="meta">@classes</span>.art</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@Bluetooth</span><span class="meta">@Bluetooth</span>.apk<span class="meta">@classes</span>.dex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@Bluetooth</span><span class="meta">@Bluetooth</span>.apk<span class="meta">@classes</span>.vdex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BluetoothMidiService</span><span class="meta">@BluetoothMidiService</span>.apk<span class="meta">@classes</span>.art</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BluetoothMidiService</span><span class="meta">@BluetoothMidiService</span>.apk<span class="meta">@classes</span>.dex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BluetoothMidiService</span><span class="meta">@BluetoothMidiService</span>.apk<span class="meta">@classes</span>.vdex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BookmarkProvider</span><span class="meta">@BookmarkProvider</span>.apk<span class="meta">@classes</span>.art</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BookmarkProvider</span><span class="meta">@BookmarkProvider</span>.apk<span class="meta">@classes</span>.dex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BookmarkProvider</span><span class="meta">@BookmarkProvider</span>.apk<span class="meta">@classes</span>.vdex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BuiltInPrintService</span><span class="meta">@BuiltInPrintService</span>.apk<span class="meta">@classes</span>.art</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BuiltInPrintService</span><span class="meta">@BuiltInPrintService</span>.apk<span class="meta">@classes</span>.dex</span><br><span class="line">system<span class="meta">@app</span><span class="meta">@BuiltInPrintService</span><span class="meta">@BuiltInPrintService</span>.apk<span class="meta">@classes</span>.vdex</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>###2.3 BaseDexClassLoader<br>DexClassLoader和PathClassLoader的构造方法都是调用了BaseDexClassLoader,在BaseDexClassLoader.java里面:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">     .....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, librarySearchPath, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            reporter.report(<span class="keyword">this</span>.pathList.getDexPaths());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明这最后都是从ClassLoader来的,ClassLoader才是祖师爷呀.在BaseDexClassLoader的构造方法里创建了DexPathList,也就干了这么一件事.<br>BaseDexClassLoader创建时的四个参数的意义:</p>
<ul>
<li>dexPath: 是加载apk/dex/jar的路径,dexPath,当有多个路径则采用:分割;</li>
<li>optimizedDirectory: 是dex的输出路径(因为加载apk/jar的时候会解压除dex文件，这个路径就是保存dex文件的),优化后的dex文件存在的目录;</li>
<li>librarySearchPath: 是加载的时候需要用到的lib库;</li>
<li>parent: 给DexClassLoader指定父加载器;</li>
</ul>
<p>####2.3.1 DexPathList<br>接着分析DexPathList代码,DexPathList.java在<code>libcore/dalvik/src/main/java/dalvik/system</code>,<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> definingContext the context in which any as-yet unresolved</span></span><br><span class="line"><span class="comment"> * classes should be defined</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dexPath list of dex/resource path elements, separated by</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> File.pathSeparator&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> librarySearchPath list of native library directory path elements,</span></span><br><span class="line"><span class="comment"> * separated by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> optimizedDirectory directory where optimized &#123;<span class="doctag">@code</span> .dex&#125; files</span></span><br><span class="line"><span class="comment"> * should be found and written to, or &#123;<span class="doctag">@code</span> null&#125; to use the default</span></span><br><span class="line"><span class="comment"> * system directory for same</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">        String librarySearchPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definingContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"definingContext == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dexPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"dexPath == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optimizedDirectory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!optimizedDirectory.exists())  &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"optimizedDirectory doesn't exist: "</span></span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(optimizedDirectory.canRead()</span><br><span class="line">                        &amp;&amp; optimizedDirectory.canWrite())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"optimizedDirectory not readable/writable: "</span></span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.definingContext = definingContext;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">    <span class="comment">// save dexPath for BaseDexClassLoader</span></span><br><span class="line">    <span class="comment">// 记录所有的dexFile文件</span></span><br><span class="line">    <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                       suppressedExceptions, definingContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Native libraries may exist in both the system and</span></span><br><span class="line">    <span class="comment">// application library paths, and we use this search order:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   1. This class loader's library path for application libraries (librarySearchPath):</span></span><br><span class="line">    <span class="comment">//   1.1. Native library directories</span></span><br><span class="line">    <span class="comment">//   1.2. Path to libraries in apk-files</span></span><br><span class="line">    <span class="comment">//   2. The VM's library path from the system property for system libraries</span></span><br><span class="line">    <span class="comment">//      also known as java.library.path</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This order was reversed prior to Gingerbread; see http://b/2933456.</span></span><br><span class="line">    <span class="comment">// app的native库 </span></span><br><span class="line">    <span class="keyword">this</span>.nativeLibraryDirectories = splitPaths(librarySearchPath, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 系统的native库</span></span><br><span class="line">    <span class="keyword">this</span>.systemNativeLibraryDirectories =</span><br><span class="line">            splitPaths(System.getProperty(<span class="string">"java.library.path"</span>), <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 把app的native库和system的native库合并,汇总</span></span><br><span class="line">    List&lt;File&gt; allNativeLibraryDirectories = <span class="keyword">new</span> ArrayList&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">    allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录所有的native动态库</span></span><br><span class="line">    <span class="keyword">this</span>.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dexElementsSuppressedExceptions =</span><br><span class="line">            suppressedExceptions.toArray(<span class="keyword">new</span> IOException[suppressedExceptions.size()]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dexElementsSuppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结的构造的过程中主要干了两件事:记录DexFile(dexElements)和记录native动态库(nativeLibraryPathElements).</p>
<p>##2.4 ClassLoader<br>所有的类加载器最终都是在调用ClassLoader类,该类是类加载的核心,其他都只是进行封装,打包.ClassLoader.java在<code>libcore/ojluni/src/main/java/java/lang/ClassLoader.java</code>,<br>下面只是列出了主要代码部分:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ClassLoader loader = ClassLoader.createSystemClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Encapsulates the set of parallel capable loader types.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader <span class="title">createSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String classPath = System.getProperty(<span class="string">"java.class.path"</span>, <span class="string">"."</span>);</span><br><span class="line">        String librarySearchPath = System.getProperty(<span class="string">"java.library.path"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String[] paths = classPath.split(":");</span></span><br><span class="line">        <span class="comment">// URL[] urls = new URL[paths.length];</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; paths.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">// try &#123;</span></span><br><span class="line">        <span class="comment">// urls[i] = new URL("file://" + paths[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// catch (Exception ex) &#123;</span></span><br><span class="line">        <span class="comment">// ex.printStackTrace();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// return new java.net.URLClassLoader(urls, null);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO Make this a java.net.URLClassLoader once we have those?</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回系统默认的加载器,appclassloader</span></span><br><span class="line">        <span class="keyword">return</span> SystemClassLoader.loader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载使用双亲委派模式</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            <span class="comment">// 首先,检查请求的类是否已经加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;<span class="comment">//委派父类加载器加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//委派启动类加载器加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;<span class="comment">//父类加载器无法完成加载请求</span></span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;<span class="comment">//本身加载器无法完成加载</span></span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the class with the given &lt;a href="#name"&gt;binary name&lt;/a&gt; if this</span></span><br><span class="line"><span class="comment">     * loader has been recorded by the Java virtual machine as an initiating</span></span><br><span class="line"><span class="comment">     * loader of a class with that &lt;a href="#name"&gt;binary name&lt;/a&gt;.  Otherwise</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;null&lt;/tt&gt; is returned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment">     *         The &lt;a href="#name"&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  The &lt;tt&gt;Class&lt;/tt&gt; object, or &lt;tt&gt;null&lt;/tt&gt; if the class has</span></span><br><span class="line"><span class="comment">     *          not been loaded</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>  1.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">        ClassLoader loader;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == BootClassLoader.getInstance())</span><br><span class="line">            loader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loader = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> VMClassLoader.findLoadedClass(loader, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义ClassLoader需要重写该方法</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Michael</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lqktz.github.io/2019/04/10/android_classloader/">https://lqktz.github.io/2019/04/10/android_classloader/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lqktz.github.io">Michael Blog</a>！</span></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/10/androidstart/"><i class="fa fa-chevron-left">  </i><span>Android开机总体流程</span></a></div><div class="next-post pull-right"><a href="/2019/04/10/PKMS扫描安装包源码分析/"><span>PackageManagerService 源码扫描安装包分析</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Michael</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to Michael <a href="http://lqktz.github.io/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>