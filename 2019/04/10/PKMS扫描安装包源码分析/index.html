<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="PackageManagerService 源码扫描安装包分析"><meta name="keywords" content="Android"><meta name="author" content="Michael"><meta name="copyright" content="Michael"><title>PackageManagerService 源码扫描安装包分析 | Michael Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://avatars2.githubusercontent.com/u/15813289?s=460&amp;v=4"></div><div class="author-info__name text-center">Michael</div><div class="author-info__description text-center">Android性能优化</div><div class="follow-button"><a href="https://github.com/lqktz">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Michael Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">目录</a><a class="site-page" href="/categories">分类</a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">PackageManagerService 源码扫描安装包分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/"> Android</a></div><div class="article-container" id="post-content"><p><strong>平台:android 8.0 源码</strong>  </p>
<hr>
<p>本文分析的问题:<br>apk的安装有如下四种方式：  </p>
<ul>
<li>apk随着PMS的启动而安装(本文)  </li>
<li>adb install安装  </li>
<li>ODM内置商店静默安装  </li>
<li>拷贝apk到手机，界面安装  </li>
</ul>
<p>这四种方式在代码里的实现其实就是如下两种：  </p>
<ul>
<li>PMS调用scanDirLI扫描安装(本文分析的方式)  </li>
<li>直接或间接调用installPackageAsUser安装  <a id="more"></a>
</li>
</ul>
<hr>
<p>在systemserver的分析过程中,在startBootstrapServices()中启动PMS是通过调用PackageManagerService.main()启动了PMS服务的,本文接着从这开始分析.<br><code>frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static PackageManagerService main(Context context, Installer installer,</span><br><span class="line">        boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">    // Self-check for initial settings.</span><br><span class="line">    PackageManagerServiceCompilerMapping.checkProperties();</span><br><span class="line"></span><br><span class="line">    PackageManagerService m = new PackageManagerService(context, installer,</span><br><span class="line">            factoryTest, onlyCore);</span><br><span class="line">    m.enableSystemUserPackages();</span><br><span class="line">    ServiceManager.addService(&quot;package&quot;, m);</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的main()方法比较简单,重点就是创建了PackageManagerService对象,并且把它加入到ServiceManager中,本文的重点就是分析PackageManagerService对象的创建.<br>在这其中会涉及到在同一个包下面的其他.java类,比较核心的有:Settings.java,  接着分析PackageManagerService.java的构造方法,该方法相当的长,分段进行分析<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public PackageManagerService(Context context, Installer installer,</span><br><span class="line">        boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">    LockGuard.installLock(mPackages, LockGuard.INDEX_PACKAGES);</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;create package manager&quot;);</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    /// M: Add for Mtprof tool.</span><br><span class="line">    mMTPROFDisable = false;</span><br><span class="line">    addBootEvent(&quot;Android:PackageManagerService_Start&quot;);</span><br><span class="line">    //mSdkVersion标示SDK版本,让apk知道自己运行在哪个版本</span><br><span class="line">    if (mSdkVersion &lt;= 0) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;**** ro.build.version.sdk not set!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mContext = context;</span><br><span class="line">    //标示了CTA表示在产品要在国内买,需要过CTA,类似CTS</span><br><span class="line">    /// M: CTA requirement - permission control</span><br><span class="line">    mPermissionReviewRequired = CtaUtils.isCtaSupported() ? true :</span><br><span class="line">        context.getResources().getBoolean(R.bool.config_permissionReviewRequired);</span><br><span class="line">    ///@&#125;</span><br><span class="line">    //是否运行在工厂模式下</span><br><span class="line">    mFactoryTest = factoryTest;</span><br><span class="line">    //判断是否只扫描系统目录,这个在后面多次用到</span><br><span class="line">    mOnlyCore = onlyCore;</span><br><span class="line">    //获取手机分辨率信息</span><br><span class="line">    mMetrics = new DisplayMetrics();</span><br><span class="line">    //mPackages是一个map集合存放packagesetting对象,是全局变量.PMS中的每一个应用程序的安装信息都是使用一个packagesetting对象进行描述</span><br><span class="line">    //Settings类是用来管理应用程序的安装信息的</span><br><span class="line">    mSettings = new Settings(mPackages);</span><br></pre></td></tr></table></figure></p>
<p>由于这个Settings类比较重要,接下来分析Settings的构造方法,Settings的构造函数主要用于创建一些目录和文件，并配置相应的权限.<br><code>frameworks/base/services/core/java/com/android/server/pm/Settings.java</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Settings(Object lock) &#123;</span><br><span class="line">    //Environment.getDataDirectory()获取的是/data目录</span><br><span class="line">    this(Environment.getDataDirectory(), lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Settings(File dataDir, Object lock) &#123;</span><br><span class="line">    mLock = lock;</span><br><span class="line"></span><br><span class="line">    mRuntimePermissionsPersistence = new RuntimePermissionPersistence(mLock);</span><br><span class="line">    //目录指向为/data/system</span><br><span class="line">    mSystemDir = new File(dataDir, &quot;system&quot;);</span><br><span class="line">    //创建前面指向好的目录</span><br><span class="line">    mSystemDir.mkdirs();</span><br><span class="line">    FileUtils.setPermissions(mSystemDir.toString(),</span><br><span class="line">            FileUtils.S_IRWXU|FileUtils.S_IRWXG</span><br><span class="line">            |FileUtils.S_IROTH|FileUtils.S_IXOTH,</span><br><span class="line">            -1, -1);</span><br><span class="line">    //packages.xml和packages-backup.xml为一组，用于描述系统所安装的Package信息，其中packages-backup.xml是packages.xml的备份</span><br><span class="line">    //PKMS写把数据写到backup文件中，信息全部写成功后在改名为非backup文件，以防止在写文件的过程中出错，导致信息丢失</span><br><span class="line">    mSettingsFilename = new File(mSystemDir, &quot;packages.xml&quot;);</span><br><span class="line">    mBackupSettingsFilename = new File(mSystemDir, &quot;packages-backup.xml&quot;);</span><br><span class="line">    //packages.list保存中所有安装apk的信息</span><br><span class="line">    mPackageListFilename = new File(mSystemDir, &quot;packages.list&quot;);</span><br><span class="line">    FileUtils.setPermissions(mPackageListFilename, 0640, SYSTEM_UID, PACKAGE_INFO_GID);</span><br><span class="line"></span><br><span class="line">    final File kernelDir = new File(&quot;/config/sdcardfs&quot;);</span><br><span class="line">    mKernelMappingFilename = kernelDir.exists() ? kernelDir : null;</span><br><span class="line">    //packages-stopped.xml用于描述系统中强行停止运行的package信息，backup也是备份文件</span><br><span class="line">    // Deprecated: Needed for migration</span><br><span class="line">    mStoppedPackagesFilename = new File(mSystemDir, &quot;packages-stopped.xml&quot;);</span><br><span class="line">    mBackupStoppedPackagesFilename = new File(mSystemDir, &quot;packages-stopped-backup.xml&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到<code>frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</code>,继续分析PackageManagerService的构造方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//设置系统的shareuserid,这个是在manifest.xml中设置,拥有相同shareuserid的app将会共享权限.</span><br><span class="line">//shareuserid属性设置为&quot;android.uid.system&quot;那么说明是系统app</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.system&quot;, Process.SYSTEM_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.phone&quot;, RADIO_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.log&quot;, LOG_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.nfc&quot;, NFC_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.bluetooth&quot;, BLUETOOTH_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">mSettings.addSharedUserLPw(&quot;android.uid.shell&quot;, SHELL_UID,</span><br><span class="line">        ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br></pre></td></tr></table></figure></p>
<p>用到了Settings类的方法:addSharedUserLPw,作用是添加共享用户:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//name和uid一一对应，例如：&quot;android.uid.system&quot;：Process.SYSTEM_UID（1000）</span><br><span class="line">//                      &quot;android.uid.phone&quot; ：RADIO_UID（Process.PHONE_UID， 1001）</span><br><span class="line">// 在PMS中，每一个共享Linux用户都是使用一个SharedUserSetting对象来描述的。这些对象保存在mSharedUsers中</span><br><span class="line">SharedUserSetting addSharedUserLPw(String name, int uid, int pkgFlags, int pkgPrivateFlags) &#123;</span><br><span class="line">//依据key(这里其实就是包名)值,从mSharedUsers对象中获取对应的SharedUserSetting对象.</span><br><span class="line">SharedUserSetting s = mSharedUsers.get(name);</span><br><span class="line">    if (s != null) &#123;//如果在mSharedUsers里面存在给的包名对应的SharedUserSetting对象</span><br><span class="line">        if (s.userId == uid) &#123;//并且userId=uid,说明PMS已经为该应用程序分配过了uid</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        PackageManagerService.reportSettingsProblem(Log.ERROR,</span><br><span class="line">                &quot;Adding duplicate shared user, keeping first: &quot; + name);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果mSharedUsers中不存在与该包名对应的SharedUserSetting对象，则为该应用程序分配一个参数uid所描述的Linux用户ID</span><br><span class="line">    s = new SharedUserSetting(name, pkgFlags, pkgPrivateFlags);</span><br><span class="line">    s.userId = uid;</span><br><span class="line">    // 在系统中保存值为uid的Linux用户ID，成功返回true</span><br><span class="line">    if (addUserIdLPw(uid, s, name)) &#123;</span><br><span class="line">        //将新new的SharedUserSetting对象添加到mSharedUsers中</span><br><span class="line">        mSharedUsers.put(name, s);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在系统保存值为uid的Linux用户ID,使用到了addUserIdLPw方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean addUserIdLPw(int uid, Object obj, Object name) &#123;</span><br><span class="line">    if (uid &gt; Process.LAST_APPLICATION_UID) &#123;//大于19999说明是一个非法的uid,超出了uid的上线</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (uid &gt;= Process.FIRST_APPLICATION_UID) &#123;//大于等于10000普通apk的uid,保存在mUserIds中</span><br><span class="line">        //计算数组长度</span><br><span class="line">        int N = mUserIds.size();</span><br><span class="line">        //计算索引值</span><br><span class="line">        final int index = uid - Process.FIRST_APPLICATION_UID;</span><br><span class="line">        while (index &gt;= N) &#123;//索引值大于数组长度,在N到index之间的位置都填上null</span><br><span class="line">            mUserIds.add(null);</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果数组的目标索引值位置有不为null的值，说明已经添加过</span><br><span class="line">        if (mUserIds.get(index) != null) &#123;</span><br><span class="line">            PackageManagerService.reportSettingsProblem(Log.ERROR,</span><br><span class="line">                    &quot;Adding duplicate user id: &quot; + uid</span><br><span class="line">                    + &quot; name=&quot; + name);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //没有添加过,则在索引位置填上obj</span><br><span class="line">        mUserIds.set(index, obj);</span><br><span class="line">    &#125; else &#123;//小于10000,系统apk使用的uid,保存在mOtherUserIds中</span><br><span class="line">        if (mOtherUserIds.get(uid) != null) &#123;</span><br><span class="line">            PackageManagerService.reportSettingsProblem(Log.ERROR,</span><br><span class="line">                    &quot;Adding duplicate shared id: &quot; + uid</span><br><span class="line">                            + &quot; name=&quot; + name);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        mOtherUserIds.put(uid, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PMS在创建了Settings之后会,调用一系列的addSharedUserLPw方法,形成下图的结构:<br><img src="https://raw.githubusercontent.com/lqktz/document/54f0dd65b3310f52a314d526879427d73bde28c1/res/PMS_addshareuserid.jpg" alt="1"><br>如图所示，PKMS将根据参数构建出SharedUserSettings对象，可以通过两个维度来引用创建出的对象，即名称和uid。<br>在Settings中mSharedUsers是一个map对象，利用名称作为索引管理SharedUserSettings对象。<br>Settings中的mOtherUserIds和mUserIds，均是利用userId作为索引管理SharedUserSettings对象。不同的是mOtherUserIds是SparseArray，<br>以系统uid作为键值；mUserIds是ArrayList，普通APK的uid为ArrayList的下标。<br>接着分析一下这个SharedUserSettings:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//重点看这一个方法</span><br><span class="line">void addPackage(PackageSetting packageSetting) &#123;</span><br><span class="line">    if (packages.add(packageSetting)) &#123;//SharedUserSettings保存着一个packages集合用来存储packageSetting&lt;-存储一个应用的安装信息</span><br><span class="line">        setFlags(this.pkgFlags | packageSetting.pkgFlags);</span><br><span class="line">        setPrivateFlags(this.pkgPrivateFlags | packageSetting.pkgPrivateFlags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到<code>frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</code>,继续分析PackageManagerService的构造方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 应用安装器,构造函数传入的InstallerService，与底层Installd通信,installer由SystemServer构造</span><br><span class="line">mInstaller = installer;</span><br><span class="line">// 实例化优化器,PackageDexOptimizer用于辅助进行dex优化</span><br><span class="line">mPackageDexOptimizer = new PackageDexOptimizer(installer, mInstallLock, context,</span><br><span class="line">        &quot;*dexopt*&quot;);</span><br><span class="line">//在pm/dex/包下,用于记录dex文件使用情况的记录在/data/system/package-dex-usage.list中</span><br><span class="line">mDexManager = new DexManager(this, mPackageDexOptimizer, installer, mInstallLock);</span><br><span class="line">//定义一些回调函数</span><br><span class="line">mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());</span><br><span class="line">//定义权限更改监听器</span><br><span class="line">mOnPermissionChangeListeners = new OnPermissionChangeListeners(</span><br><span class="line">        FgThread.get().getLooper());</span><br><span class="line">//获取默认显示屏信息</span><br><span class="line">getDefaultDisplayMetrics(context, mMetrics);</span><br><span class="line"></span><br><span class="line">Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;get system config&quot;);</span><br><span class="line">//获得SystemConfig对象,通过该对象获取系统配置</span><br><span class="line">SystemConfig systemConfig = SystemConfig.getInstance();</span><br></pre></td></tr></table></figure></p>
<p>由于SystemConfig是一个比较重要的类,下面的代码多次使用,进行详细分析.<br><code>frameworks/base/core/java/com/android/server/SystemConfig.java</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static SystemConfig sInstance;</span><br><span class="line">//SystemConfig是单例模式</span><br><span class="line">public static SystemConfig getInstance() &#123;</span><br><span class="line">    synchronized (SystemConfig.class) &#123;</span><br><span class="line">        if (sInstance == null) &#123;</span><br><span class="line">            sInstance = new SystemConfig();</span><br><span class="line">        &#125;</span><br><span class="line">        return sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SystemConfig() &#123;//从不少目录读取权限,可能有些目录不存在,但是/system一定存在</span><br><span class="line">    //Environment.getRootDirectory()获取到的是/system目录,从/system目录读取权限</span><br><span class="line">    // Read configuration from system</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">            Environment.getRootDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), ALLOW_ALL);</span><br><span class="line">    // Read configuration from the old permissions dir</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">            Environment.getRootDirectory(), &quot;etc&quot;, &quot;permissions&quot;), ALLOW_ALL);</span><br><span class="line">    //从/vendor目录下读取权限</span><br><span class="line">    // Allow Vendor to customize system configs around libs, features, permissions and apps</span><br><span class="line">    int vendorPermissionFlag = ALLOW_LIBS | ALLOW_FEATURES | ALLOW_PERMISSIONS |</span><br><span class="line">            ALLOW_APP_CONFIGS;</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">            Environment.getVendorDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), vendorPermissionFlag);</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">            Environment.getVendorDirectory(), &quot;etc&quot;, &quot;permissions&quot;), vendorPermissionFlag);</span><br><span class="line">    //从/odm目录读取权限</span><br><span class="line">    // Allow ODM to customize system configs around libs, features and apps</span><br><span class="line">    int odmPermissionFlag = ALLOW_LIBS | ALLOW_FEATURES | ALLOW_APP_CONFIGS;</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">            Environment.getOdmDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), odmPermissionFlag);</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">            Environment.getOdmDirectory(), &quot;etc&quot;, &quot;permissions&quot;), odmPermissionFlag);</span><br><span class="line">    //从/oem目录读取权限</span><br><span class="line">    // Only allow OEM to customize features</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">            Environment.getOemDirectory(), &quot;etc&quot;, &quot;sysconfig&quot;), ALLOW_FEATURES);</span><br><span class="line">    readPermissions(Environment.buildPath(</span><br><span class="line">            Environment.getOemDirectory(), &quot;etc&quot;, &quot;permissions&quot;), ALLOW_FEATURES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//接着看readPermissions方法的实现</span><br><span class="line">void readPermissions(File libraryDir, int permissionFlag) &#123;</span><br><span class="line">    //检测是否存在,是否可读</span><br><span class="line">    // Read permissions from given directory.</span><br><span class="line">    if (!libraryDir.exists() || !libraryDir.isDirectory()) &#123;</span><br><span class="line">        if (permissionFlag == ALLOW_ALL) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;No directory &quot; + libraryDir + &quot;, skipping&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!libraryDir.canRead()) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Directory &quot; + libraryDir + &quot; cannot be read&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 遍历目标文件夹下所有的.xml文件</span><br><span class="line">    // Iterate over the files in the directory and scan .xml files</span><br><span class="line">    File platformFile = null;</span><br><span class="line">    for (File f : libraryDir.listFiles()) &#123;</span><br><span class="line">        // 最后解析platform.xml文件</span><br><span class="line">        // We&apos;ll read platform.xml last</span><br><span class="line">        if (f.getPath().endsWith(&quot;etc/permissions/platform.xml&quot;)) &#123;</span><br><span class="line">            platformFile = f;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!f.getPath().endsWith(&quot;.xml&quot;)) &#123;</span><br><span class="line">            Slog.i(TAG, &quot;Non-xml file &quot; + f + &quot; in &quot; + libraryDir + &quot; directory, ignoring&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!f.canRead()) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Permissions library file &quot; + f + &quot; cannot be read&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //将可读取的xml进行读取</span><br><span class="line">        readPermissionsFromXml(f, permissionFlag);//下面详解readPermissionsFromXml方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 最后解析platform.xml文件，该文件的优先级最高</span><br><span class="line">    // Read platform permissions last so it will take precedence</span><br><span class="line">    if (platformFile != null) &#123;</span><br><span class="line">        readPermissionsFromXml(platformFile, permissionFlag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>readPermissions就是从指定目录下，读取xml中的配置的权限信息.将xml文件转换成对应的数据结构.eg:/system/etc/permissions/platform.xml.<br>看一下platform.xml里面的主要标签：  </p>
<ul>
<li>permission和group字段用于建立Linux层GID和Android层permission字段之间的映射关系；  </li>
<li>assign-permission用于向指定的uid赋予相应的权限；  </li>
<li>library字段用于可链接的指定系统库;  </li>
<li>allow-in-power-save-except-idle用于指定进程在省电模式下(非Idle)仍可上网;  </li>
<li>backup-transport-whitelisted-service用于指定服务具有传输备份数据的权利;  </li>
</ul>
<p>上面这些标签是用readPermissionsFromXml方法解析的.在readPermissions方法中两次调用到了readPermissionsFromXml,该方法是SystemConfig的核心方法.源码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void readPermissionsFromXml(File permFile, int permissionFlag) &#123;</span><br><span class="line">    FileReader permReader = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //利用file构造fileReader</span><br><span class="line">        permReader = new FileReader(permFile);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Couldn&apos;t find or open permissions file &quot; + permFile);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //读取系统属性&quot;ro.config.low_ram&quot;，如果该属性为true，不会加载指定notLowRam的feature属性</span><br><span class="line">    final boolean lowRam = ActivityManager.isLowRamDeviceStatic();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //创建xml解析器</span><br><span class="line">        XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">        //给解析器输入FileReader读取的内容</span><br><span class="line">        parser.setInput(permReader);</span><br><span class="line"></span><br><span class="line">        //寻找解析的起点</span><br><span class="line">        int type;</span><br><span class="line">        while ((type=parser.next()) != parser.START_TAG</span><br><span class="line">                   &amp;&amp; type != parser.END_DOCUMENT) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (type != parser.START_TAG) &#123;</span><br><span class="line">            throw new XmlPullParserException(&quot;No start tag found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!parser.getName().equals(&quot;permissions&quot;) &amp;&amp; !parser.getName().equals(&quot;config&quot;)) &#123;</span><br><span class="line">            throw new XmlPullParserException(&quot;Unexpected start tag in &quot; + permFile</span><br><span class="line">                    + &quot;: found &quot; + parser.getName() + &quot;, expected &apos;permissions&apos; or &apos;config&apos;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //根据SystemConfig构造方法中设置的flag，决定当前目录下，从xml文件中解析内容的范围</span><br><span class="line">        boolean allowAll = permissionFlag == ALLOW_ALL;</span><br><span class="line">        boolean allowLibs = (permissionFlag &amp; ALLOW_LIBS) != 0;</span><br><span class="line">        boolean allowFeatures = (permissionFlag &amp; ALLOW_FEATURES) != 0;</span><br><span class="line">        boolean allowPermissions = (permissionFlag &amp; ALLOW_PERMISSIONS) != 0;</span><br><span class="line">        boolean allowAppConfigs = (permissionFlag &amp; ALLOW_APP_CONFIGS) != 0;</span><br><span class="line">        boolean allowPrivappPermissions = (permissionFlag &amp; ALLOW_PRIVAPP_PERMISSIONS) != 0;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            XmlUtils.nextElement(parser);</span><br><span class="line">            //解析完成退出</span><br><span class="line">            if (parser.getEventType() == XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String name = parser.getName();</span><br><span class="line">            //解析group标签</span><br><span class="line">            if (&quot;group&quot;.equals(name) &amp;&amp; allowAll) &#123;</span><br><span class="line">                //以字符串的形式获取属性值,如果获取的属性值是一个int,那么就要进行转换</span><br><span class="line">                String gidStr = parser.getAttributeValue(null, &quot;gid&quot;);</span><br><span class="line">                if (gidStr != null) &#123;</span><br><span class="line">                    //将Gid字符串转化成整形，保存到mGlobalGids中</span><br><span class="line">                    int gid = android.os.Process.getGidForName(gidStr);</span><br><span class="line">                    mGlobalGids = appendInt(mGlobalGids, gid);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;group&gt; without gid in &quot; + permFile + &quot; at &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else if (&quot;permission&quot;.equals(name) &amp;&amp; allowPermissions) &#123;//解析permission标签</span><br><span class="line">                String perm = parser.getAttributeValue(null, &quot;name&quot;);</span><br><span class="line">                if (perm == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;permission&gt; without name in &quot; + permFile + &quot; at &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                    XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                perm = perm.intern();</span><br><span class="line">                //调用readPermission解析permission标签,注意不是readPermissions方法!!!</span><br><span class="line">                readPermission(parser, perm);</span><br><span class="line"></span><br><span class="line">            &#125; else if (&quot;assign-permission&quot;.equals(name) &amp;&amp; allowPermissions) &#123;//解析assign-permission标签,记录uid分配的权限,最终记录到mSystemPermissions</span><br><span class="line">                //获取权限名称</span><br><span class="line">                String perm = parser.getAttributeValue(null, &quot;name&quot;);</span><br><span class="line">                if (perm == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;assign-permission&gt; without name in &quot; + permFile + &quot; at &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                    XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //获取该权限的uid的值</span><br><span class="line">                String uidStr = parser.getAttributeValue(null, &quot;uid&quot;);</span><br><span class="line">                if (uidStr == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;assign-permission&gt; without uid in &quot; + permFile + &quot; at &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                    XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //将uid从string转换成int</span><br><span class="line">                int uid = Process.getUidForName(uidStr);</span><br><span class="line">                if (uid &lt; 0) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;assign-permission&gt; with unknown uid \&quot;&quot;</span><br><span class="line">                            + uidStr + &quot;  in &quot; + permFile + &quot; at &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                    XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //使用了字符串池,intern()是String类的方法</span><br><span class="line">                perm = perm.intern();</span><br><span class="line">                //从系统获取该uid已经拥有的权限</span><br><span class="line">                ArraySet&lt;String&gt; perms = mSystemPermissions.get(uid);</span><br><span class="line">                //如果该uid之前没有添加过权限,创建一个,并将添加到mSystemPermissions中</span><br><span class="line">                if (perms == null) &#123;</span><br><span class="line">                    perms = new ArraySet&lt;String&gt;();</span><br><span class="line">                    mSystemPermissions.put(uid, perms);//保存着以uid为key的权限映射表,是一个稀疏数组</span><br><span class="line">                &#125;</span><br><span class="line">                //将uid新增的权限，加入到它的ArraySet</span><br><span class="line">                perms.add(perm);</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line"></span><br><span class="line">            &#125; else if (&quot;library&quot;.equals(name) &amp;&amp; allowLibs) &#123;//解析library标签,最终记录到mSharedLibraries</span><br><span class="line">                String lname = parser.getAttributeValue(null, &quot;name&quot;);</span><br><span class="line">                String lfile = parser.getAttributeValue(null, &quot;file&quot;);</span><br><span class="line">                if (lname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;library&gt; without name in &quot; + permFile + &quot; at &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                &#125; else if (lfile == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;library&gt; without file in &quot; + permFile + &quot; at &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //Log.i(TAG, &quot;Got library &quot; + lname + &quot; in &quot; + lfile);</span><br><span class="line">                    //将解析好的library标签的内容添加到mSharedLibraries,是一个map集合</span><br><span class="line">                    mSharedLibraries.put(lname, lfile);</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            &#125; else if (&quot;feature&quot;.equals(name) &amp;&amp; allowFeatures) &#123;//解析feature标签</span><br><span class="line">                String fname = parser.getAttributeValue(null, &quot;name&quot;);</span><br><span class="line">                int fversion = XmlUtils.readIntAttribute(parser, &quot;version&quot;, 0);</span><br><span class="line">                boolean allowed;</span><br><span class="line">                if (!lowRam) &#123;//如果是低内存就不解析</span><br><span class="line">                    allowed = true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    String notLowRam = parser.getAttributeValue(null, &quot;notLowRam&quot;);</span><br><span class="line">                    allowed = !&quot;true&quot;.equals(notLowRam);</span><br><span class="line">                &#125;</span><br><span class="line">                if (fname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;feature&gt; without name in &quot; + permFile + &quot; at &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                &#125; else if (allowed) &#123;</span><br><span class="line">                //将feature构造成featureInfo，加入到mAvailableFeatures对象中,该方法在SystemConfig中</span><br><span class="line">                    addFeature(fname, fversion);</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            &#125; else if (&quot;unavailable-feature&quot;.equals(name) &amp;&amp; allowFeatures) &#123;//mUnavailableFeatures保存不支持的feature</span><br><span class="line">                String fname = parser.getAttributeValue(null, &quot;name&quot;);</span><br><span class="line">                if (fname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;unavailable-feature&gt; without name in &quot; + permFile + &quot; at &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mUnavailableFeatures.add(fname);</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            &#125; else if (&quot;allow-in-power-save-except-idle&quot;.equals(name) &amp;&amp; allowAll) &#123;//保存省电模式下,可以使用网络的应用</span><br><span class="line">                String pkgname = parser.getAttributeValue(null, &quot;package&quot;);</span><br><span class="line">                if (pkgname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;allow-in-power-save-except-idle&gt; without package in &quot;</span><br><span class="line">                            + permFile + &quot; at &quot; + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //保存在mAllowInPowerSaveExceptIdle中</span><br><span class="line">                    mAllowInPowerSaveExceptIdle.add(pkgname);</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            &#125; else if (&quot;allow-in-power-save&quot;.equals(name) &amp;&amp; allowAll) &#123;</span><br><span class="line">            //mAllowInPowerSave与mAllowInPowerSaveExceptIdle类似，权限更高</span><br><span class="line">            //这与Android M新特性Doze and App Standby模式有关</span><br><span class="line">            //DeviceIdleController用于判断设备是否进入Idle状态，进入Idle状态时，mAllowInPowerSaveExceptIdle中的应用要被禁掉</span><br><span class="line">            //但mAllowInPowerSave中的应用仍可运行</span><br><span class="line">                String pkgname = parser.getAttributeValue(null, &quot;package&quot;);</span><br><span class="line">                if (pkgname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;allow-in-power-save&gt; without package in &quot; + permFile + &quot; at &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mAllowInPowerSave.add(pkgname);</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            &#125; else if (&quot;allow-in-data-usage-save&quot;.equals(name) &amp;&amp; allowAll) &#123;</span><br><span class="line">               //mAllowInDataUsageSave保存此标签对应的packageName</span><br><span class="line">               //貌似android 7新增了一个节省数据流量的能力，有此标签的应用在节省数据流量时，仍可访问网络</span><br><span class="line">                String pkgname = parser.getAttributeValue(null, &quot;package&quot;);</span><br><span class="line">                if (pkgname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;allow-in-data-usage-save&gt; without package in &quot; + permFile</span><br><span class="line">                            + &quot; at &quot; + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mAllowInDataUsageSave.add(pkgname);</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            &#125; else if (&quot;allow-unthrottled-location&quot;.equals(name) &amp;&amp; allowAll) &#123;</span><br><span class="line">                String pkgname = parser.getAttributeValue(null, &quot;package&quot;);</span><br><span class="line">                if (pkgname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;allow-unthrottled-location&gt; without package in &quot;</span><br><span class="line">                        + permFile + &quot; at &quot; + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mAllowUnthrottledLocation.add(pkgname);</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            &#125; else if (&quot;allow-implicit-broadcast&quot;.equals(name) &amp;&amp; allowAll) &#123;</span><br><span class="line">                String action = parser.getAttributeValue(null, &quot;action&quot;);</span><br><span class="line">                if (action == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;allow-implicit-broadcast&gt; without action in &quot; + permFile</span><br><span class="line">                            + &quot; at &quot; + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mAllowImplicitBroadcasts.add(action);</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            &#125; else if (&quot;app-link&quot;.equals(name) &amp;&amp; allowAppConfigs) &#123;</span><br><span class="line">                String pkgname = parser.getAttributeValue(null, &quot;package&quot;);</span><br><span class="line">                if (pkgname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;app-link&gt; without package in &quot; + permFile + &quot; at &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mLinkedApps.add(pkgname);</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">            &#125; else if (&quot;system-user-whitelisted-app&quot;.equals(name) &amp;&amp; allowAppConfigs) &#123;</span><br><span class="line">            //mSystemUserWhitelistedApps保存此标签对应的packageName</span><br><span class="line">            //指定以system user权限运行的app</span><br><span class="line">                String pkgname = parser.getAttributeValue(null, &quot;package&quot;);</span><br><span class="line">                if (pkgname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;system-user-whitelisted-app&gt; without package in &quot; + permFile</span><br><span class="line">                            + &quot; at &quot; + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mSystemUserWhitelistedApps.add(pkgname);</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">            &#125; else if (&quot;system-user-blacklisted-app&quot;.equals(name) &amp;&amp; allowAppConfigs) &#123;</span><br><span class="line">            //mSystemUserBlacklistedApp保存此标签对应的packageName</span><br><span class="line">            //指定在system user权限下，不应该运行的app</span><br><span class="line">                String pkgname = parser.getAttributeValue(null, &quot;package&quot;);</span><br><span class="line">                if (pkgname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;system-user-blacklisted-app without package in &quot; + permFile</span><br><span class="line">                            + &quot; at &quot; + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mSystemUserBlacklistedApps.add(pkgname);</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">            &#125; else if (&quot;default-enabled-vr-app&quot;.equals(name) &amp;&amp; allowAppConfigs) &#123;</span><br><span class="line">            //mDefaultVrComponents保存此标签对应的packageName</span><br><span class="line">            //指定默认运行在VR模式下的components</span><br><span class="line">                String pkgname = parser.getAttributeValue(null, &quot;package&quot;);</span><br><span class="line">                String clsname = parser.getAttributeValue(null, &quot;class&quot;);</span><br><span class="line">                if (pkgname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;default-enabled-vr-app without package in &quot; + permFile</span><br><span class="line">                            + &quot; at &quot; + parser.getPositionDescription());</span><br><span class="line">                &#125; else if (clsname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;default-enabled-vr-app without class in &quot; + permFile</span><br><span class="line">                            + &quot; at &quot; + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mDefaultVrComponents.add(new ComponentName(pkgname, clsname));</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">            &#125; else if (&quot;backup-transport-whitelisted-service&quot;.equals(name) &amp;&amp; allowFeatures) &#123;</span><br><span class="line">            //mBackupTransportWhitelist保存此标签对应的packageName</span><br><span class="line">            //保存能够传输备份数据的服务</span><br><span class="line">                String serviceName = parser.getAttributeValue(null, &quot;service&quot;);</span><br><span class="line">                if (serviceName == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;backup-transport-whitelisted-service&gt; without service in &quot;</span><br><span class="line">                            + permFile + &quot; at &quot; + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    ComponentName cn = ComponentName.unflattenFromString(serviceName);</span><br><span class="line">                    if (cn == null) &#123;</span><br><span class="line">                        Slog.w(TAG,</span><br><span class="line">                                &quot;&lt;backup-transport-whitelisted-service&gt; with invalid service name &quot;</span><br><span class="line">                                + serviceName + &quot; in &quot;+ permFile</span><br><span class="line">                                + &quot; at &quot; + parser.getPositionDescription());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBackupTransportWhitelist.add(cn);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">            &#125; else if (&quot;disabled-until-used-preinstalled-carrier-associated-app&quot;.equals(name)</span><br><span class="line">                    &amp;&amp; allowAppConfigs) &#123;</span><br><span class="line">                String pkgname = parser.getAttributeValue(null, &quot;package&quot;);</span><br><span class="line">                String carrierPkgname = parser.getAttributeValue(null, &quot;carrierAppPackage&quot;);</span><br><span class="line">                if (pkgname == null || carrierPkgname == null) &#123;</span><br><span class="line">                    Slog.w(TAG, &quot;&lt;disabled-until-used-preinstalled-carrier-associated-app&quot;</span><br><span class="line">                            + &quot; without package or carrierAppPackage in &quot; + permFile + &quot; at &quot;</span><br><span class="line">                            + parser.getPositionDescription());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    List&lt;String&gt; associatedPkgs =</span><br><span class="line">                            mDisabledUntilUsedPreinstalledCarrierAssociatedApps.get(</span><br><span class="line">                                    carrierPkgname);</span><br><span class="line">                    if (associatedPkgs == null) &#123;</span><br><span class="line">                        associatedPkgs = new ArrayList&lt;&gt;();</span><br><span class="line">                        mDisabledUntilUsedPreinstalledCarrierAssociatedApps.put(</span><br><span class="line">                                carrierPkgname, associatedPkgs);</span><br><span class="line">                    &#125;</span><br><span class="line">                    associatedPkgs.add(pkgname);</span><br><span class="line">                &#125;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">            &#125; else if (&quot;privapp-permissions&quot;.equals(name) &amp;&amp; allowPrivappPermissions) &#123;</span><br><span class="line">                readPrivAppPermissions(parser);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Got exception parsing permissions.&quot;, e);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        Slog.w(TAG, &quot;Got exception parsing permissions.&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        IoUtils.closeQuietly(permReader);</span><br><span class="line">    &#125;</span><br><span class="line">    //对相关的feature加密</span><br><span class="line">    // Some devices can be field-converted to FBE, so offer to splice in</span><br><span class="line">    // those features if not already defined by the static config</span><br><span class="line">    if (StorageManager.isFileEncryptedNativeOnly()) &#123;</span><br><span class="line">        addFeature(PackageManager.FEATURE_FILE_BASED_ENCRYPTION, 0);</span><br><span class="line">        addFeature(PackageManager.FEATURE_SECURELY_REMOVES_USERS, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    //移除mUnavailableFeatures中记录的不支持的feature</span><br><span class="line">    for (String featureName : mUnavailableFeatures) &#123;</span><br><span class="line">        removeFeature(featureName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到<code>frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</code>,继续分析PackageManagerService的构造方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mGlobalGids = systemConfig.getGlobalGids();</span><br><span class="line">mSystemPermissions = systemConfig.getSystemPermissions();</span><br><span class="line">mAvailableFeatures = systemConfig.getAvailableFeatures();</span><br><span class="line">Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br></pre></td></tr></table></figure></p>
<p>分别调用SystemConfig类的getGlobalGids(),getSystemPermissions(),getAvailableFeatures()方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int[] getGlobalGids() &#123;</span><br><span class="line">    return mGlobalGids;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SparseArray&lt;ArraySet&lt;String&gt;&gt; getSystemPermissions() &#123;</span><br><span class="line">    return mSystemPermissions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayMap&lt;String, FeatureInfo&gt; getAvailableFeatures() &#123;</span><br><span class="line">    return mAvailableFeatures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出这三个方法只是将readPermissionsFromXml方法中解析xml文件得到的数据结构获取出来.PMS调用SystemConfig的作用就是解析xml.<br>回到<code>frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</code>,继续分析PackageManagerService的构造方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//mHandlerThread将负责Apk的安装和卸载</span><br><span class="line">mHandlerThread = new ServiceThread(TAG,</span><br><span class="line">        Process.THREAD_PRIORITY_BACKGROUND, true /*allowIo*/);</span><br><span class="line">mHandlerThread.start();</span><br><span class="line">//PackageHandler、ProcessLoggingHandler共用ServiceThread</span><br><span class="line">// 以mHandlerThread线程的looper创建的Handler实例，该Handler运行在mHandlerThread线程</span><br><span class="line">// 该消息循环用于处理apk的安装请求</span><br><span class="line">mHandler = new PackageHandler(mHandlerThread.getLooper());</span><br><span class="line">mProcessLoggingHandler = new ProcessLoggingHandler();</span><br><span class="line">//Watchdog监控ServiceThread是否长时间阻塞</span><br><span class="line">Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</span><br><span class="line"></span><br><span class="line">mDefaultPermissionPolicy = new DefaultPermissionGrantPolicy(this);</span><br><span class="line">mInstantAppRegistry = new InstantAppRegistry(this);</span><br><span class="line">//在/data目录下创建一系列的目录</span><br><span class="line">File dataDir = Environment.getDataDirectory();//获取的是/data目录</span><br><span class="line">mAppInstallDir = new File(dataDir, &quot;app&quot;);//data/app保存用户自己的app</span><br><span class="line">mAppLib32InstallDir = new File(dataDir, &quot;app-lib&quot;);</span><br><span class="line">mAsecInternalPath = new File(dataDir, &quot;app-asec&quot;).getPath();</span><br><span class="line">mDrmAppPrivateInstallDir = new File(dataDir, &quot;app-private&quot;);// /data/app-parivate目录，保存的是受DRM保护的私有app</span><br><span class="line">//实例化多用户管理服务,用于管理多用户</span><br><span class="line">sUserManager = new UserManagerService(context, this,</span><br><span class="line">        new UserDataPreparer(mInstaller, mInstallLock, mContext, mOnlyCore), mPackages);</span><br><span class="line">//取出SystemConfig中的mPermissions</span><br><span class="line">//向包管理器中传播权限配置。</span><br><span class="line">// Propagate permission configuration in to package manager.</span><br><span class="line">ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig</span><br><span class="line">        = systemConfig.getPermissions();</span><br><span class="line"></span><br><span class="line">//从SystemConfig中的mPermissions获取信息,存储到mSettings.mPermissions中</span><br><span class="line">for (int i=0; i&lt;permConfig.size(); i++) &#123;</span><br><span class="line">    SystemConfig.PermissionEntry perm = permConfig.valueAt(i);</span><br><span class="line">    // 根据权限名获取基本权限信息</span><br><span class="line">    BasePermission bp = mSettings.mPermissions.get(perm.name);</span><br><span class="line">    if (bp == null) &#123;</span><br><span class="line">        bp = new BasePermission(perm.name, &quot;android&quot;, BasePermission.TYPE_BUILTIN);</span><br><span class="line">        mSettings.mPermissions.put(perm.name, bp);</span><br><span class="line">    &#125;</span><br><span class="line">    if (perm.gids != null) &#123;</span><br><span class="line">        bp.setGids(perm.gids, perm.perUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取出systemConfig对象中的链接库信息，保存到PKMS中</span><br><span class="line">ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();</span><br><span class="line">final int builtInLibCount = libConfig.size();</span><br><span class="line">for (int i = 0; i &lt; builtInLibCount; i++) &#123;</span><br><span class="line">    String name = libConfig.keyAt(i);</span><br><span class="line">    String path = libConfig.valueAt(i);</span><br><span class="line">    addSharedLibraryLPw(path, null, name, SharedLibraryInfo.VERSION_UNDEFINED,</span><br><span class="line">            SharedLibraryInfo.TYPE_BUILTIN, PLATFORM_PACKAGE_NAME, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解析SELinux的策略文件</span><br><span class="line">mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();</span><br><span class="line"></span><br><span class="line">Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;read user settings&quot;);</span><br><span class="line">//mFirstBoot用于判断机器是否时第一次开机,这里的readLPw恢复上一次的应用程序安装信息，扫描package.xml文件,如果没有该文件判断为第一次开机</span><br><span class="line">mFirstBoot = !mSettings.readLPw(sUserManager.getUsers(false));</span><br><span class="line">Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br></pre></td></tr></table></figure></p>
<p>Android系统每次启动时，都会重新安装一遍系统中的应用程序，但是有些应用程序信息每次安装都是需要保持一致的，<br>如应用程序的Linux用户ID等。否则应用程序每次在系统重启后表现可能不一致。因此PMS每次在安装完成应用程序之后，<br>都需要将它们的信息保存下来，以便下次安装时可以恢复回来。恢复上一次的应用程序安装信息是通过Settings类的readLPw方法实现的。<br>重点分析Settings类的方法readLPw:<br>进入<code>frameworks/base/services/core/java/com/android/server/pm/Settings.java</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean readLPw(@NonNull List&lt;UserInfo&gt; users) &#123;</span><br><span class="line">    FileInputStream str = null;</span><br><span class="line">    // 先检查/data/system/packages-backup.xml文件是否存在，</span><br><span class="line">    // 如果存在就将它的内容作为上一次的应用程序安装信息</span><br><span class="line">    if (mBackupSettingsFilename.exists()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            str = new FileInputStream(mBackupSettingsFilename);</span><br><span class="line">            mReadMessages.append(&quot;Reading from backup settings file\n&quot;);</span><br><span class="line">            PackageManagerService.reportSettingsProblem(Log.INFO,</span><br><span class="line">                    &quot;Need to read from backup settings file&quot;);</span><br><span class="line">            if (mSettingsFilename.exists()) &#123;</span><br><span class="line">                // If both the backup and settings file exist, we</span><br><span class="line">                // ignore the settings since it might have been</span><br><span class="line">                // corrupted.</span><br><span class="line">                Slog.w(PackageManagerService.TAG, &quot;Cleaning up settings file &quot;</span><br><span class="line">                        + mSettingsFilename);</span><br><span class="line">                mSettingsFilename.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (java.io.IOException e) &#123;</span><br><span class="line">            // We&apos;ll try for the normal settings file.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPendingPackages.clear();</span><br><span class="line">    mPastSignatures.clear();</span><br><span class="line">    mKeySetRefs.clear();</span><br><span class="line">    mInstallerPackages.clear();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (str == null) &#123;</span><br><span class="line">            if (!mSettingsFilename.exists()) &#123;</span><br><span class="line">                mReadMessages.append(&quot;No settings file found\n&quot;);</span><br><span class="line">                PackageManagerService.reportSettingsProblem(Log.INFO,</span><br><span class="line">                        &quot;No settings file; creating initial state&quot;);</span><br><span class="line">                // It&apos;s enough to just touch version details to create them</span><br><span class="line">                // with default values</span><br><span class="line">                // 如果原文件不存在，根据默认值创建版本信息。</span><br><span class="line">                findOrCreateVersion(StorageManager.UUID_PRIVATE_INTERNAL).forceCurrent();</span><br><span class="line">                findOrCreateVersion(StorageManager.UUID_PRIMARY_PHYSICAL).forceCurrent();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            str = new FileInputStream(mSettingsFilename);</span><br><span class="line">        &#125;</span><br><span class="line">        XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">        parser.setInput(str, StandardCharsets.UTF_8.name());</span><br><span class="line"></span><br><span class="line">        int type;</span><br><span class="line">        while ((type = parser.next()) != XmlPullParser.START_TAG</span><br><span class="line">                &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            mReadMessages.append(&quot;No start tag found in settings file\n&quot;);</span><br><span class="line">            PackageManagerService.reportSettingsProblem(Log.WARN,</span><br><span class="line">                    &quot;No start tag found in package manager settings&quot;);</span><br><span class="line">            Slog.wtf(PackageManagerService.TAG,</span><br><span class="line">                    &quot;No start tag found in package manager settings&quot;);</span><br><span class="line"></span><br><span class="line">            /// M: Create version info when packages.xml is corrupt</span><br><span class="line">            findOrCreateVersion(StorageManager.UUID_PRIVATE_INTERNAL);</span><br><span class="line">            findOrCreateVersion(StorageManager.UUID_PRIMARY_PHYSICAL);</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int outerDepth = parser.getDepth();</span><br><span class="line">        //开始解析</span><br><span class="line">        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">                &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String tagName = parser.getName();</span><br><span class="line">            if (tagName.equals(&quot;package&quot;)) &#123;</span><br><span class="line">            // 解析标签为package的元素，一个应用一个package标签.</span><br><span class="line">            // 获取上一次安装这个应用程序时所分配给它的Linux用户ID</span><br><span class="line">                readPackageLPw(parser);//1</span><br><span class="line">            &#125; else if (tagName.equals(&quot;permissions&quot;)) &#123;</span><br><span class="line">            // 解析系统定义了哪些权限，由哪个包定义</span><br><span class="line">                readPermissionsLPw(mPermissions, parser);</span><br><span class="line">            &#125; else if (tagName.equals(&quot;permission-trees&quot;)) &#123;</span><br><span class="line">                readPermissionsLPw(mPermissionTrees, parser);</span><br><span class="line">            &#125; else if (tagName.equals(&quot;shared-user&quot;)) &#123;</span><br><span class="line">            // shared-user标签是以sharedUserId的名字为name属性，然后为它分配一个userId赋值给userId属性。</span><br><span class="line">            // 其他应用用到该sharedUserId的，userId都是shared-user标签中的userId属性值</span><br><span class="line">            // 解析上一次应用程序安装信息中的共享Linux用户信息</span><br><span class="line">            // 就是前面在Settings类中addSharedUserLPw方法写信息,最终保存在mSharedUsers中</span><br><span class="line">                readSharedUserLPw(parser);//解析上一次应用程序安装信息中的共享linux用户信息</span><br><span class="line">            &#125; else if (tagName.equals(&quot;preferred-packages&quot;)) &#123;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">        str.close();</span><br><span class="line"></span><br><span class="line">    &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p>
<p>分析readPackageLPw方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void readPackageLPw(XmlPullParser parser) throws XmlPullParserException, IOException &#123;</span><br><span class="line">    //定义变量</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //获取应用程序包名,Linux用户Id,sharedUserId等信息,将前面定义的变量初始化</span><br><span class="line">        name = parser.getAttributeValue(null, ATTR_NAME);</span><br><span class="line">        realName = parser.getAttributeValue(null, &quot;realName&quot;);</span><br><span class="line">        idStr = parser.getAttributeValue(null, &quot;userId&quot;);</span><br><span class="line">        uidError = parser.getAttributeValue(null, &quot;uidError&quot;);</span><br><span class="line">        sharedIdStr = parser.getAttributeValue(null, &quot;sharedUserId&quot;);</span><br><span class="line">        codePathStr = parser.getAttributeValue(null, &quot;codePath&quot;);</span><br><span class="line">        resourcePathStr = parser.getAttributeValue(null, &quot;resourcePath&quot;);</span><br><span class="line">        //初始化变量,并且做相应的合法性判断,eg:==NULL?</span><br><span class="line">        .....</span><br><span class="line">       &#125; else if (userId &gt; 0) &#123;</span><br><span class="line">          //packageSetting用于保存一个应用程序的的安装信息,使用addPackageLPw将以上app的安装信息封装成packageSetting对象保存在mPackages中</span><br><span class="line">            packageSetting = addPackageLPw(name.intern(), realName, new File(codePathStr),//addPackageLPw源码分析</span><br><span class="line">                    new File(resourcePathStr), legacyNativeLibraryPathStr, primaryCpuAbiString,</span><br><span class="line">                    secondaryCpuAbiString, cpuAbiOverrideString, userId, versionCode, pkgFlags,</span><br><span class="line">                    pkgPrivateFlags, flagsEx, parentPackageName, null /*childPackageNames*/,</span><br><span class="line">                    null /*usesStaticLibraries*/, null /*usesStaticLibraryVersions*/);</span><br><span class="line">            //对返回的packageSetting对象进行合法性判断</span><br><span class="line">            if (PackageManagerService.DEBUG_SETTINGS)</span><br><span class="line">                Log.i(PackageManagerService.TAG, &quot;Reading package &quot; + name + &quot;: userId=&quot;</span><br><span class="line">                        + userId + &quot; pkg=&quot; + packageSetting);</span><br><span class="line">            if (packageSetting == null) &#123;</span><br><span class="line">                PackageManagerService.reportSettingsProblem(Log.ERROR, &quot;Failure adding uid &quot;</span><br><span class="line">                        + userId + &quot; while parsing settings at &quot;</span><br><span class="line">                        + parser.getPositionDescription());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                packageSetting.setTimeStamp(timeStamp);</span><br><span class="line">                packageSetting.firstInstallTime = firstInstallTime;</span><br><span class="line">                packageSetting.lastUpdateTime = lastUpdateTime;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>进入addPackageLPw方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在系统中保存值为userId的Linux用户ID</span><br><span class="line">// 在PMS中，每一个应用程序的安装信息都是使用一个PackageSetting对象来描述的。这些对象保存在mPackages中。</span><br><span class="line">PackageSetting addPackageLPw(String name, String realName, File codePath, File resourcePath,</span><br><span class="line">        String legacyNativeLibraryPathString, String primaryCpuAbiString,</span><br><span class="line">        String secondaryCpuAbiString, String cpuAbiOverrideString, int uid, int vc, int</span><br><span class="line">        pkgFlags, int pkgPrivateFlags, int flagsEx, String parentPackageName,</span><br><span class="line">        List&lt;String&gt; childPackageNames, String[] usesStaticLibraries,</span><br><span class="line">        int[] usesStaticLibraryNames) &#123;</span><br><span class="line">    PackageSetting p = mPackages.get(name);</span><br><span class="line">    if (p != null) &#123;//判断一下mPackages是否已经有了</span><br><span class="line">        if (p.appId == uid) &#123;</span><br><span class="line">            return p;//在mPackages应经存在,直接将mPackages里的PackageSetting对象直接返回</span><br><span class="line">        &#125;</span><br><span class="line">        PackageManagerService.reportSettingsProblem(Log.ERROR,</span><br><span class="line">                &quot;Adding duplicate package, keeping first: &quot; + name);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //mPackages里面没有,依据传入的信息,new一个PackageSetting对象,并且添加到mPackages中,并将该对象返回</span><br><span class="line">    /// M: [FlagExt] Add flagsEx</span><br><span class="line">    p = new PackageSetting(name, realName, codePath, resourcePath,</span><br><span class="line">            legacyNativeLibraryPathString, primaryCpuAbiString, secondaryCpuAbiString,</span><br><span class="line">            cpuAbiOverrideString, vc, pkgFlags, pkgPrivateFlags, flagsEx, parentPackageName,</span><br><span class="line">            childPackageNames, 0 /*userId*/, usesStaticLibraries, usesStaticLibraryNames);</span><br><span class="line">    p.appId = uid;</span><br><span class="line">    if (addUserIdLPw(uid, p, name)) &#123;//addUserIdLPw是在系统中保存值为uid的Linux用户Id,该方法在前面分析过</span><br><span class="line">        mPackages.put(name, p);</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到readPackageLPw方法,继续分析:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        &#125; else if (sharedIdStr != null) &#123;</span><br><span class="line">        // 如果sharedIdStr不为null，说明安装该应用时PMS给它分配了一个共享的uid。此时不能马上保存该uid，</span><br><span class="line">        // 因为这个uid不属于它自己所有，而是所有shareuserId了该uid的app共享.所以等解析完shared-user节点之后，再为它保存上一次所使用的Linux用户ID</span><br><span class="line">            if (sharedUserId &gt; 0) &#123;</span><br><span class="line">                /// M: [FlagExt] Add flagsEx</span><br><span class="line">                packageSetting = new PackageSetting(name.intern(), realName, new File(</span><br><span class="line">                        codePathStr), new File(resourcePathStr), legacyNativeLibraryPathStr,</span><br><span class="line">                        primaryCpuAbiString, secondaryCpuAbiString, cpuAbiOverrideString,</span><br><span class="line">                        versionCode, pkgFlags, pkgPrivateFlags, flagsEx, parentPackageName,</span><br><span class="line">                        null /*childPackageNames*/, sharedUserId,</span><br><span class="line">                        null /*usesStaticLibraries*/, null /*usesStaticLibraryVersions*/);</span><br><span class="line">                packageSetting.setTimeStamp(timeStamp);</span><br><span class="line">                packageSetting.firstInstallTime = firstInstallTime;</span><br><span class="line">                packageSetting.lastUpdateTime = lastUpdateTime;</span><br><span class="line">                //将是shareuserId的应用信息,先暂时保存在mPendingPackages中</span><br><span class="line">                mPendingPackages.add(packageSetting);</span><br><span class="line">                if (PackageManagerService.DEBUG_SETTINGS)</span><br><span class="line">                    Log.i(PackageManagerService.TAG, &quot;Reading package &quot; + name</span><br><span class="line">                            + &quot;: sharedUserId=&quot; + sharedUserId + &quot; pkg=&quot; + packageSetting);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                PackageManagerService.reportSettingsProblem(Log.WARN,</span><br><span class="line">                        &quot;Error in package manager settings: package &quot; + name</span><br><span class="line">                                + &quot; has bad sharedId &quot; + sharedIdStr + &quot; at &quot;</span><br><span class="line">                                + parser.getPositionDescription());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            PackageManagerService.reportSettingsProblem(Log.WARN,</span><br><span class="line">                    &quot;Error in package manager settings: package &quot; + name + &quot; has bad userId &quot;</span><br><span class="line">                            + idStr + &quot; at &quot; + parser.getPositionDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        PackageManagerService.reportSettingsProblem(Log.WARN,</span><br><span class="line">                &quot;Error in package manager settings: package &quot; + name + &quot; has bad userId &quot;</span><br><span class="line">                        + idStr + &quot; at &quot; + parser.getPositionDescription());</span><br><span class="line">    &#125;</span><br><span class="line">    if (packageSetting != null) &#123;</span><br><span class="line">        packageSetting.uidError = &quot;true&quot;.equals(uidError);</span><br><span class="line">        packageSetting.installerPackageName = installerPackageName;</span><br><span class="line">        packageSetting.isOrphaned = &quot;true&quot;.equals(isOrphaned);</span><br><span class="line">        packageSetting.volumeUuid = volumeUuid;</span><br><span class="line">        packageSetting.categoryHint = categoryHint;</span><br><span class="line">        packageSetting.legacyNativeLibraryPathString = legacyNativeLibraryPathStr;</span><br><span class="line">        packageSetting.primaryCpuAbiString = primaryCpuAbiString;</span><br><span class="line">        packageSetting.secondaryCpuAbiString = secondaryCpuAbiString;</span><br><span class="line">        packageSetting.updateAvailable = &quot;true&quot;.equals(updateAvailable);</span><br><span class="line">        // Handle legacy string here for single-user mode</span><br><span class="line">        final String enabledStr = parser.getAttributeValue(null, ATTR_ENABLED);</span><br><span class="line">        if (enabledStr != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                packageSetting.setEnabled(Integer.parseInt(enabledStr), 0 /* userId */, null);</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                if (enabledStr.equalsIgnoreCase(&quot;true&quot;)) &#123;</span><br><span class="line">                    packageSetting.setEnabled(COMPONENT_ENABLED_STATE_ENABLED, 0, null);</span><br><span class="line">                &#125; else if (enabledStr.equalsIgnoreCase(&quot;false&quot;)) &#123;</span><br><span class="line">                    packageSetting.setEnabled(COMPONENT_ENABLED_STATE_DISABLED, 0, null);</span><br><span class="line">                &#125; else if (enabledStr.equalsIgnoreCase(&quot;default&quot;)) &#123;</span><br><span class="line">                    packageSetting.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, 0, null);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    PackageManagerService.reportSettingsProblem(Log.WARN,</span><br><span class="line">                            &quot;Error in package manager settings: package &quot; + name</span><br><span class="line">                                    + &quot; has bad enabled value: &quot; + idStr + &quot; at &quot;</span><br><span class="line">                                    + parser.getPositionDescription());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            packageSetting.setEnabled(COMPONENT_ENABLED_STATE_DEFAULT, 0, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (installerPackageName != null) &#123;</span><br><span class="line">            mInstallerPackages.add(installerPackageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String installStatusStr = parser.getAttributeValue(null, &quot;installStatus&quot;);</span><br><span class="line">        if (installStatusStr != null) &#123;</span><br><span class="line">            if (installStatusStr.equalsIgnoreCase(&quot;false&quot;)) &#123;</span><br><span class="line">                packageSetting.installStatus = PackageSettingBase.PKG_INSTALL_INCOMPLETE;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                packageSetting.installStatus = PackageSettingBase.PKG_INSTALL_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int outerDepth = parser.getDepth();</span><br><span class="line">        int type;</span><br><span class="line">        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">                &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String tagName = parser.getName();</span><br><span class="line">            // Legacy</span><br><span class="line">            if (tagName.equals(TAG_DISABLED_COMPONENTS)) &#123;</span><br><span class="line">                readDisabledComponentsLPw(packageSetting, parser, 0);</span><br><span class="line">            &#125; else if (tagName.equals(TAG_ENABLED_COMPONENTS)) &#123;</span><br><span class="line">                readEnabledComponentsLPw(packageSetting, parser, 0);</span><br><span class="line">            &#125; else if (tagName.equals(&quot;sigs&quot;)) &#123;</span><br><span class="line">                packageSetting.signatures.readXml(parser, mPastSignatures);</span><br><span class="line">            &#125; else if (tagName.equals(TAG_PERMISSIONS)) &#123;</span><br><span class="line">                readInstallPermissionsLPr(parser,</span><br><span class="line">                        packageSetting.getPermissionsState());</span><br><span class="line">                packageSetting.installPermissionsFixed = true;</span><br><span class="line">            &#125; else if (tagName.equals(&quot;proper-signing-keyset&quot;)) &#123;</span><br><span class="line">                long id = Long.parseLong(parser.getAttributeValue(null, &quot;identifier&quot;));</span><br><span class="line">                Integer refCt = mKeySetRefs.get(id);</span><br><span class="line">                if (refCt != null) &#123;</span><br><span class="line">                    mKeySetRefs.put(id, refCt + 1);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mKeySetRefs.put(id, 1);</span><br><span class="line">                &#125;</span><br><span class="line">                packageSetting.keySetData.setProperSigningKeySet(id);</span><br><span class="line">            &#125; else if (tagName.equals(&quot;signing-keyset&quot;)) &#123;</span><br><span class="line">                // from v1 of keysetmanagerservice - no longer used</span><br><span class="line">            &#125; else if (tagName.equals(&quot;upgrade-keyset&quot;)) &#123;</span><br><span class="line">                long id = Long.parseLong(parser.getAttributeValue(null, &quot;identifier&quot;));</span><br><span class="line">                packageSetting.keySetData.addUpgradeKeySetById(id);</span><br><span class="line">            &#125; else if (tagName.equals(&quot;defined-keyset&quot;)) &#123;</span><br><span class="line">                long id = Long.parseLong(parser.getAttributeValue(null, &quot;identifier&quot;));</span><br><span class="line">                String alias = parser.getAttributeValue(null, &quot;alias&quot;);</span><br><span class="line">                Integer refCt = mKeySetRefs.get(id);</span><br><span class="line">                if (refCt != null) &#123;</span><br><span class="line">                    mKeySetRefs.put(id, refCt + 1);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mKeySetRefs.put(id, 1);</span><br><span class="line">                &#125;</span><br><span class="line">                packageSetting.keySetData.addDefinedKeySet(id, alias);</span><br><span class="line">            &#125; else if (tagName.equals(TAG_DOMAIN_VERIFICATION)) &#123;</span><br><span class="line">                readDomainVerificationLPw(parser, packageSetting);</span><br><span class="line">            &#125; else if (tagName.equals(TAG_CHILD_PACKAGE)) &#123;</span><br><span class="line">                String childPackageName = parser.getAttributeValue(null, ATTR_NAME);</span><br><span class="line">                if (packageSetting.childPackageNames == null) &#123;</span><br><span class="line">                    packageSetting.childPackageNames = new ArrayList&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                packageSetting.childPackageNames.add(childPackageName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                PackageManagerService.reportSettingsProblem(Log.WARN,</span><br><span class="line">                        &quot;Unknown element under &lt;package&gt;: &quot; + parser.getName());</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        XmlUtils.skipCurrentTag(parser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到readLPw继续分析:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    // If the build is setup to drop runtime permissions</span><br><span class="line">    // on update drop the files before loading them.</span><br><span class="line">    if (PackageManagerService.CLEAR_RUNTIME_PERMISSIONS_ON_UPGRADE) &#123;</span><br><span class="line">        final VersionInfo internal = getInternalVersion();</span><br><span class="line">        if (!Build.FINGERPRINT.equals(internal.fingerprint)) &#123;</span><br><span class="line">            for (UserInfo user : users) &#123;</span><br><span class="line">                mRuntimePermissionsPersistence.deleteUserRuntimePermissionsFile(user.id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //在readPackageLPw方法中将shareuserId的app安装信息都暂时的保存在mPendingPackages,现在进行处理</span><br><span class="line">    final int N = mPendingPackages.size();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        final PackageSetting p = mPendingPackages.get(i);</span><br><span class="line">        final int sharedUserId = p.getSharedUserId();</span><br><span class="line">        // 根据uid获取对应的对象，如果在mUserIds或mOtherUserIds中存在一个与userId对应的Object对象，</span><br><span class="line">        // 且该对象是SharedUserSetting的类型，则说明pp所描述的应用程序上一次所使用的Linux用户ID是有效的</span><br><span class="line">        final Object idObj = getUserIdLPr(sharedUserId);</span><br><span class="line">        //每一个共享Linux用户Id都是使用SharedUserSetting对象来描述,并且保存在mSharedUsers中</span><br><span class="line">        if (idObj instanceof SharedUserSetting) &#123;</span><br><span class="line">            final SharedUserSetting sharedUser = (SharedUserSetting) idObj;</span><br><span class="line">            p.sharedUser = sharedUser;</span><br><span class="line">            p.appId = sharedUser.userId;</span><br><span class="line">            //addPackageSettingLPw将PackageSetting对象p添加到mPackages,把sharedUser赋给p.sharedUser保存</span><br><span class="line">            addPackageSettingLPw(p, sharedUser);</span><br><span class="line">        &#125; else if (idObj != null) &#123;</span><br><span class="line">            String msg = &quot;Bad package setting: package &quot; + p.name + &quot; has shared uid &quot;</span><br><span class="line">                    + sharedUserId + &quot; that is not a shared uid\n&quot;;</span><br><span class="line">            mReadMessages.append(msg);</span><br><span class="line">            PackageManagerService.reportSettingsProblem(Log.ERROR, msg);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String msg = &quot;Bad package setting: package &quot; + p.name + &quot; has shared uid &quot;</span><br><span class="line">                    + sharedUserId + &quot; that is not defined\n&quot;;</span><br><span class="line">            mReadMessages.append(msg);</span><br><span class="line">            PackageManagerService.reportSettingsProblem(Log.ERROR, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingPackages.clear();</span><br><span class="line"></span><br><span class="line">    if (mBackupStoppedPackagesFilename.exists()</span><br><span class="line">            || mStoppedPackagesFilename.exists()) &#123;</span><br><span class="line">        // Read old file</span><br><span class="line">        readStoppedLPw();</span><br><span class="line">        mBackupStoppedPackagesFilename.delete();</span><br><span class="line">        mStoppedPackagesFilename.delete();</span><br><span class="line">        // Migrate to new file format</span><br><span class="line">        writePackageRestrictionsLPr(UserHandle.USER_SYSTEM);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (UserInfo user : users) &#123;</span><br><span class="line">            readPackageRestrictionsLPr(user.id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (UserInfo user : users) &#123;</span><br><span class="line">        mRuntimePermissionsPersistence.readStateForUserSyncLPr(user.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Make sure all the updated system packages have their shared users</span><br><span class="line">     * associated with them.</span><br><span class="line">     */</span><br><span class="line">    final Iterator&lt;PackageSetting&gt; disabledIt = mDisabledSysPackages.values().iterator();</span><br><span class="line">    while (disabledIt.hasNext()) &#123;</span><br><span class="line">        final PackageSetting disabledPs = disabledIt.next();</span><br><span class="line">        final Object id = getUserIdLPr(disabledPs.appId);</span><br><span class="line">        if (id != null &amp;&amp; id instanceof SharedUserSetting) &#123;</span><br><span class="line">            disabledPs.sharedUser = (SharedUserSetting) id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mReadMessages.append(&quot;Read completed successfully: &quot; + mPackages.size() + &quot; packages, &quot;</span><br><span class="line">            + mSharedUsers.size() + &quot; shared uids\n&quot;);</span><br><span class="line"></span><br><span class="line">    writeKernelMappingLPr();</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过上面的readLPw函数,将之前手机里面的安装信息都加载进来,接下来进入下一个阶段:开始扫描手机指定放apk的目录.<br>回到<code>frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</code>,继续分析PackageManagerService的构造方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> // 记录开始扫描的时间</span><br><span class="line"> long startTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line"> .....</span><br><span class="line"></span><br><span class="line">//获取目录:/system/framework/</span><br><span class="line"> File frameworkDir = new File(Environment.getRootDirectory(), &quot;framework&quot;);</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">//初始化扫描参数</span><br><span class="line"> // Set flag to monitor and not change apk file paths when</span><br><span class="line"> // scanning install directories.</span><br><span class="line"> int scanFlags = SCAN_BOOTING | SCAN_INITIAL;</span><br><span class="line"></span><br><span class="line"> if (mIsUpgrade || mFirstBoot) &#123;</span><br><span class="line">     scanFlags = scanFlags | SCAN_FIRST_BOOT_OR_UPGRADE;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // Collect vendor overlay packages. (Do this before scanning any apps.)</span><br><span class="line"> // For security and version matching reason, only consider</span><br><span class="line"> // overlay packages if they reside in the right directory.</span><br><span class="line"> scanDirTracedLI(new File(VENDOR_OVERLAY_DIR), mDefParseFlags//scanDirTracedLI详解其实调用还是scanDirLI,下来分析scanDirLI</span><br><span class="line">         | PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">         | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">         | PackageParser.PARSE_TRUSTED_OVERLAY, scanFlags | SCAN_TRUSTED_OVERLAY, 0);</span><br><span class="line"></span><br><span class="line"> //依次扫描放apk的目录</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure></p>
<p>scanDirLI是用来扫描一个指定目录下的apk文件.接下来分析scanDirLI方法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) &#123;</span><br><span class="line">    final File[] files = dir.listFiles();</span><br><span class="line">    if (ArrayUtils.isEmpty(files)) &#123;</span><br><span class="line">        Log.d(TAG, &quot;No files in app dir &quot; + dir);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// M: Add for Mtprof tool.</span><br><span class="line">    addBootEvent(&quot;Android:PMS_scan_data:&quot; + dir.getPath().toString());</span><br><span class="line"></span><br><span class="line">    //为了加快扫描速度,使用多线程进行扫描,启动多线程扫描来自QCOM平台</span><br><span class="line">    int iMultitaskNum = SystemProperties.getInt(&quot;persist.pm.multitask&quot;, 6);</span><br><span class="line">    final MultiTaskDealer dealer = (iMultitaskNum &gt; 1) ? MultiTaskDealer.startDealer(</span><br><span class="line">            MultiTaskDealer.PACKAGEMANAGER_SCANER, iMultitaskNum) : null;</span><br><span class="line"></span><br><span class="line">    ParallelPackageParser parallelPackageParser = new ParallelPackageParser(</span><br><span class="line">            mSeparateProcesses, mOnlyCore, mMetrics, mCacheDir,</span><br><span class="line">            mParallelPackageParserCallback);</span><br><span class="line"></span><br><span class="line">    // Submit files for parsing in parallel</span><br><span class="line">    int fileCount = 0;</span><br><span class="line">    for (File file : files) &#123;</span><br><span class="line">        // Added by zhongyang_lib for apk lib</span><br><span class="line">        if(file == null)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            if(!file.getAbsolutePath().equals(file.getCanonicalPath()) &amp;&amp; file.getName().endsWith(&quot;.so&quot;)) &#123;</span><br><span class="line">                //indicate file is a link file</span><br><span class="line">                Log.i(TAG,&quot;file: &quot;+file.getAbsolutePath()+&quot; is a link file: &quot;+ file.getCanonicalPath());</span><br><span class="line">                file = new File(file.getCanonicalPath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(IOException e)&#123;</span><br><span class="line">            Log.e(TAG,&quot;scan link file:&quot;+file.getAbsolutePath()+&quot;  caused an exception&quot;,e);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        parallelPackageParser.submit(file, parseFlags);</span><br><span class="line">        fileCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Process results one by one</span><br><span class="line">    for (; fileCount &gt; 0; fileCount--) &#123;</span><br><span class="line">        ParallelPackageParser.ParseResult parseResult = parallelPackageParser.take();</span><br><span class="line">        Throwable throwable = parseResult.throwable;</span><br><span class="line">        int errorCode = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line"></span><br><span class="line">        //merge from qcom platform by tian.pan@tcl.com for task5306252 start</span><br><span class="line">        Runnable scanTask = new Runnable() &#123;</span><br><span class="line">          public void run() &#123;</span><br><span class="line">            int parserErrorCode = errorCode;</span><br><span class="line"></span><br><span class="line">        if (throwable == null) &#123;</span><br><span class="line">            // Static shared libraries have synthetic package names</span><br><span class="line">            if (parseResult.pkg.applicationInfo.isStaticSharedLibrary()) &#123;</span><br><span class="line">                renameStaticSharedLibraryPackage(parseResult.pkg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                if (errorCode == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                    //使用scanPackageLI解析apk文件</span><br><span class="line">                    scanPackageLI(parseResult.pkg, parseResult.scanFile, parseFlags, scanFlags,</span><br><span class="line">                            currentTime, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">                    parserErrorCode = e.error;</span><br><span class="line">                Slog.w(TAG, &quot;Failed to scan &quot; + parseResult.scanFile + &quot;: &quot; + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (throwable instanceof PackageParser.PackageParserException) &#123;</span><br><span class="line">                PackageParser.PackageParserException e = (PackageParser.PackageParserException)throwable;</span><br><span class="line">                parserErrorCode = e.error;</span><br><span class="line">            Slog.w(TAG, &quot;Failed to parse &quot; + parseResult.scanFile + &quot;: &quot; + e.getMessage());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Unexpected exception occurred while parsing &quot;</span><br><span class="line">                    + parseResult.scanFile, throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        // Delete invalid userdata apps</span><br><span class="line">        if ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp;</span><br><span class="line">                    parserErrorCode == PackageManager.INSTALL_FAILED_INVALID_APK) &#123;</span><br><span class="line">                logCriticalInfo(Log.WARN, &quot;Deleting invalid package at &quot; + parseResult.scanFile);</span><br><span class="line">            //删除无效的apk文件</span><br><span class="line">            removeCodePathLI(parseResult.scanFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        if (dealer != null) &#123;</span><br><span class="line">            dealer.addTask(scanTask);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            scanTask.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dealer != null) &#123;</span><br><span class="line">        dealer.waitAll();</span><br><span class="line">    &#125;</span><br><span class="line">    //merge from qcom platform by tian.pan@tcl.com for task5306252 end</span><br><span class="line"></span><br><span class="line">    parallelPackageParser.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>scanDirLI方法只是去扫描了指定的文件夹  </p>
<ul>
<li>/system/framework</li>
<li>/system/app</li>
<li>/vendor/app</li>
<li>/data/app</li>
<li>/data/app-private<br>然后并没有处理扫描到的apk文件,而是交给scanPackageLI去处理,<br>上面代码中使用到了一个核心的方法scanPackageLI,这个方法就是实现对apk文件进行解析和安装的文件.该方法有三个,参数对应的是6参数的,来看源码:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  Scans a package and returns the newly parsed package.//返回的是刚刚解析的这个包.</span><br><span class="line"> *  @throws PackageManagerException on a parse error.</span><br><span class="line"> */</span><br><span class="line">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, File scanFile,</span><br><span class="line">        final int policyFlags, int scanFlags, long currentTime, @Nullable UserHandle user)</span><br><span class="line">        throws PackageManagerException &#123;</span><br><span class="line">    // If the package has children and this is the first dive in the function</span><br><span class="line">    // we scan the package with the SCAN_CHECK_ONLY flag set to see whether all</span><br><span class="line">    // packages (parent and children) would be successfully scanned before the</span><br><span class="line">    // actual scan since scanning mutates internal state and we want to atomically</span><br><span class="line">    // install the package and its children.</span><br><span class="line">    // 从注释看,一个package里面可能存在多个需要解析的文件</span><br><span class="line">    if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123;</span><br><span class="line">        if (pkg.childPackages != null &amp;&amp; pkg.childPackages.size() &gt; 0) &#123;</span><br><span class="line">            scanFlags |= SCAN_CHECK_ONLY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        scanFlags &amp;= ~SCAN_CHECK_ONLY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Scan the parent</span><br><span class="line">    //真正的解析工作是scanPackageInternalLI,返回的解析的包也是scanPackageInternalLI返回的</span><br><span class="line">    PackageParser.Package scannedPkg = scanPackageInternalLI(pkg, scanFile, policyFlags,</span><br><span class="line">            scanFlags, currentTime, user);</span><br><span class="line"></span><br><span class="line">    // Scan the children</span><br><span class="line">    final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;</span><br><span class="line">    for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">        PackageParser.Package childPackage = pkg.childPackages.get(i);</span><br><span class="line">        scanPackageInternalLI(childPackage, scanFile, policyFlags, scanFlags,//是scanPackageInternalLI干活</span><br><span class="line">                currentTime, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123;</span><br><span class="line">        return scanPackageLI(pkg, scanFile, policyFlags, scanFlags, currentTime, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return scannedPkg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>OTA升级使用到scanPackageInternalLI,该方法作用就是比对新旧包,判断是否更换.分析scanPackageInternalLI的源码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  Scans a package and returns the newly parsed package.</span><br><span class="line"> *  @throws PackageManagerException on a parse error.</span><br><span class="line"> */</span><br><span class="line">//scanPackageInternalLI方法是把扫描到的androidmainifest数据和之前在手机内扫描得到的数据做对比，然后进行对应操作。</span><br><span class="line">private PackageParser.Package scanPackageInternalLI(PackageParser.Package pkg, File scanFile,</span><br><span class="line">        int policyFlags, int scanFlags, long currentTime, @Nullable UserHandle user)</span><br><span class="line">        throws PackageManagerException &#123;</span><br><span class="line">    PackageSetting ps = null;</span><br><span class="line">    PackageSetting updatedPkg;</span><br><span class="line">    // reader</span><br><span class="line">    synchronized (mPackages) &#123;</span><br><span class="line">        // 看是否是已知的包,并对其进行操作</span><br><span class="line">        // Look to see if we already know about this package.</span><br><span class="line">        String oldName = mSettings.getRenamedPackageLPr(pkg.packageName);</span><br><span class="line">        if (pkg.mOriginalPackages != null &amp;&amp; pkg.mOriginalPackages.contains(oldName)) &#123;</span><br><span class="line">            // This package has been renamed to its original name.  Let&apos;s</span><br><span class="line">            // use that.</span><br><span class="line">            ps = mSettings.getPackageLPr(oldName);</span><br><span class="line">        &#125;</span><br><span class="line">        // If there was no original package, see one for the real package name.</span><br><span class="line">        if (ps == null) &#123;</span><br><span class="line">            ps = mSettings.getPackageLPr(pkg.packageName);</span><br><span class="line">        &#125;</span><br><span class="line">        // Check to see if this package could be hiding/updating a system</span><br><span class="line">        // package.  Must look for it either under the original or real</span><br><span class="line">        // package name depending on our state.</span><br><span class="line">        updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName);</span><br><span class="line">        if (DEBUG_INSTALL &amp;&amp; updatedPkg != null) Slog.d(TAG, &quot;updatedPkg = &quot; + updatedPkg);</span><br><span class="line"></span><br><span class="line">        // 非第一次启动 如果是一个已卸载的系统应用或者vendor app(厂商应用)则直接返回null</span><br><span class="line">        /// M: Skip an uninstalled system or vendor app</span><br><span class="line">        if (!isFirstBoot() &amp;&amp; (isVendorApp(pkg) || isSystemApp(pkg))</span><br><span class="line">             &amp;&amp; ((updatedPkg != null)</span><br><span class="line">                  || (ps.getInstallStatus() == PackageSettingBase.PKG_INSTALL_INCOMPLETE))) &#123;</span><br><span class="line">             Slog.d(TAG, &quot;Skip scanning &quot; + scanFile.toString() + &quot;, package &quot; + updatedPkg +</span><br><span class="line">                        &quot;, install status:  &quot; + ps.getInstallStatus());</span><br><span class="line">             return null;</span><br><span class="line">        &#125; else if (ps == null &amp;&amp; updatedPkg != null) &#123;</span><br><span class="line">            Slog.d(TAG, &quot;Skip scanning uninstalled package: &quot; + pkg.packageName);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If this is a package we don&apos;t know about on the system partition, we</span><br><span class="line">        // may need to remove disabled child packages on the system partition</span><br><span class="line">        // or may need to not add child packages if the parent apk is updated</span><br><span class="line">        // on the data partition and no longer defines this child package.</span><br><span class="line">        if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM) != 0) &#123;</span><br><span class="line">            // If this is a parent package for an updated system app and this system</span><br><span class="line">            // app got an OTA update which no longer defines some of the child packages</span><br><span class="line">            // we have to prune them from the disabled system packages.</span><br><span class="line">            PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);</span><br><span class="line">            if (disabledPs != null) &#123;//和OTA升级相关</span><br><span class="line">                final int scannedChildCount = (pkg.childPackages != null)</span><br><span class="line">                        ? pkg.childPackages.size() : 0;</span><br><span class="line">                final int disabledChildCount = disabledPs.childPackageNames != null</span><br><span class="line">                        ? disabledPs.childPackageNames.size() : 0;</span><br><span class="line">                for (int i = 0; i &lt; disabledChildCount; i++) &#123;</span><br><span class="line">                    String disabledChildPackageName = disabledPs.childPackageNames.get(i);</span><br><span class="line">                    boolean disabledPackageAvailable = false;</span><br><span class="line">                    for (int j = 0; j &lt; scannedChildCount; j++) &#123;</span><br><span class="line">                        PackageParser.Package childPkg = pkg.childPackages.get(j);</span><br><span class="line">                        if (childPkg.packageName.equals(disabledChildPackageName)) &#123;</span><br><span class="line">                            disabledPackageAvailable = true;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                     if (!disabledPackageAvailable) &#123;</span><br><span class="line">                         mSettings.removeDisabledSystemPackageLPw(disabledChildPackageName);</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 首先检查是否包含更新的系统包，包括vendor目录下</span><br><span class="line">    final boolean isUpdatedPkg = updatedPkg != null;</span><br><span class="line">    /// M: [Operator] Package in vendor folder should also be checked.</span><br><span class="line">    final boolean isUpdatedSystemPkg = isUpdatedPkg</span><br><span class="line">            &amp;&amp; ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM) != 0</span><br><span class="line">             || (policyFlags &amp; PackageParser.PARSE_IS_OPERATOR) != 0);</span><br><span class="line">    boolean isUpdatedPkgBetter = false;</span><br><span class="line">    // First check if this is a system package that may involve an update</span><br><span class="line">    if (isUpdatedSystemPkg) &#123;//是一个更新的系统包</span><br><span class="line">        // If new package is not located in &quot;/system/priv-app&quot; (e.g. due to an OTA),</span><br><span class="line">        // it needs to drop FLAG_PRIVILEGED.</span><br><span class="line">        //如果新的包不在priv-app下，应该下调Flag</span><br><span class="line">        if (locationIsPrivileged(scanFile)) &#123;</span><br><span class="line">            updatedPkg.pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            updatedPkg.pkgPrivateFlags &amp;= ~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果扫描到的包路径发生了变化，根据已经存储的内容来判断该如何操作此app,记录下flag用于后面的使用</span><br><span class="line">        if (ps != null &amp;&amp; !ps.codePath.equals(scanFile)) &#123;</span><br><span class="line">            // The path has changed from what was last scanned...  check the</span><br><span class="line">            // version of the new path against what we have stored to determine</span><br><span class="line">            // what to do.</span><br><span class="line">            if (DEBUG_INSTALL) Slog.d(TAG, &quot;Path changing from &quot; + ps.codePath);</span><br><span class="line">            ///M: [Operator] Allow vendor package downgrade.</span><br><span class="line">            ///Always install the updated one on data partition.</span><br><span class="line">            if (pkg.mVersionCode &lt; ps.versionCode</span><br><span class="line">                   || ((policyFlags &amp; PackageParser.PARSE_IS_OPERATOR) != 0)</span><br><span class="line">                   /// M: Removable system app support</span><br><span class="line">                   || isRemovableSysApp(pkg.packageName)) &#123;</span><br><span class="line">                // The system package has been updated and the code path does not match</span><br><span class="line">                // Ignore entry. Skip it.</span><br><span class="line">                if (DEBUG_INSTALL) Slog.i(TAG, &quot;Package &quot; + ps.name + &quot; at &quot; + scanFile</span><br><span class="line">                        + &quot; ignored: updated version &quot; + ps.versionCode</span><br><span class="line">                        + &quot; better than this &quot; + pkg.mVersionCode);</span><br><span class="line">                if (!updatedPkg.codePath.equals(scanFile)) &#123;</span><br><span class="line">                    Slog.w(PackageManagerService.TAG, &quot;Code path for hidden system pkg &quot;</span><br><span class="line">                            + ps.name + &quot; changing from &quot; + updatedPkg.codePathString</span><br><span class="line">                            + &quot; to &quot; + scanFile);</span><br><span class="line">                    updatedPkg.codePath = scanFile;</span><br><span class="line">                    updatedPkg.codePathString = scanFile.toString();</span><br><span class="line">                    updatedPkg.resourcePath = scanFile;</span><br><span class="line">                    updatedPkg.resourcePathString = scanFile.toString();</span><br><span class="line">                &#125;</span><br><span class="line">                updatedPkg.pkg = pkg;</span><br><span class="line">                updatedPkg.versionCode = pkg.mVersionCode;</span><br><span class="line"></span><br><span class="line">                // Update the disabled system child packages to point to the package too.</span><br><span class="line">                final int childCount = updatedPkg.childPackageNames != null</span><br><span class="line">                        ? updatedPkg.childPackageNames.size() : 0;</span><br><span class="line">                for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">                    String childPackageName = updatedPkg.childPackageNames.get(i);</span><br><span class="line">                    PackageSetting updatedChildPkg = mSettings.getDisabledSystemPkgLPr(</span><br><span class="line">                            childPackageName);</span><br><span class="line">                    if (updatedChildPkg != null) &#123;</span><br><span class="line">                        updatedChildPkg.pkg = pkg;</span><br><span class="line">                        updatedChildPkg.versionCode = pkg.mVersionCode;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;// /system下的package比我们在/data目下pacakage好</span><br><span class="line">                // The current app on the system partition is better than</span><br><span class="line">                // what we have updated to on the data partition; switch</span><br><span class="line">                // back to the system partition version.</span><br><span class="line">                // At this point, its safely assumed that package installation for</span><br><span class="line">                // apps in system partition will go through. If not there won&apos;t be a working</span><br><span class="line">                // version of the app</span><br><span class="line">                // writer</span><br><span class="line">                synchronized (mPackages) &#123;</span><br><span class="line">                    // Just remove the loaded entries from package lists.</span><br><span class="line">                    mPackages.remove(ps.name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logCriticalInfo(Log.WARN, &quot;Package &quot; + ps.name + &quot; at &quot; + scanFile</span><br><span class="line">                        + &quot; reverting from &quot; + ps.codePathString</span><br><span class="line">                        + &quot;: new version &quot; + pkg.mVersionCode</span><br><span class="line">                        + &quot; better than installed &quot; + ps.versionCode);</span><br><span class="line"></span><br><span class="line">                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps),</span><br><span class="line">                        ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));</span><br><span class="line">                synchronized (mInstallLock) &#123;</span><br><span class="line">                    args.cleanUpResourcesLI();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (mPackages) &#123;</span><br><span class="line">                    mSettings.enableSystemPackageLPw(ps.name);</span><br><span class="line">                &#125;</span><br><span class="line">                isUpdatedPkgBetter = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String resourcePath = null;</span><br><span class="line">    String baseResourcePath = null;</span><br><span class="line">    if ((policyFlags &amp; PackageParser.PARSE_FORWARD_LOCK) != 0 &amp;&amp; !isUpdatedPkgBetter) &#123;</span><br><span class="line">        if (ps != null &amp;&amp; ps.resourcePathString != null) &#123;</span><br><span class="line">            resourcePath = ps.resourcePathString;</span><br><span class="line">            baseResourcePath = ps.resourcePathString;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Should not happen at all. Just log an error.</span><br><span class="line">            Slog.e(TAG, &quot;Resource path not set for package &quot; + pkg.packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        resourcePath = pkg.codePath;</span><br><span class="line">        baseResourcePath = pkg.baseCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //精确的设置app的路径</span><br><span class="line">    // Set application objects path explicitly.</span><br><span class="line">    pkg.setApplicationVolumeUuid(pkg.volumeUuid);</span><br><span class="line">    pkg.setApplicationInfoCodePath(pkg.codePath);</span><br><span class="line">    pkg.setApplicationInfoBaseCodePath(pkg.baseCodePath);</span><br><span class="line">    pkg.setApplicationInfoSplitCodePaths(pkg.splitCodePaths);</span><br><span class="line">    pkg.setApplicationInfoResourcePath(resourcePath);</span><br><span class="line">    pkg.setApplicationInfoBaseResourcePath(baseResourcePath);</span><br><span class="line">    pkg.setApplicationInfoSplitResourcePaths(pkg.splitCodePaths);</span><br><span class="line"></span><br><span class="line">    // throw an exception if we have an update to a system application, but, it&apos;s not more</span><br><span class="line">    // recent than the package we&apos;ve already scanned</span><br><span class="line">    if (isUpdatedSystemPkg &amp;&amp; !isUpdatedPkgBetter) &#123;</span><br><span class="line">        // Set CPU Abis to application info.</span><br><span class="line">        if ((scanFlags &amp; SCAN_FIRST_BOOT_OR_UPGRADE) != 0) &#123;</span><br><span class="line">            final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, updatedPkg);</span><br><span class="line">            derivePackageAbi(pkg, scanFile, cpuAbiOverride, false, mAppLib32InstallDir);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pkg.applicationInfo.primaryCpuAbi = updatedPkg.primaryCpuAbiString;</span><br><span class="line">            pkg.applicationInfo.secondaryCpuAbi = updatedPkg.secondaryCpuAbiString;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new PackageManagerException(Log.WARN, &quot;Package &quot; + ps.name + &quot; at &quot;</span><br><span class="line">                + scanFile + &quot; ignored: updated version &quot; + ps.versionCode</span><br><span class="line">                + &quot; better than this &quot; + pkg.mVersionCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isUpdatedPkg) &#123;</span><br><span class="line">        // An updated system app will not have the PARSE_IS_SYSTEM flag set</span><br><span class="line">        // initially</span><br><span class="line">        /** M: [Operator] Only system app have system flag @&#123; */</span><br><span class="line">        if (isSystemApp(updatedPkg)) &#123;</span><br><span class="line">            policyFlags |= PackageParser.PARSE_IS_SYSTEM;</span><br><span class="line">        &#125;</span><br><span class="line">        /// M: [Operator] Add operator flags for updated vendor package</span><br><span class="line">        /// We should consider an operator app with flag changed after OTA</span><br><span class="line">        if ((isVendorApp(updatedPkg) || locationIsOperator(updatedPkg.codePath))</span><br><span class="line">                &amp;&amp; locationIsOperator(ps.codePath)) &#123;</span><br><span class="line">            policyFlags |= PackageParser.PARSE_IS_OPERATOR;</span><br><span class="line">        &#125;</span><br><span class="line">        /** @&#125; */</span><br><span class="line"></span><br><span class="line">        // An updated privileged app will not have the PARSE_IS_PRIVILEGED</span><br><span class="line">        // flag set initially</span><br><span class="line">        if ((updatedPkg.pkgPrivateFlags &amp; ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) &#123;</span><br><span class="line">            policyFlags |= PackageParser.PARSE_IS_PRIVILEGED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //扫描验证证书</span><br><span class="line">    // Verify certificates against what was last scanned</span><br><span class="line">    collectCertificatesLI(ps, pkg, scanFile, policyFlags);</span><br><span class="line"></span><br><span class="line">    //一个新的system app，但有一个已安装的同名非系统app</span><br><span class="line">    // 这里的代码是处理这样的情景：当系统更新后，可能更新包会多出一些system app出来，那么如果此时用户恰好安装了一个同包名的app.</span><br><span class="line">    // 两者的签名还不一致，那么就删除扫描到的系统应用的信息。</span><br><span class="line">    // 当两者签名一致时，如果扫描到的app版本更高，那么就删除安装的应用；如果扫描的app版本低，那么隐藏扫描到的系统应用。</span><br><span class="line">   /*</span><br><span class="line">     * A new system app appeared, but we already had a non-system one of the</span><br><span class="line">     * same name installed earlier.</span><br><span class="line">     */</span><br><span class="line">    boolean shouldHideSystemApp = false;</span><br><span class="line">    if (!isUpdatedPkg &amp;&amp; ps != null</span><br><span class="line">            &amp;&amp; (policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) != 0 &amp;&amp; !isSystemApp(ps)) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Check to make sure the signatures match first. If they don&apos;t,</span><br><span class="line">         * wipe the installed application and its data.</span><br><span class="line">         */</span><br><span class="line">        //如果签名不同，擦除已安装应用和数据</span><br><span class="line">        if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures)</span><br><span class="line">                != PackageManager.SIGNATURE_MATCH) &#123;</span><br><span class="line">            logCriticalInfo(Log.WARN, &quot;Package &quot; + ps.name + &quot; appeared on system, but&quot;</span><br><span class="line">                    + &quot; signatures don&apos;t match existing userdata copy; removing&quot;);</span><br><span class="line">            try (PackageFreezer freezer = freezePackage(pkg.packageName,</span><br><span class="line">                    &quot;scanPackageInternalLI&quot;)) &#123;</span><br><span class="line">                deletePackageLIF(pkg.packageName, null, true, null, 0, null, false, null);</span><br><span class="line">            &#125;</span><br><span class="line">            ps = null;</span><br><span class="line">        &#125; else &#123;//签名相同,继续判断</span><br><span class="line">            /*</span><br><span class="line">             * If the newly-added system app is an older version than the</span><br><span class="line">             * already installed version, hide it. It will be scanned later</span><br><span class="line">             * and re-added like an update.</span><br><span class="line">             */</span><br><span class="line">            if (pkg.mVersionCode &lt;= ps.versionCode) &#123;//新添加app更旧，则隐藏此app，后续会重新添加</span><br><span class="line">                shouldHideSystemApp = true;</span><br><span class="line">                logCriticalInfo(Log.INFO, &quot;Package &quot; + ps.name + &quot; appeared at &quot; + scanFile</span><br><span class="line">                        + &quot; but new version &quot; + pkg.mVersionCode + &quot; better than installed &quot;</span><br><span class="line">                        + ps.versionCode + &quot;; hiding system&quot;);</span><br><span class="line">            &#125; else &#123;//如果比已安装的app新，则保留app数据直接安装更新此system app</span><br><span class="line">                /*</span><br><span class="line">                 * The newly found system app is a newer version that the</span><br><span class="line">                 * one previously installed. Simply remove the</span><br><span class="line">                 * already-installed application and replace it with our own</span><br><span class="line">                 * while keeping the application data.</span><br><span class="line">                 */</span><br><span class="line">                logCriticalInfo(Log.WARN, &quot;Package &quot; + ps.name + &quot; at &quot; + scanFile</span><br><span class="line">                        + &quot; reverting from &quot; + ps.codePathString + &quot;: new version &quot;</span><br><span class="line">                        + pkg.mVersionCode + &quot; better than installed &quot; + ps.versionCode);</span><br><span class="line">                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps),</span><br><span class="line">                        ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));</span><br><span class="line">                synchronized (mInstallLock) &#123;</span><br><span class="line">                    args.cleanUpResourcesLI();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The apk is forward locked (not public) if its code and resources</span><br><span class="line">    // are kept in different files. (except for app in either system or</span><br><span class="line">    // vendor path).</span><br><span class="line">    // TODO grab this value from PackageSettings</span><br><span class="line">    //如果app中制定的资源在别的路径，则从PackageSettings中抓取</span><br><span class="line">    if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123;</span><br><span class="line">        if (ps != null &amp;&amp; !ps.codePath.equals(ps.resourcePath)) &#123;</span><br><span class="line">            policyFlags |= PackageParser.PARSE_FORWARD_LOCK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int userId = ((user == null) ? 0 : user.getIdentifier());</span><br><span class="line">    if (ps != null &amp;&amp; ps.getInstantApp(userId)) &#123;</span><br><span class="line">        scanFlags |= SCAN_AS_INSTANT_APP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Note that we invoke the following method only if we are about to unpack an application</span><br><span class="line">    PackageParser.Package scannedPkg = scanPackageLI(pkg, policyFlags, scanFlags//这里是5参数的scanPackageLI方法,第一个参数是PackageParser.Package类型</span><br><span class="line">            | SCAN_UPDATE_SIGNATURE, currentTime, user);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * If the system app should be overridden by a previously installed</span><br><span class="line">     * data, hide the system app now and let the /data/app scan pick it up</span><br><span class="line">     * again.</span><br><span class="line">     */</span><br><span class="line">    if (shouldHideSystemApp) &#123;//该package被隐藏</span><br><span class="line">        synchronized (mPackages) &#123;</span><br><span class="line">            mSettings.disableSystemPackageLPw(pkg.packageName, true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return scannedPkg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的分析看出scanPackageInternalLI方法主要还是进行比对新旧package信息(主要是OTA升级带来的升级包),进行相关的参数判断,设置不同的参数,最后交给5参数的scanPackageLI方法,<br>从5参数的scanPackageLI方法开始才开始,所有合法性验证都通过,开始解析,安装这个package.:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private PackageParser.Package scanPackageLI(PackageParser.Package pkg, final int policyFlags,</span><br><span class="line">        int scanFlags, long currentTime, @Nullable UserHandle user)</span><br><span class="line">                throws PackageManagerException &#123;</span><br><span class="line">    boolean success = false;</span><br><span class="line">    try &#123;//scanPackageDirtyLI是安装的核心函数,不论是开机扫描还是adb安装都会调用到该函数进行APK安装</span><br><span class="line">        final PackageParser.Package res = scanPackageDirtyLI(pkg, policyFlags, scanFlags,</span><br><span class="line">                currentTime, user);</span><br><span class="line">        success = true;</span><br><span class="line">        return res;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!success &amp;&amp; (scanFlags &amp; SCAN_DELETE_DATA_ON_FAILURES) != 0) &#123;</span><br><span class="line">            // DELETE_DATA_ON_FAILURES is only used by frozen paths</span><br><span class="line">            destroyAppDataLIF(pkg, UserHandle.USER_ALL,</span><br><span class="line">                    StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE);</span><br><span class="line">            destroyAppProfilesLIF(pkg, UserHandle.USER_ALL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>快来看看这个scanPackageDirtyLI函数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获得前面所解析的应用程序的组件配置信息，以及为这个应用程序分配Linux用户ID</span><br><span class="line">private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg,</span><br><span class="line">        final int policyFlags, final int scanFlags, long currentTime, @Nullable UserHandle user)</span><br><span class="line">                throws PackageManagerException &#123;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_PACKAGE_SCANNING) &#123;</span><br><span class="line">        if ((policyFlags &amp; PackageParser.PARSE_CHATTY) != 0)</span><br><span class="line">            Log.d(TAG, &quot;Scanning package &quot; + pkg.packageName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    applyPolicy(pkg, policyFlags);</span><br><span class="line"></span><br><span class="line">    // Begin added by Xutao.Wu for Task5185134 on 2017/09/22</span><br><span class="line">    if (PackageManager.TCT_RETAILDEMO_PACKAGE_NAME.equals(pkg.packageName))&#123;</span><br><span class="line">        if (DEBUG_INSTALL) Slog.w(TAG,&quot;scanPackageDirtyLI, set retaildemo as SYSTEM PRIVILEGED&quot;);</span><br><span class="line">        pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;</span><br><span class="line">        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;</span><br><span class="line">    &#125;</span><br><span class="line">    // End added by Xutao.Wu for Task5185134 on 2017/09/22</span><br><span class="line">    // 方法的作用是判断给定的pkg是不是有效的</span><br><span class="line">    assertPackageIsValid(pkg, policyFlags, scanFlags);</span><br><span class="line"></span><br><span class="line">    // Initialize package source and resource directories</span><br><span class="line">    final File scanFile = new File(pkg.codePath);</span><br><span class="line">    final File destCodeFile = new File(pkg.applicationInfo.getCodePath());</span><br><span class="line">    final File destResourceFile = new File(pkg.applicationInfo.getResourcePath());</span><br><span class="line"></span><br><span class="line">    SharedUserSetting suid = null;</span><br><span class="line">    PackageSetting pkgSetting = null;</span><br><span class="line"></span><br><span class="line">    // Getting the package setting may have a side-effect, so if we</span><br><span class="line">    // are only checking if scan would succeed, stash a copy of the</span><br><span class="line">    // old setting to restore at the end.</span><br><span class="line">    PackageSetting nonMutatedPs = null;</span><br><span class="line"></span><br><span class="line">    // We keep references to the derived CPU Abis from settings in oder to reuse</span><br><span class="line">    // them in the case where we&apos;re not upgrading or booting for the first time.</span><br><span class="line">    String primaryCpuAbiFromSettings = null;</span><br><span class="line">    String secondaryCpuAbiFromSettings = null;</span><br><span class="line"></span><br><span class="line">    // writer</span><br><span class="line">    // 为参数pkg所描述的应用程序分配Linux用户ID</span><br><span class="line">    synchronized (mPackages) &#123;</span><br><span class="line">        if (pkg.mSharedUserId != null) &#123;// 如果该应用有sharedUserId属性，则从mSettings中获取要为它分配的共享uid</span><br><span class="line">            // SIDE EFFECTS; may potentially allocate a new shared user</span><br><span class="line">            suid = mSettings.getSharedUserLPw(</span><br><span class="line">                    pkg.mSharedUserId, 0 /*pkgFlags*/, 0 /*pkgPrivateFlags*/, true /*create*/);</span><br><span class="line">            if (DEBUG_PACKAGE_SCANNING) &#123;</span><br><span class="line">                if ((policyFlags &amp; PackageParser.PARSE_CHATTY) != 0)</span><br><span class="line">                    Log.d(TAG, &quot;Shared UserID &quot; + pkg.mSharedUserId + &quot; (uid=&quot; + suid.userId</span><br><span class="line">                            + &quot;): packages=&quot; + suid.packages);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check if we are renaming from an original package name.</span><br><span class="line">        PackageSetting origPackage = null;</span><br><span class="line">        String realName = null;</span><br><span class="line">        if (pkg.mOriginalPackages != null) &#123;</span><br><span class="line">            // This package may need to be renamed to a previously</span><br><span class="line">            // installed name.  Let&apos;s check on that...</span><br><span class="line">            final String renamed = mSettings.getRenamedPackageLPr(pkg.mRealPackage);</span><br><span class="line">            if (pkg.mOriginalPackages.contains(renamed)) &#123;</span><br><span class="line">                // This package had originally been installed as the</span><br><span class="line">                // original name, and we have already taken care of</span><br><span class="line">                // transitioning to the new one.  Just update the new</span><br><span class="line">                // one to continue using the old name.</span><br><span class="line">                realName = pkg.mRealPackage;</span><br><span class="line">                if (!pkg.packageName.equals(renamed)) &#123;</span><br><span class="line">                    // Callers into this function may have already taken</span><br><span class="line">                    // care of renaming the package; only do it here if</span><br><span class="line">                    // it is not already done.</span><br><span class="line">                    pkg.setPackageName(renamed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (int i=pkg.mOriginalPackages.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">                    if ((origPackage = mSettings.getPackageLPr(</span><br><span class="line">                            pkg.mOriginalPackages.get(i))) != null) &#123;</span><br><span class="line">                        // We do have the package already installed under its</span><br><span class="line">                        // original name...  should we use it?</span><br><span class="line">                        if (!verifyPackageUpdateLPr(origPackage, pkg)) &#123;</span><br><span class="line">                            // New package is not compatible with original.</span><br><span class="line">                            origPackage = null;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125; else if (origPackage.sharedUser != null) &#123;</span><br><span class="line">                            // Make sure uid is compatible between packages.</span><br><span class="line">                            if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) &#123;</span><br><span class="line">                                Slog.w(TAG, &quot;Unable to migrate data from &quot; + origPackage.name</span><br><span class="line">                                        + &quot; to &quot; + pkg.packageName + &quot;: old uid &quot;</span><br><span class="line">                                        + origPackage.sharedUser.name</span><br><span class="line">                                        + &quot; differs from &quot; + pkg.mSharedUserId);</span><br><span class="line">                                origPackage = null;</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line">                            // TODO: Add case when shared user id is added [b/28144775]</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            if (DEBUG_UPGRADE) Log.v(TAG, &quot;Renaming new package &quot;</span><br><span class="line">                                    + pkg.packageName + &quot; to old name &quot; + origPackage.name);</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mTransferedPackages.contains(pkg.packageName)) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Package &quot; + pkg.packageName</span><br><span class="line">                    + &quot; was transferred to another, but its .apk remains&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // See comments in nonMutatedPs declaration</span><br><span class="line">        if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123;</span><br><span class="line">            PackageSetting foundPs = mSettings.getPackageLPr(pkg.packageName);</span><br><span class="line">            if (foundPs != null) &#123;</span><br><span class="line">                nonMutatedPs = new PackageSetting(foundPs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((scanFlags &amp; SCAN_FIRST_BOOT_OR_UPGRADE) == 0) &#123;</span><br><span class="line">            PackageSetting foundPs = mSettings.getPackageLPr(pkg.packageName);</span><br><span class="line">            if (foundPs != null) &#123;</span><br><span class="line">                primaryCpuAbiFromSettings = foundPs.primaryCpuAbiString;</span><br><span class="line">                secondaryCpuAbiFromSettings = foundPs.secondaryCpuAbiString;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 创建PackageSetting并设置</span><br><span class="line">        pkgSetting = mSettings.getPackageLPr(pkg.packageName);</span><br><span class="line">        if (pkgSetting != null &amp;&amp; pkgSetting.sharedUser != suid) &#123;</span><br><span class="line">            PackageManagerService.reportSettingsProblem(Log.WARN,</span><br><span class="line">                    &quot;Package &quot; + pkg.packageName + &quot; shared user changed from &quot;</span><br><span class="line">                            + (pkgSetting.sharedUser != null</span><br><span class="line">                                    ? pkgSetting.sharedUser.name : &quot;&lt;nothing&gt;&quot;)</span><br><span class="line">                            + &quot; to &quot;</span><br><span class="line">                            + (suid != null ? suid.name : &quot;&lt;nothing&gt;&quot;)</span><br><span class="line">                            + &quot;; replacing with new&quot;);</span><br><span class="line">            pkgSetting = null;</span><br><span class="line">        &#125;</span><br><span class="line">        final PackageSetting oldPkgSetting =</span><br><span class="line">                pkgSetting == null ? null : new PackageSetting(pkgSetting);</span><br><span class="line">        final PackageSetting disabledPkgSetting =</span><br><span class="line">                mSettings.getDisabledSystemPkgLPr(pkg.packageName);</span><br><span class="line"></span><br><span class="line">        String[] usesStaticLibraries = null;</span><br><span class="line">        if (pkg.usesStaticLibraries != null) &#123;</span><br><span class="line">            usesStaticLibraries = new String[pkg.usesStaticLibraries.size()];</span><br><span class="line">            pkg.usesStaticLibraries.toArray(usesStaticLibraries);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (pkgSetting == null) &#123;</span><br><span class="line">            final String parentPackageName = (pkg.parentPackage != null)</span><br><span class="line">                    ? pkg.parentPackage.packageName : null;</span><br><span class="line">            final boolean instantApp = (scanFlags &amp; SCAN_AS_INSTANT_APP) != 0;</span><br><span class="line">            // REMOVE SharedUserSetting from method; update in a separate call</span><br><span class="line">            pkgSetting = Settings.createNewSetting(pkg.packageName, origPackage,</span><br><span class="line">                    disabledPkgSetting, realName, suid, destCodeFile, destResourceFile,</span><br><span class="line">                    pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi,</span><br><span class="line">                    pkg.applicationInfo.secondaryCpuAbi, pkg.mVersionCode,</span><br><span class="line">                    pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags,</span><br><span class="line">                    /// M: [FlagExt] Add flagsEx</span><br><span class="line">                    pkg.applicationInfo.flagsEx, user,</span><br><span class="line">                    true /*allowInstall*/, instantApp, parentPackageName,</span><br><span class="line">                    pkg.getChildPackageNames(), UserManagerService.getInstance(),</span><br><span class="line">                    usesStaticLibraries, pkg.usesStaticLibrariesVersions);</span><br><span class="line">            // SIDE EFFECTS; updates system state; move elsewhere</span><br><span class="line">            if (origPackage != null) &#123;</span><br><span class="line">                mSettings.addRenamedPackageLPw(pkg.packageName, origPackage.name);</span><br><span class="line">            &#125;</span><br><span class="line">            mSettings.addUserToSettingLPw(pkgSetting);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // REMOVE SharedUserSetting from method; update in a separate call.</span><br><span class="line">            //</span><br><span class="line">            // TODO(narayan): This update is bogus. nativeLibraryDir &amp; primaryCpuAbi,</span><br><span class="line">            // secondaryCpuAbi are not known at this point so we always update them</span><br><span class="line">            // to null here, only to reset them at a later point.</span><br><span class="line">            Settings.updatePackageSetting(pkgSetting, disabledPkgSetting, suid, destCodeFile,</span><br><span class="line">                    pkg.applicationInfo.nativeLibraryDir, pkg.applicationInfo.primaryCpuAbi,</span><br><span class="line">                    pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags,</span><br><span class="line">                    pkg.applicationInfo.privateFlags, pkg.getChildPackageNames(),</span><br><span class="line">                    UserManagerService.getInstance(), usesStaticLibraries,</span><br><span class="line">                    pkg.usesStaticLibrariesVersions);</span><br><span class="line">        &#125;</span><br><span class="line">        // SIDE EFFECTS; persists system state to files on disk; move elsewhere</span><br><span class="line">        mSettings.writeUserRestrictionsLPw(pkgSetting, oldPkgSetting);</span><br><span class="line"></span><br><span class="line">        // SIDE EFFECTS; modifies system state; move elsewhere</span><br><span class="line">        if (pkgSetting.origPackage != null) &#123;</span><br><span class="line">            // If we are first transitioning from an original package,</span><br><span class="line">            // fix up the new package&apos;s name now.  We need to do this after</span><br><span class="line">            // looking up the package under its new name, so getPackageLP</span><br><span class="line">            // can take care of fiddling things correctly.</span><br><span class="line">            pkg.setPackageName(origPackage.name);</span><br><span class="line"></span><br><span class="line">            // File a report about this.</span><br><span class="line">            String msg = &quot;New package &quot; + pkgSetting.realName</span><br><span class="line">                    + &quot; renamed to replace old package &quot; + pkgSetting.name;</span><br><span class="line">            reportSettingsProblem(Log.WARN, msg);</span><br><span class="line"></span><br><span class="line">            // Make a note of it.</span><br><span class="line">            if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0) &#123;</span><br><span class="line">                mTransferedPackages.add(origPackage.name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // No longer need to retain this.</span><br><span class="line">            pkgSetting.origPackage = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // SIDE EFFECTS; modifies system state; move elsewhere</span><br><span class="line">        if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0 &amp;&amp; realName != null) &#123;</span><br><span class="line">            // Make a note of it.</span><br><span class="line">            mTransferedPackages.add(pkg.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) &#123;</span><br><span class="line">            /** M: [Operator] Operator package should not have FLAG_UPDATED_SYSTEM_APP @&#123; */</span><br><span class="line">            PackageSetting oldPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);</span><br><span class="line">            if (oldPs != null &amp;&amp; !isVendorApp(oldPs)) &#123;</span><br><span class="line">            pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;</span><br><span class="line">            &#125;</span><br><span class="line">            /** @&#125; */</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((scanFlags &amp; SCAN_BOOTING) == 0</span><br><span class="line">                &amp;&amp; (policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123;</span><br><span class="line">            // Check all shared libraries and map to their actual file path.</span><br><span class="line">            // We only do this here for apps not on a system dir, because those</span><br><span class="line">            // are the only ones that can fail an install due to this.  We</span><br><span class="line">            // will take care of the system apps by updating all of their</span><br><span class="line">            // library paths after the scan is done. Also during the initial</span><br><span class="line">            // scan don&apos;t update any libs as we do this wholesale after all</span><br><span class="line">            // apps are scanned to avoid dependency based scanning.</span><br><span class="line">            updateSharedLibrariesLPr(pkg, null);//创建共享库</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mFoundPolicyFile) &#123;</span><br><span class="line">            SELinuxMMAC.assignSeInfoValue(pkg);//设置SELinux策略</span><br><span class="line">        &#125;</span><br><span class="line">        pkg.applicationInfo.uid = pkgSetting.appId;</span><br><span class="line">        pkg.mExtras = pkgSetting;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // Static shared libs have same package with different versions where</span><br><span class="line">        // we internally use a synthetic package name to allow multiple versions</span><br><span class="line">        // of the same package, therefore we need to compare signatures against</span><br><span class="line">        // the package setting for the latest library version.</span><br><span class="line">        //验证签名信息的合法性</span><br><span class="line">        PackageSetting signatureCheckPs = pkgSetting;</span><br><span class="line">        if (pkg.applicationInfo.isStaticSharedLibrary()) &#123;</span><br><span class="line">            SharedLibraryEntry libraryEntry = getLatestSharedLibraVersionLPr(pkg);</span><br><span class="line">            if (libraryEntry != null) &#123;</span><br><span class="line">                signatureCheckPs = mSettings.getPackageLPr(libraryEntry.apk);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (shouldCheckUpgradeKeySetLP(signatureCheckPs, scanFlags)) &#123;</span><br><span class="line">            if (checkUpgradeKeySetLP(signatureCheckPs, pkg)) &#123;</span><br><span class="line">                // We just determined the app is signed correctly, so bring</span><br><span class="line">                // over the latest parsed certs.</span><br><span class="line">                pkgSetting.signatures.mSignatures = pkg.mSignatures;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0) &#123;</span><br><span class="line">                    throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE,</span><br><span class="line">                            &quot;Package &quot; + pkg.packageName + &quot; upgrade keys do not match the &quot;</span><br><span class="line">                            + &quot;previously installed version&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    pkgSetting.signatures.mSignatures = pkg.mSignatures;</span><br><span class="line">                    String msg = &quot;System package &quot; + pkg.packageName</span><br><span class="line">                            + &quot; signature changed; retaining data.&quot;;</span><br><span class="line">                    reportSettingsProblem(Log.WARN, msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // SIDE EFFECTS; compareSignaturesCompat() changes KeysetManagerService</span><br><span class="line">                verifySignaturesLP(signatureCheckPs, pkg);</span><br><span class="line">                // We just determined the app is signed correctly, so bring</span><br><span class="line">                // over the latest parsed certs.</span><br><span class="line">                pkgSetting.signatures.mSignatures = pkg.mSignatures;</span><br><span class="line">            &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">                ///M: Add for operator APP.</span><br><span class="line">                if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) == 0</span><br><span class="line">                      &amp;&amp; (policyFlags &amp; PackageParser.PARSE_IS_OPERATOR) == 0) &#123;</span><br><span class="line">                    throw e;</span><br><span class="line">                &#125;</span><br><span class="line">                // The signature has changed, but this package is in the system</span><br><span class="line">                // image...  let&apos;s recover!</span><br><span class="line">                pkgSetting.signatures.mSignatures = pkg.mSignatures;</span><br><span class="line">                // However...  if this package is part of a shared user, but it</span><br><span class="line">                // doesn&apos;t match the signature of the shared user, let&apos;s fail.</span><br><span class="line">                // What this means is that you can&apos;t change the signatures</span><br><span class="line">                // associated with an overall shared user, which doesn&apos;t seem all</span><br><span class="line">                // that unreasonable.</span><br><span class="line">                if (signatureCheckPs.sharedUser != null) &#123;</span><br><span class="line">                    if (compareSignatures(signatureCheckPs.sharedUser.signatures.mSignatures,</span><br><span class="line">                            pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) &#123;</span><br><span class="line">                        throw new PackageManagerException(</span><br><span class="line">                                INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES,</span><br><span class="line">                                &quot;Signature mismatch for shared user: &quot;</span><br><span class="line">                                        + pkgSetting.sharedUser);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // File a report about this.</span><br><span class="line">                String msg = &quot;System package &quot; + pkg.packageName</span><br><span class="line">                        + &quot; signature changed; retaining data.&quot;;</span><br><span class="line">                reportSettingsProblem(Log.WARN, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((scanFlags &amp; SCAN_CHECK_ONLY) == 0 &amp;&amp; pkg.mAdoptPermissions != null) &#123;</span><br><span class="line">            // This package wants to adopt ownership of permissions from</span><br><span class="line">            // another package.</span><br><span class="line">            // 是否需要获取其他包的权限</span><br><span class="line">            for (int i = pkg.mAdoptPermissions.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                final String origName = pkg.mAdoptPermissions.get(i);</span><br><span class="line">                final PackageSetting orig = mSettings.getPackageLPr(origName);</span><br><span class="line">                if (orig != null) &#123;</span><br><span class="line">                    if (verifyPackageUpdateLPr(orig, pkg)) &#123;</span><br><span class="line">                        Slog.i(TAG, &quot;Adopting permissions from &quot; + origName + &quot; to &quot;</span><br><span class="line">                                + pkg.packageName);</span><br><span class="line">                        // SIDE EFFECTS; updates permissions system state; move elsewhere</span><br><span class="line">                        mSettings.transferPermissionsLPw(origName, pkg.packageName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //确定进程名称</span><br><span class="line">    pkg.applicationInfo.processName = fixProcessName(</span><br><span class="line">            pkg.applicationInfo.packageName,</span><br><span class="line">            pkg.applicationInfo.processName);</span><br><span class="line"></span><br><span class="line">    if (pkg != mPlatformPackage) &#123;</span><br><span class="line">        // Get all of our default paths setup</span><br><span class="line">        pkg.applicationInfo.initForUser(UserHandle.USER_SYSTEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);</span><br><span class="line"></span><br><span class="line">    if ((scanFlags &amp; SCAN_NEW_INSTALL) == 0) &#123;</span><br><span class="line">        if ((scanFlags &amp; SCAN_FIRST_BOOT_OR_UPGRADE) != 0) &#123;</span><br><span class="line">            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;derivePackageAbi&quot;);</span><br><span class="line">            final boolean extractNativeLibs = !pkg.isLibrary();</span><br><span class="line">            derivePackageAbi(pkg, scanFile, cpuAbiOverride, extractNativeLibs,</span><br><span class="line">                    mAppLib32InstallDir);</span><br><span class="line">            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line"></span><br><span class="line">            // Some system apps still use directory structure for native libraries</span><br><span class="line">            // in which case we might end up not detecting abi solely based on apk</span><br><span class="line">            // structure. Try to detect abi based on directory structure.</span><br><span class="line">            if (isSystemApp(pkg) &amp;&amp; !pkg.isUpdatedSystemApp() &amp;&amp;</span><br><span class="line">                    pkg.applicationInfo.primaryCpuAbi == null) &#123;</span><br><span class="line">                setBundledAppAbisAndRoots(pkg, pkgSetting);</span><br><span class="line">                setNativeLibraryPaths(pkg, mAppLib32InstallDir);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // This is not a first boot or an upgrade, don&apos;t bother deriving the</span><br><span class="line">            // ABI during the scan. Instead, trust the value that was stored in the</span><br><span class="line">            // package setting.</span><br><span class="line">            pkg.applicationInfo.primaryCpuAbi = primaryCpuAbiFromSettings;</span><br><span class="line">            pkg.applicationInfo.secondaryCpuAbi = secondaryCpuAbiFromSettings;</span><br><span class="line"></span><br><span class="line">            setNativeLibraryPaths(pkg, mAppLib32InstallDir);</span><br><span class="line"></span><br><span class="line">            if (DEBUG_ABI_SELECTION) &#123;</span><br><span class="line">                Slog.i(TAG, &quot;Using ABIS and native lib paths from settings : &quot; +</span><br><span class="line">                    pkg.packageName + &quot; &quot; + pkg.applicationInfo.primaryCpuAbi + &quot;, &quot; +</span><br><span class="line">                    pkg.applicationInfo.secondaryCpuAbi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ((scanFlags &amp; SCAN_MOVE) != 0) &#123;</span><br><span class="line">            // We haven&apos;t run dex-opt for this move (since we&apos;ve moved the compiled output too)</span><br><span class="line">            // but we already have this packages package info in the PackageSetting. We just</span><br><span class="line">            // use that and derive the native library path based on the new codepath.</span><br><span class="line">            pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;</span><br><span class="line">            pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Set native library paths again. For moves, the path will be updated based on the</span><br><span class="line">        // ABIs we&apos;ve determined above. For non-moves, the path will be updated based on the</span><br><span class="line">        // ABIs we determined during compilation, but the path will depend on the final</span><br><span class="line">        // package path (after the rename away from the stage path).</span><br><span class="line">        setNativeLibraryPaths(pkg, mAppLib32InstallDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // This is a special case for the &quot;system&quot; package, where the ABI is</span><br><span class="line">    // dictated by the zygote configuration (and init.rc). We should keep track</span><br><span class="line">    // of this ABI so that we can deal with &quot;normal&quot; applications that run under</span><br><span class="line">    // the same UID correctly.</span><br><span class="line">    if (mPlatformPackage == pkg) &#123;</span><br><span class="line">        pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ?</span><br><span class="line">                Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If there&apos;s a mismatch between the abi-override in the package setting</span><br><span class="line">    // and the abiOverride specified for the install. Warn about this because we</span><br><span class="line">    // would&apos;ve already compiled the app without taking the package setting into</span><br><span class="line">    // account.</span><br><span class="line">    if ((scanFlags &amp; SCAN_NO_DEX) == 0 &amp;&amp; (scanFlags &amp; SCAN_NEW_INSTALL) != 0) &#123;</span><br><span class="line">        if (cpuAbiOverride == null &amp;&amp; pkgSetting.cpuAbiOverrideString != null) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Ignoring persisted ABI override &quot; + cpuAbiOverride +</span><br><span class="line">                    &quot; for package &quot; + pkg.packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // CPU描述</span><br><span class="line">    pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;</span><br><span class="line">    pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;</span><br><span class="line">    pkgSetting.cpuAbiOverrideString = cpuAbiOverride;</span><br><span class="line"></span><br><span class="line">    // Copy the derived override back to the parsed package, so that we can</span><br><span class="line">    // update the package settings accordingly.</span><br><span class="line">    pkg.cpuAbiOverride = cpuAbiOverride;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_ABI_SELECTION) &#123;</span><br><span class="line">        Slog.d(TAG, &quot;Resolved nativeLibraryRoot for &quot; + pkg.applicationInfo.packageName</span><br><span class="line">                + &quot; to root=&quot; + pkg.applicationInfo.nativeLibraryRootDir + &quot;, isa=&quot;</span><br><span class="line">                + pkg.applicationInfo.nativeLibraryRootRequiresIsa);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Push the derived path down into PackageSettings so we know what to</span><br><span class="line">    // clean up at uninstall time.</span><br><span class="line">    pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_ABI_SELECTION) &#123;</span><br><span class="line">        Slog.d(TAG, &quot;Abis for package[&quot; + pkg.packageName + &quot;] are&quot; +</span><br><span class="line">                &quot; primary=&quot; + pkg.applicationInfo.primaryCpuAbi +</span><br><span class="line">                &quot; secondary=&quot; + pkg.applicationInfo.secondaryCpuAbi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // SIDE EFFECTS; removes DEX files from disk; move elsewhere</span><br><span class="line">    if ((scanFlags &amp; SCAN_BOOTING) == 0 &amp;&amp; pkgSetting.sharedUser != null) &#123;</span><br><span class="line">        // We don&apos;t do this here during boot because we can do it all</span><br><span class="line">        // at once after scanning all existing packages.</span><br><span class="line">        //</span><br><span class="line">        // We also do this *before* we perform dexopt on this package, so that</span><br><span class="line">        // we can avoid redundant dexopts, and also to make sure we&apos;ve got the</span><br><span class="line">        // code and package path correct.</span><br><span class="line">        adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mFactoryTest &amp;&amp; pkg.requestedPermissions.contains(</span><br><span class="line">            android.Manifest.permission.FACTORY_TEST)) &#123;</span><br><span class="line">        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_FACTORY_TEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isSystemApp(pkg)) &#123;</span><br><span class="line">        pkgSetting.isOrphaned = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新安装时间</span><br><span class="line">    // Take care of first install / last update times.</span><br><span class="line">    final long scanFileTime = getLastModifiedTime(pkg, scanFile);</span><br><span class="line">    if (currentTime != 0) &#123;</span><br><span class="line">        if (pkgSetting.firstInstallTime == 0) &#123;</span><br><span class="line">            pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime;</span><br><span class="line">        &#125; else if ((scanFlags &amp; SCAN_UPDATE_TIME) != 0) &#123;</span><br><span class="line">            pkgSetting.lastUpdateTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (pkgSetting.firstInstallTime == 0) &#123;</span><br><span class="line">        // We need *something*.  Take time time stamp of the file.</span><br><span class="line">        pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime;</span><br><span class="line">    &#125; else if ((policyFlags &amp; PackageParser.PARSE_IS_SYSTEM_DIR) != 0) &#123;</span><br><span class="line">        if (scanFileTime != pkgSetting.timeStamp) &#123;</span><br><span class="line">            // A package on the system image has changed; consider this</span><br><span class="line">            // to be an update.</span><br><span class="line">            pkgSetting.lastUpdateTime = scanFileTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pkgSetting.setTimeStamp(scanFileTime);</span><br><span class="line"></span><br><span class="line">    if ((scanFlags &amp; SCAN_CHECK_ONLY) != 0) &#123;</span><br><span class="line">        if (nonMutatedPs != null) &#123;</span><br><span class="line">            synchronized (mPackages) &#123;</span><br><span class="line">                mSettings.mPackages.put(nonMutatedPs.name, nonMutatedPs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final int userId = user == null ? 0 : user.getIdentifier();</span><br><span class="line">        // Modify state for the given package setting</span><br><span class="line">        // 该方法回设置很多东西包括services,providers,</span><br><span class="line">        // 更新lib时杀掉依赖此lib的进程</span><br><span class="line">        // 对framework-res.apk单独处理</span><br><span class="line">        //更新设置apk的provider并更新到数据中</span><br><span class="line">        // 广播接受者receivers,activities,permissionGroups,permissions,Instrumentation信息</span><br><span class="line">        commitPackageSettings(pkg, pkgSetting, user, scanFlags</span><br><span class="line">                (policyFlags &amp; PackageParser.PARSE_CHATTY) != 0 /*chatty*/);</span><br><span class="line">        if (pkgSetting.getInstantApp(userId)) &#123;</span><br><span class="line">            mInstantAppRegistry.addInstantAppLPw(userId, pkgSetting.appId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pkg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>scanPackageDirtyLI流程总结如下：  </p>
<ul>
<li>framework-res.apk单独处理   </li>
<li>初始化代码路径和资源路径  </li>
<li>创建共享库  </li>
<li>验证签名信息的合法性  </li>
<li>验证新的包的Provider不会与现有包冲突  </li>
<li>是否需要获得其他包的权限  </li>
<li>确定进程名称  </li>
<li>Lib库的更新设置操作等  </li>
<li>跟新Settings参数  </li>
<li>更新安装的时间  </li>
<li>四大组件、权限、Instrumentation、把解析的这些信息注册到PMS  </li>
</ul>
<p>当然上面有不少是在commitPackageSettings方法中实现的.<br>到此apk就安装完成了,在PackageManagerService的构造方法.接下来的方法就是使用一下两个方法把<br>// 为申请了特定的资源访问权限的应用程序分配相应的Linux用户组ID<br><code>updatePermissionsLPw(null, null, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags);</code><br>// 将前面获取到的应用程序安装信息保存在本地的一个配置文件中，以便下一次再安装这些应用程序时<br>// 可以将需要保持一致的应用程序信息恢复回来<br><code>mSettings.writeLPr();</code></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Michael</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lqktz.github.io/2019/04/10/PKMS扫描安装包源码分析/">https://lqktz.github.io/2019/04/10/PKMS扫描安装包源码分析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lqktz.github.io">Michael Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/10/androidstart/"><i class="fa fa-chevron-left">  </i><span>Android开机总体流程</span></a></div><div class="next-post pull-right"><a href="/2019/04/10/zygote启动/"><span>Zygote进程启动过程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Michael</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>