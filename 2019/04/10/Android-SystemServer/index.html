<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android SystemServer学习笔记"><meta name="keywords" content="Android"><meta name="author" content="Michael"><meta name="copyright" content="Michael"><title>Android SystemServer学习笔记 | Michael Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://avatars2.githubusercontent.com/u/15813289?s=460&amp;v=4"></div><div class="author-info__name text-center">Michael</div><div class="author-info__description text-center">Android性能优化</div><div class="follow-button"><a href="https://github.com/lqktz">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">6</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/fd0b722ce11f">王小二</a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Michael Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">目录</a><a class="site-page" href="/categories">分类</a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Android SystemServer学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/android/"> android</a></div><div class="article-container" id="post-content"><h3 id="版本-Android-O"><a href="#版本-Android-O" class="headerlink" title="版本:Android O"></a>版本:Android O</h3><p>SystemServer和Zygote是Android java世界的两大支柱,SystemServer是Zygote孵化出来的进程,进程名为system_server,几乎所有的系统服务都在该进程中,eg:AMS,PMS,WMS .etc<br><a id="more"></a></p>
<h2 id="1-分析SystemServer代码"><a href="#1-分析SystemServer代码" class="headerlink" title="1 分析SystemServer代码"></a>1 分析SystemServer代码</h2><h3 id="1-1-从SystemServer-java分析"><a href="#1-1-从SystemServer-java分析" class="headerlink" title="1.1 从SystemServer.java分析"></a>1.1 从SystemServer.java分析</h3><p>源码位置:<code>frameworks\base\services\java\com\android\server\SystemServer.java</code>,从main()函数开始分析:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The main entry point from zygote.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>new出一个SystemServer类,执行其run()方法.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SystemServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check for factory test mode.</span></span><br><span class="line">    mFactoryTestMode = FactoryTest.getMode();</span><br><span class="line">    <span class="comment">// Remember if it's runtime restart(when sys.boot_completed is already set) or reboot</span></span><br><span class="line">    mRuntimeRestart = <span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"sys.boot_completed"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是SystemServer的构造方法,具体没有研究,有blog说SystemServer.java是final的,不能被继承,但是在O中不是(也没有具体研究,研究了再补充).接下来看run()方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        traceBeginAndSlog(<span class="string">"InitBeforeStartServices"</span>);</span><br><span class="line">        <span class="comment">// If a device's clock is before 1970 (before 0), a lot of</span></span><br><span class="line">        <span class="comment">// APIs crash dealing with negative numbers, notably</span></span><br><span class="line">        <span class="comment">// java.io.File#setLastModified, so instead we fake it and</span></span><br><span class="line">        <span class="comment">// hope that time from cell towers or NTP fixes it shortly.</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"System clock is before 1970; setting to 1970."</span>);</span><br><span class="line">            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Default the timezone property to GMT if not set.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        String timezoneProperty =  SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">        <span class="keyword">if</span> (timezoneProperty == <span class="keyword">null</span> || timezoneProperty.isEmpty()) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Timezone not set; setting to GMT."</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.timezone"</span>, <span class="string">"GMT"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the system has "persist.sys.language" and friends set, replace them with</span></span><br><span class="line">        <span class="comment">// "persist.sys.locale". Note that the default locale at this point is calculated</span></span><br><span class="line">        <span class="comment">// using the "-Duser.locale" command line flag. That flag is usually populated by</span></span><br><span class="line">        <span class="comment">// AndroidRuntime using the same set of system properties, but only the system_server</span></span><br><span class="line">        <span class="comment">// and system apps are allowed to set them.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Most changes made here will need an equivalent change to</span></span><br><span class="line">        <span class="comment">// core/jni/AndroidRuntime.cpp</span></span><br><span class="line">        <span class="keyword">if</span> (!SystemProperties.get(<span class="string">"persist.sys.language"</span>).isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> String languageTag = Locale.getDefault().toLanguageTag();</span><br><span class="line"></span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.locale"</span>, languageTag);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.language"</span>, <span class="string">""</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.country"</span>, <span class="string">""</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.localevar"</span>, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The system server should never make non-oneway calls</span></span><br><span class="line">        Binder.setWarnOnBlocking(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here we go!</span></span><br><span class="line">        Slog.i(TAG, <span class="string">"Entered the Android system server!"</span>);</span><br><span class="line">        <span class="keyword">int</span> uptimeMillis = (<span class="keyword">int</span>) SystemClock.elapsedRealtime();</span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, uptimeMillis);</span><br><span class="line">        <span class="keyword">if</span> (!mRuntimeRestart) &#123;</span><br><span class="line">            MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_system_server_init"</span>, uptimeMillis);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// M: BOOTPROF</span></span><br><span class="line">        addBootEvent(<span class="string">"Android:SysServerInit_START"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In case the runtime switched since last boot (such as when</span></span><br><span class="line">        <span class="comment">// the old runtime was removed in an OTA), set the system</span></span><br><span class="line">        <span class="comment">// property so that it is in sync. We can | xq oqi't do this in</span></span><br><span class="line">        <span class="comment">// libnativehelper's JniInvocation::Init code where we already</span></span><br><span class="line">        <span class="comment">// had to fallback to a different runtime because it is</span></span><br><span class="line">        <span class="comment">// running as root and we need to be the system user to set</span></span><br><span class="line">        <span class="comment">// the property. http://b/11463182</span></span><br><span class="line">        SystemProperties.set(<span class="string">"persist.sys.dalvik.vm.lib.2"</span>, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enable the sampling profiler.</span></span><br><span class="line">        <span class="keyword">if</span> (SamplingProfilerIntegration.isEnabled()) &#123;</span><br><span class="line">            SamplingProfilerIntegration.start();</span><br><span class="line">            mProfilerSnapshotTimer = <span class="keyword">new</span> Timer();</span><br><span class="line">            mProfilerSnapshotTimer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        SamplingProfilerIntegration.writeSnapshot(<span class="string">"system_server"</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mmmmmm... more memory!</span></span><br><span class="line">        VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The system server has to run all of the time, so it needs to be</span></span><br><span class="line">        <span class="comment">// as efficient as possible with its memory usage.</span></span><br><span class="line">        VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.8f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Some devices rely on runtime fingerprint generation, so make sure</span></span><br><span class="line">        <span class="comment">// we've defined it before booting further.</span></span><br><span class="line">        Build.ensureFingerprintProperty();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Within the system server, it is an error to access Environment paths without</span></span><br><span class="line">        <span class="comment">// explicitly specifying a user.</span></span><br><span class="line">        Environment.setUserRequired(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Within the system server, any incoming Bundles should be defused</span></span><br><span class="line">        <span class="comment">// to avoid throwing BadParcelableException.</span></span><br><span class="line">        BaseBundle.setShouldDefuse(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure binder calls into the system always run at foreground priority.</span></span><br><span class="line">        BinderInternal.disableBackgroundScheduling(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Increase the number of binder threads in system_server</span></span><br><span class="line">        BinderInternal.setMaxThreads(sMaxBinderThreads);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the main looper thread (this thread).</span></span><br><span class="line">        android.os.Process.setThreadPriority(</span><br><span class="line">            android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">        android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//开启消息循环</span></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize native services.</span></span><br><span class="line">        System.loadLibrary(<span class="string">"android_servers"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check whether we failed to shut down last time we tried.</span></span><br><span class="line">        <span class="comment">// This call may not return.</span></span><br><span class="line">        performPendingShutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize the system context.</span></span><br><span class="line">        createSystemContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the system service manager.</span></span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">        mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">        <span class="comment">// Prepare the thread pool for init tasks that can be parallelized</span></span><br><span class="line">        SystemServerInitThreadPool.get();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建服务</span></span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        traceBeginAndSlog(<span class="string">"StartServices"</span>);</span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">        SystemServerInitThreadPool.shutdown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">"System"</span>, <span class="string">"******************************************"</span>);</span><br><span class="line">        Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting system services"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        traceEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For debug builds, log event loop stalls to dropbox for analysis.</span></span><br><span class="line">    <span class="keyword">if</span> (StrictMode.conditionallyEnableDebugLogging()) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Enabled StrictMode for system server main thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// M: open wtf when load is user or userdebug.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">"eng"</span>.equals(Build.TYPE) &amp;&amp; !mRuntimeRestart &amp;&amp; !isFirstBootOrUpgrade()) &#123;</span><br><span class="line">        <span class="keyword">int</span> uptimeMillis = (<span class="keyword">int</span>) SystemClock.elapsedRealtime();</span><br><span class="line">        MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_system_server_ready"</span>, uptimeMillis);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MAX_UPTIME_MILLIS = <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (uptimeMillis &gt; MAX_UPTIME_MILLIS) &#123;</span><br><span class="line">            Slog.wtf(SYSTEM_SERVER_TIMING_TAG,</span><br><span class="line">                    <span class="string">"SystemServer init took too long. uptimeMillis="</span> + uptimeMillis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// M: BOOTPROF</span></span><br><span class="line">    addBootEvent(<span class="string">"Android:SysServerInit_END"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终的实现实在run方法里面,接下来分块分析run方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">    Slog.w(TAG, <span class="string">"System clock is before 1970; setting to 1970."</span>);</span><br><span class="line">    SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了判断系统时钟是否早于1970/01/01/00:00,如果早于这个时间,系统后面的处理可能会出问题,所以如果早于该时间,统一设置为1970/01/01/00:00<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String timezoneProperty =  SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line"><span class="keyword">if</span> (timezoneProperty == <span class="keyword">null</span> || timezoneProperty.isEmpty()) &#123;</span><br><span class="line">    Slog.w(TAG, <span class="string">"Timezone not set; setting to GMT."</span>);</span><br><span class="line">    SystemProperties.set(<span class="string">"persist.sys.timezone"</span>, <span class="string">"GMT"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有设置时区,统一设置为GMT<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!SystemProperties.get(<span class="string">"persist.sys.language"</span>).isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">final</span> String languageTag = Locale.getDefault().toLanguageTag();</span><br><span class="line"></span><br><span class="line">    SystemProperties.set(<span class="string">"persist.sys.locale"</span>, languageTag);</span><br><span class="line">    SystemProperties.set(<span class="string">"persist.sys.language"</span>, <span class="string">""</span>);</span><br><span class="line">    SystemProperties.set(<span class="string">"persist.sys.country"</span>, <span class="string">""</span>);</span><br><span class="line">    SystemProperties.set(<span class="string">"persist.sys.localevar"</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置系统语言环境;<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Here we go!</span></span><br><span class="line">Slog.i(TAG, <span class="string">"Entered the Android system server!"</span>);</span><br><span class="line"><span class="keyword">int</span> uptimeMillis = (<span class="keyword">int</span>) SystemClock.elapsedRealtime();</span><br><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, uptimeMillis);</span><br><span class="line"><span class="keyword">if</span> (!mRuntimeRestart) &#123;</span><br><span class="line">    MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_system_server_init"</span>, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// M: BOOTPROF</span></span><br><span class="line">addBootEvent(<span class="string">"Android:SysServerInit_START"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// In case the runtime switched since last boot (such as when</span></span><br><span class="line"><span class="comment">// the old runtime was removed in an OTA), set the system</span></span><br><span class="line"><span class="comment">// property so that it is in sync. We can | xq oqi't do this in</span></span><br><span class="line"><span class="comment">// libnativehelper's JniInvocation::Init code where we already</span></span><br><span class="line"><span class="comment">// had to fallback to a different runtime because it is</span></span><br><span class="line"><span class="comment">// running as root and we need to be the system user to set</span></span><br><span class="line"><span class="comment">// the property. http://b/11463182</span></span><br><span class="line">SystemProperties.set(<span class="string">"persist.sys.dalvik.vm.lib.2"</span>, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable the sampling profiler.</span></span><br><span class="line"><span class="keyword">if</span> (SamplingProfilerIntegration.isEnabled()) &#123;</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line">    mProfilerSnapshotTimer = <span class="keyword">new</span> Timer();</span><br><span class="line">    mProfilerSnapshotTimer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                SamplingProfilerIntegration.writeSnapshot(<span class="string">"system_server"</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mmmmmm... more memory!</span></span><br><span class="line">VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// The system server has to run all of the time, so it needs to be</span></span><br><span class="line"><span class="comment">// as efficient as possible with its memory usage.</span></span><br><span class="line">VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.8f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some devices rely on runtime fingerprint generation, so make sure</span></span><br><span class="line"><span class="comment">// we've defined it before booting further.</span></span><br><span class="line">Build.ensureFingerprintProperty();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Within the system server, it is an error to access Environment paths without</span></span><br><span class="line"><span class="comment">// explicitly specifying a user.</span></span><br><span class="line">Environment.setUserRequired(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Within the system server, any incoming Bundles should be defused</span></span><br><span class="line"><span class="comment">// to avoid throwing BadParcelableException.</span></span><br><span class="line">BaseBundle.setShouldDefuse(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure binder calls into the system always run at foreground priority.</span></span><br><span class="line">BinderInternal.disableBackgroundScheduling(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Increase the number of binder threads in system_server</span></span><br><span class="line">BinderInternal.setMaxThreads(sMaxBinderThreads);</span><br></pre></td></tr></table></figure></p>
<p>这段代码的主要作用是设置虚拟机(VMRuntime)运行内存,相关的操作,(没有细致的研究过).<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prepare the main looper thread (this thread).</span></span><br><span class="line">android.os.Process.setThreadPriority(</span><br><span class="line">    android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line">Looper.prepareMainLooper();</span><br></pre></td></tr></table></figure></p>
<p>创建消息循环,和ActivityThread.java里的main()函数里建立异步消息循环一样.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize native services.</span></span><br><span class="line">System.loadLibrary(<span class="string">"android_servers"</span>);</span><br></pre></td></tr></table></figure></p>
<p>加载了libandroid_servers.so文件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check whether we failed to shut down last time we tried.</span></span><br><span class="line"><span class="comment">// This call may not return.</span></span><br><span class="line">performPendingShutdown();</span><br></pre></td></tr></table></figure></p>
<hr>
<p>performPendingShutdown()函数代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPendingShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String shutdownAction = SystemProperties.get(</span><br><span class="line">            ShutdownThread.SHUTDOWN_ACTION_PROPERTY, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (shutdownAction != <span class="keyword">null</span> &amp;&amp; shutdownAction.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> reboot = (shutdownAction.charAt(<span class="number">0</span>) == <span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String reason;</span><br><span class="line">        <span class="keyword">if</span> (shutdownAction.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            reason = shutdownAction.substring(<span class="number">1</span>, shutdownAction.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reason = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If it's a pending reboot into recovery to apply an update,</span></span><br><span class="line">        <span class="comment">// always make sure uncrypt gets executed properly when needed.</span></span><br><span class="line">        <span class="comment">// If '/cache/recovery/block.map' hasn't been created, stop the</span></span><br><span class="line">        <span class="comment">// reboot which will fail for sure, and get a chance to capture a</span></span><br><span class="line">        <span class="comment">// bugreport when that's still feasible. (Bug: 26444951)</span></span><br><span class="line">        <span class="keyword">if</span> (reason != <span class="keyword">null</span> &amp;&amp; reason.startsWith(PowerManager.REBOOT_RECOVERY_UPDATE)) &#123;</span><br><span class="line">            File packageFile = <span class="keyword">new</span> File(UNCRYPT_PACKAGE_FILE);</span><br><span class="line">            <span class="keyword">if</span> (packageFile.exists()) &#123;</span><br><span class="line">                String filename = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    filename = FileUtils.readTextFile(packageFile, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    Slog.e(TAG, <span class="string">"Error reading uncrypt package file"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (filename != <span class="keyword">null</span> &amp;&amp; filename.startsWith(<span class="string">"/data"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">new</span> File(BLOCK_MAP_FILE).exists()) &#123;</span><br><span class="line">                        Slog.e(TAG, <span class="string">"Can't find block map file, uncrypt failed or "</span> +</span><br><span class="line">                                   <span class="string">"unexpected runtime restart?"</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ShutdownThread.rebootOrShutdown(<span class="keyword">null</span>, reboot, reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>依据注释,和代码名,最近一次关机操作(启动SystemServer是在开机过程中),是非正常状态,该代码将shutdown操作悬挂.(想要明白此处还要明白android的关机流程,还要努力!!!).</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize the system context.</span></span><br><span class="line">createSystemContext();</span><br></pre></td></tr></table></figure>
<hr>
<p>看看createSystemContext()做了什么<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createSystemContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ActivityThread activityThread = ActivityThread.systemMain();</span><br><span class="line">    mSystemContext = activityThread.getSystemContext();</span><br><span class="line">    mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Context systemUiContext = activityThread.getSystemUiContext();</span><br><span class="line">    systemUiContext.setTheme(DEFAULT_SYSTEM_THEME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里还是通过ActivityThread.java来操作,和启动一个应用进程类似,只不过应用进程是使用ActivityThread.java-&gt;main(),这里是使用ActivityThread.java-&gt;systemMain();这两者一定有区别,因为普通进程是要attach到AMS的,这里AMS还没有出生…可以对比ActivityThread.java里面的代码进行分析,对比.为了不偏离主线,这里就不深入分析了.接着往下看:</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the system service manager.</span></span><br><span class="line">mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);</span><br><span class="line">LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"><span class="comment">// Prepare the thread pool for init tasks that can be parallelized</span></span><br><span class="line">SystemServerInitThreadPool.get();</span><br></pre></td></tr></table></figure>
<p>启动AMS\PMS\WMS等等这些系统级的服务前,要把管理他们的服务SystemServiceManager启动起来吧,老铁,这没有问题吧~~~<code>LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</code>将SystemServiceManager对象保存SystemServer进程中的一个数据结构中.<code>SystemServerInitThreadPool.get();</code>初始化线程池,为了初始化任务能够并行处理.这些启动系统级服务的准备工作都做好了,是不是该启动服务了:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Start services.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartServices"</span>);</span><br><span class="line">    startBootstrapServices();</span><br><span class="line">    startCoreServices();</span><br><span class="line">    startOtherServices();</span><br><span class="line">    SystemServerInitThreadPool.shutdown();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    Slog.e(<span class="string">"System"</span>, <span class="string">"******************************************"</span>);</span><br><span class="line">    Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting system services"</span>, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    traceEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>终于到启动这些重量级的系统级的服务了,通过<code>startBootstrapServices()</code>主要用于启动系统Boot级服务 ,<code>startCoreServices()</code>主要用于启动系统核心的服务,<code>startOtherServices()</code>主要用于启动一些非紧要或者是非需要及时启动的服务.启动完成之后使用SystemServerInitThreadPool.shutdown()讲线程池关闭.接着我们注意分析<code>startBootstrapServices()</code>,<code>startCoreServices()</code>,<code>startOtherServices()</code>这三个函数.<br>首先看<code>startBootstrapServices()</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Starts the small tangle of critical services that are needed to get</span></span><br><span class="line"><span class="comment"> * the system off the ground.  These services have complex mutual dependencies</span></span><br><span class="line"><span class="comment"> * which is why we initialize them all in one place here.  Unless your service</span></span><br><span class="line"><span class="comment"> * is also entwined in these dependencies, it should be initialized in one of</span></span><br><span class="line"><span class="comment"> * the other functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">   Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line">    traceEnd();</span><br><span class="line">   ......</span><br><span class="line">    <span class="comment">// In some cases after launching an app we need to access device identifiers,</span></span><br><span class="line">    <span class="comment">// therefore register the device identifier policy before the activity manager.</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"DeviceIdentifiersPolicyService"</span>);</span><br><span class="line">    mSystemServiceManager.startService(DeviceIdentifiersPolicyService.class);</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Activity manager runs the show.</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartActivityManager"</span>);</span><br><span class="line">    mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Power manager needs to be started early because other services need it.</span></span><br><span class="line">    <span class="comment">// Native daemons may be watching for it to be registered so it must be ready</span></span><br><span class="line">    <span class="comment">// to handle incoming binder calls immediately (including being able to verify</span></span><br><span class="line">    <span class="comment">// the permissions for those calls).</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartPowerManager"</span>);</span><br><span class="line">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that the power manager has been started, let the activity manager</span></span><br><span class="line">    <span class="comment">// initialize power management features.</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"InitPowerManagement"</span>);</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bring up recovery system in case a rescue party needs a reboot</span></span><br><span class="line">    <span class="keyword">if</span> (!SystemProperties.getBoolean(<span class="string">"config.disable_noncore"</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        traceBeginAndSlog(<span class="string">"StartRecoverySystemService"</span>);</span><br><span class="line">        mSystemServiceManager.startService(RecoverySystemService.class);</span><br><span class="line">        traceEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we have the bare essentials of the OS up and running, take</span></span><br><span class="line">    <span class="comment">// note that we just booted, which might send out a rescue party if</span></span><br><span class="line">    <span class="comment">// we're stuck in a runtime restart loop.</span></span><br><span class="line">    RescueParty.noteBoot(mSystemContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Manages LEDs and display backlight so we need it to bring up the display.</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartLightsService"</span>);</span><br><span class="line">    mSystemServiceManager.startService(LightsService.class);</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display manager is needed to provide display metrics before package manager</span></span><br><span class="line">    <span class="comment">// starts up.</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartDisplayManager"</span>);</span><br><span class="line">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the default display before we can initialize the package manager.</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"WaitForDisplay"</span>);</span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only run "core" apps if we're encrypting the device.</span></span><br><span class="line">    String cryptState = SystemProperties.get(<span class="string">"vold.decrypt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Detected encryption in progress - only parsing core apps"</span>);</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Device encrypted - only parsing core apps"</span>);</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the package manager.</span></span><br><span class="line">    <span class="keyword">if</span> (!mRuntimeRestart) &#123;</span><br><span class="line">        MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_package_manager_init_start"</span>,</span><br><span class="line">                (<span class="keyword">int</span>) SystemClock.elapsedRealtime());</span><br><span class="line">    &#125;</span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartPackageManagerService"</span>);</span><br><span class="line">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line">    traceEnd();</span><br><span class="line">    <span class="keyword">if</span> (!mRuntimeRestart &amp;&amp; !isFirstBootOrUpgrade()) &#123;</span><br><span class="line">        MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_package_manager_init_ready"</span>,</span><br><span class="line">                (<span class="keyword">int</span>) SystemClock.elapsedRealtime());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Manages A/B OTA dexopting. This is a bootstrap service as we need it to rename</span></span><br><span class="line">    <span class="comment">// A/B artifacts after boot, before anything else might touch/need them.</span></span><br><span class="line">    <span class="comment">// Note: this isn't needed during decryption (we don't have /data anyways).</span></span><br><span class="line">    <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> disableOtaDexopt = SystemProperties.getBoolean(<span class="string">"config.disable_otadexopt"</span>,</span><br><span class="line">                <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!disableOtaDexopt) &#123;</span><br><span class="line">            traceBeginAndSlog(<span class="string">"StartOtaDexOptService"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                OtaDexoptService.main(mSystemContext, mPackageManagerService);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                reportWtf(<span class="string">"starting OtaDexOptService"</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                traceEnd();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartUserManagerService"</span>);</span><br><span class="line">    mSystemServiceManager.startService(UserManagerService.LifeCycle.class);</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize attribute cache used to cache resources from packages.</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"InitAttributerCache"</span>);</span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the Application instance for the system process and get started.</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"SetSystemProcess"</span>);</span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DisplayManagerService needs to setup android.display scheduling related policies</span></span><br><span class="line">    <span class="comment">// since setSystemProcess() would have overridden policies due to setProcessGroup</span></span><br><span class="line">    mDisplayManagerService.setupSchedulerPolicies();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// M: CTA requirement - permission control  @&#123;</span></span><br><span class="line">    <span class="comment">/// M: MOTA for CTA permissions handling</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This function is used for granting CTA permissions after OTA upgrade.</span></span><br><span class="line"><span class="comment">     * This should be placed after AMS is added to ServiceManager and before</span></span><br><span class="line"><span class="comment">     * starting other services since granting permissions needs AMS instance</span></span><br><span class="line"><span class="comment">     * to do permission checking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mPackageManagerService.onAmsAddedtoServiceMgr();</span><br><span class="line">    <span class="comment">/// @&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Manages Overlay packages</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartOverlayManagerService"</span>);</span><br><span class="line">    mSystemServiceManager.startService(<span class="keyword">new</span> OverlayManagerService(mSystemContext, installer));</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The sensor service needs access to package manager service, app ops</span></span><br><span class="line">    <span class="comment">// service, and permissions service, therefore we start it after them.</span></span><br><span class="line">    <span class="comment">// Start sensor service in a separate thread. Completion should be checked</span></span><br><span class="line">    <span class="comment">// before using it.</span></span><br><span class="line">    mSensorServiceStart = SystemServerInitThreadPool.get().submit(() -&gt; &#123;</span><br><span class="line">        BootTimingsTraceLog traceLog = <span class="keyword">new</span> BootTimingsTraceLog(</span><br><span class="line">                SYSTEM_SERVER_TIMING_ASYNC_TAG, Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">        traceLog.traceBegin(START_SENSOR_SERVICE);</span><br><span class="line">        startSensorService();</span><br><span class="line">        traceLog.traceEnd();</span><br><span class="line">    &#125;, START_SENSOR_SERVICE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先分析<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Installer installer = mSystemServiceManager.startService(Installer.class);</span><br></pre></td></tr></table></figure></p>
<p>mSystemServiceManager是系统服务管理对象,在前面介绍的run()里面已经实例化了.这里简单介绍一下Installer类，该类是系统安装apk时的一个服务类，继承SystemService（系统服务的一个抽象接口），我们需要在启动完成Installer服务之后才能启动其他的系统服务.接着可以看到ActivityManagerService,PowerManagerService,RecoverySystemService,LightsService,DisplayManagerService,UserManagerService这些服务都是使用mSystemServiceManager.startService()方法将服务启动起来.<br>发现PackageManagerService服务和其他的有点不一样,他是直接调用了静态方法main()方法实现了<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Start the package manager.</span></span><br><span class="line"><span class="keyword">if</span> (!mRuntimeRestart) &#123;</span><br><span class="line">    MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_package_manager_init_start"</span>,</span><br><span class="line">            (<span class="keyword">int</span>) SystemClock.elapsedRealtime());</span><br><span class="line">&#125;</span><br><span class="line">traceBeginAndSlog(<span class="string">"StartPackageManagerService"</span>);</span><br><span class="line">mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">        mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line"><span class="comment">//mFirstBoot是判断是否第一次开机的标示,isFirstBoot()是对应的方法,原理就是判断packages.xml是否存在</span></span><br><span class="line">mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line">traceEnd();</span><br><span class="line"><span class="keyword">if</span> (!mRuntimeRestart &amp;&amp; !isFirstBootOrUpgrade()) &#123;</span><br><span class="line">    MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_package_manager_init_ready"</span>,</span><br><span class="line">            (<span class="keyword">int</span>) SystemClock.elapsedRealtime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析main()函数:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PackageManagerService <span class="title">main</span><span class="params">(Context context, Installer installer,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Self-check for initial settings.</span></span><br><span class="line">    PackageManagerServiceCompilerMapping.checkProperties();</span><br><span class="line"></span><br><span class="line">    PackageManagerService m = <span class="keyword">new</span> PackageManagerService(context, installer,</span><br><span class="line">            factoryTest, onlyCore);</span><br><span class="line">    m.enableSystemUserPackages();</span><br><span class="line">    ServiceManager.addService(<span class="string">"package"</span>, m);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里是直接newPackageManagerService,然后调用ServiceManager.addService,通过了binder(以后再仔细研究).<br>这里有一段涉及vold服务的:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Only run "core" apps if we're encrypting the device.</span></span><br><span class="line">String cryptState = SystemProperties.get(<span class="string">"vold.decrypt"</span>);</span><br><span class="line"><span class="keyword">if</span> (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">    Slog.w(TAG, <span class="string">"Detected encryption in progress - only parsing core apps"</span>);</span><br><span class="line">    mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">    Slog.w(TAG, <span class="string">"Device encrypted - only parsing core apps"</span>);</span><br><span class="line">    mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>android 4.0新增的一个功能，即设备加密（encrypting the device）,该功能由系统属性vold.decrypt指定.涉及设备安全和加密的,vold(Volume Daemon)用于管理和控制Android平台外部存储设备的后台进程，这些管理和控制，包括SD卡的插拔事件检测、SD卡挂载、卸载、格式化等。这里的设置是当我们的设备处于加密状态,只启动核心服务,通过设置mOnlyCore来进行标示.<br>接着分析startCoreServices()函数:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Starts some essential services that are not tangled up in the bootstrap process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCoreServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Records errors and logs, for example wtf()</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartDropBoxManager"</span>);</span><br><span class="line">    mSystemServiceManager.startService(DropBoxManagerService.class);</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartBatteryService"</span>);</span><br><span class="line">    <span class="comment">// Tracks the battery level.  Requires LightService.</span></span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line">    traceEnd();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tracks application usage stats.</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartUsageService"</span>);</span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line">    traceEnd();</span><br><span class="line">    <span class="comment">// Tracks whether the updatable WebView is in a ready state and watches for update installs.</span></span><br><span class="line">    traceBeginAndSlog(<span class="string">"StartWebViewUpdateService"</span>);</span><br><span class="line">    mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">    traceEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动了DropBoxManagerService(系统出问题的调用栈信息),BatteryService(电池相关的服务),UsageStatsService,WebViewUpdateService.<br>startOtherServices方法，主要用于启动系统中其他的服务,包括Luncher的启动  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>SystemServer进程是android中一个很重要的进程由Zygote进程启动,是Zygote的嫡长子,如果该进程崩溃,Zygote会调用方法kill掉自己；</li>
<li>SystemServer进程主要用于启动系统中的服务；</li>
<li>SystemServer进程启动服务的启动函数为main函数,其实真正干活的还是在run()方法里面；</li>
<li>SystemServer在执行过程中首先会初始化一些系统变量，加载类库，创建Context对象，创建SystemServiceManager对象等之后才开始启动系统服务；</li>
<li>SystemServer进程将系统服务分为三类：boot服务，core服务和other服务，并逐步启动;</li>
<li>SertemServer进程在尝试启动服务之前会首先尝试与Zygote建立socket通讯，只有通讯成功之后才会开始尝试启动服务；</li>
<li>创建的系统服务过程中主要通过SystemServiceManager对象来管理，通过调用服务对象的构造方法和onStart方法初始化服务的相关变量；</li>
<li>服务对象都有自己的异步消息对象，并运行在单独的线程中；</li>
</ul>
<p>参考文章:<br><a href="http://blog.csdn.net/qq_23547831/article/details/51105171" target="_blank" rel="noopener">http://blog.csdn.net/qq_23547831/article/details/51105171</a>  </p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Michael</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lqktz.github.io/2019/04/10/Android-SystemServer/">https://lqktz.github.io/2019/04/10/Android-SystemServer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lqktz.github.io">Michael Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/10/zygote启动/"><i class="fa fa-chevron-left">  </i><span>Zygote进程启动过程</span></a></div><div class="next-post pull-right"><a href="/2019/04/10/App_Standby_Bucket/"><span>Android P 应用分组介绍</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Michael</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to Michael <a href="http://lqktz.github.io/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>