<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="init启动分析"><meta name="keywords" content="Android"><meta name="author" content="Michael"><meta name="copyright" content="Michael"><title>init启动分析 | Michael Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://avatars2.githubusercontent.com/u/15813289?s=460&amp;v=4"></div><div class="author-info__name text-center">Michael</div><div class="author-info__description text-center">Android性能优化</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Michael Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">目录</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">分类</a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">init启动分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/"> Android</a></div><div class="article-container" id="post-content"><p><strong>Android N平台</strong></p>
<hr>
<p>涉及源码位置:<br>aosp/system/core/init/init.cpp<br>aosp/system/core/rootdir/init.rc<br>aosp/system/core/init/property_service.cpp  </p>
<hr>
<h3 id="0-init进程的主要职责"><a href="#0-init进程的主要职责" class="headerlink" title="0 init进程的主要职责"></a>0 init进程的主要职责</h3><ul>
<li>init如何创建zygote。  </li>
<li>init的属性服务是如何工作的。  <a id="more"></a>
</li>
</ul>
<h3 id="1-init-cpp分析"><a href="#1-init-cpp分析" class="headerlink" title="1 init.cpp分析"></a>1 init.cpp分析</h3><h4 id="1-1从init进程的入口函数main-开始分析"><a href="#1-1从init进程的入口函数main-开始分析" class="headerlink" title="1.1从init进程的入口函数main()开始分析"></a>1.1从init进程的入口函数main()开始分析</h4><p>init进程的main()函数会执行两次,分别是第一阶段和第二阶段,main函数会进入两次,只是两次进去执行的代码不一样<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于ueventd watchdogd是公用代码，所以启动的时候根据文件名来判断是哪个进程</span></span><br><span class="line">    <span class="comment">//和ueventd守护进程相关</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"ueventd"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//和watchdogd守护进程相关</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"watchdogd"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> watchdogd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the umask.</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//添加环境变量 </span></span><br><span class="line">    add_environment(<span class="string">"PATH"</span>, _PATH_DEFPATH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> is_first_stage = (argc == <span class="number">1</span>) || (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--second-stage"</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//创建文件夹，挂载设备,和linux相关</span></span><br><span class="line">    <span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line">    <span class="comment">// on / and then we'll let the rc file figure out the rest.</span></span><br><span class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">        mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>);</span><br><span class="line">        mkdir(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>);</span><br><span class="line">        mkdir(<span class="string">"/dev/socket"</span>, <span class="number">0755</span>);</span><br><span class="line">        mount(<span class="string">"devpts"</span>, <span class="string">"/dev/pts"</span>, <span class="string">"devpts"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">        mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="string">"hidepid=2,gid="</span> MAKE_STR(AID_READPROC));</span><br><span class="line">        mount(<span class="string">"sysfs"</span>, <span class="string">"/sys"</span>, <span class="string">"sysfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We must have some place other than / to create the device nodes for</span></span><br><span class="line">    <span class="comment">// kmsg and null, otherwise we won't be able to remount / read-only</span></span><br><span class="line">    <span class="comment">// later on. Now that tmpfs is mounted on /dev, we can actually talk</span></span><br><span class="line">    <span class="comment">// to the outside world.</span></span><br><span class="line">    <span class="comment">//重定向标准输入/输出/错误输出到/dev/_null_　</span></span><br><span class="line">    open_devnull_stdio();</span><br><span class="line">    <span class="comment">//对klog进行初始化，设置klog level为NOTICE，所以可以将NOTICE级别的log输出，而INFO级别的log就打印不出来</span></span><br><span class="line">    <span class="comment">//&lt;http://blog.csdn.net/fu_kevin0606/article/details/53339001&gt;</span></span><br><span class="line">    <span class="comment">//初始化klog</span></span><br><span class="line">    klog_init();</span><br><span class="line">    <span class="comment">//设置klog的级别为NOTICE</span></span><br><span class="line">    klog_set_level(KLOG_NOTICE_LEVEL);</span><br><span class="line"></span><br><span class="line">    NOTICE(<span class="string">"init %s started!\n"</span>, is_first_stage ? <span class="string">"first stage"</span> : <span class="string">"second stage"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!is_first_stage) &#123;<span class="comment">//第二阶段执行该代码</span></span><br><span class="line">        <span class="comment">// Indicate that booting is in progress to background fw loaders, etc.</span></span><br><span class="line">        close(open(<span class="string">"/dev/.booting"</span>, O_WRONLY | O_CREAT | O_CLOEXEC, <span class="number">0000</span>));</span><br><span class="line">        <span class="comment">//属性服务初始化，接下来会分析</span></span><br><span class="line">        property_init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If arguments are passed both on the command line and in DT,</span></span><br><span class="line">        <span class="comment">// properties set in DT always have priority over the command-line ones.</span></span><br><span class="line">        process_kernel_dt();</span><br><span class="line">        process_kernel_cmdline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate the kernel variables to internal variables</span></span><br><span class="line">        <span class="comment">// used by init as well as the current required properties.</span></span><br><span class="line">        export_kernel_boot_props();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化SELinux，加载策略文件</span></span><br><span class="line">    <span class="comment">// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.</span></span><br><span class="line">    selinux_initialize(is_first_stage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're in the kernel domain, re-exec init to transition to the init domain now</span></span><br><span class="line">    <span class="comment">// that the SELinux policy has been loaded.</span></span><br><span class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">        <span class="keyword">if</span> (restorecon(<span class="string">"/init"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"restorecon failed: %s\n"</span>, strerror(errno));</span><br><span class="line">            security_failure();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>* path = argv[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//设置第二阶段的参数</span></span><br><span class="line">        <span class="keyword">char</span>* args[] = &#123; path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">"--second-stage"</span>), <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        <span class="comment">//当init是第一阶段,要通过execv重启init进程,进入init的第二阶段</span></span><br><span class="line">        <span class="keyword">if</span> (execv(path, args) == <span class="number">-1</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"execv(\"%s\") failed: %s\n"</span>, path, strerror(errno));</span><br><span class="line">            security_failure();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These directories were necessarily created before initial policy load</span></span><br><span class="line">    <span class="comment">// and therefore need their security context restored to the proper value.</span></span><br><span class="line">    <span class="comment">// This must happen before /dev is populated by ueventd.</span></span><br><span class="line">    NOTICE(<span class="string">"Running restorecon...\n"</span>);</span><br><span class="line">    restorecon(<span class="string">"/dev"</span>);</span><br><span class="line">    restorecon(<span class="string">"/dev/socket"</span>);</span><br><span class="line">    restorecon(<span class="string">"/dev/__properties__"</span>);</span><br><span class="line">    restorecon(<span class="string">"/property_contexts"</span>);</span><br><span class="line">    restorecon_recursive(<span class="string">"/sys"</span>);</span><br><span class="line"></span><br><span class="line">    epoll_fd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"epoll_create1 failed: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal_handler_init();</span><br><span class="line"></span><br><span class="line">    property_load_boot_defaults();</span><br><span class="line">    export_oem_lock_status();</span><br><span class="line">    <span class="comment">//启动属性服务</span></span><br><span class="line">    start_property_service();</span><br><span class="line">    <span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line">    <span class="comment">//将`service`,`on`,`import`分为３个section</span></span><br><span class="line">    Parser&amp; parser = Parser::GetInstance();</span><br><span class="line">    parser.AddSectionParser(<span class="string">"service"</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">    parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</span><br><span class="line">    parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</span><br><span class="line">    <span class="comment">//解析init.rc配置文件入口</span></span><br><span class="line">    parser.ParseConfig(<span class="string">"/init.rc"</span>);</span><br><span class="line"></span><br><span class="line">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line"></span><br><span class="line">    am.QueueEventTrigger(<span class="string">"early-init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class="string">"wait_for_coldboot_done"</span>);</span><br><span class="line">    <span class="comment">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class="line">    am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line">    am.QueueBuiltinAction(set_mmap_rnd_bits_action, <span class="string">"set_mmap_rnd_bits"</span>);</span><br><span class="line">    am.QueueBuiltinAction(keychord_init_action, <span class="string">"keychord_init"</span>);</span><br><span class="line">    am.QueueBuiltinAction(console_init_action, <span class="string">"console_init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">    am.QueueEventTrigger(<span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class="line">    <span class="comment">// wasn't ready immediately after wait_for_coldboot_done</span></span><br><span class="line">    am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't mount filesystems or start core system services in charger mode.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootmode = property_get(<span class="string">"ro.bootmode"</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootmode == <span class="string">"charger"</span>) &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">"charger"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">"late-init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run all property triggers based on current state of the properties.</span></span><br><span class="line">    am.QueueBuiltinAction(queue_property_triggers_action, <span class="string">"queue_property_triggers"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!waiting_for_exec) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">            restart_processes();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> timeout = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (process_needs_restart) &#123;</span><br><span class="line">            timeout = (process_needs_restart - gettime()) * <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">                timeout = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (am.HasMoreCommands()) &#123;</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bootchart_sample(&amp;timeout);</span><br><span class="line"></span><br><span class="line">        epoll_event ev;</span><br><span class="line">        <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, timeout));</span><br><span class="line">        <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"epoll_wait failed: %s\n"</span>, strerror(errno));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</span><br><span class="line">            ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main函数里涉及不少东西,只是把当前知道的注释了一下,以后补充,这里关注一下,属性服务的启动,以及对init.rc文件的解析.  </p>
<h4 id="1-2-属性服务"><a href="#1-2-属性服务" class="headerlink" title="1.2 属性服务"></a>1.2 属性服务</h4><p>Android中有很多属性,是通过属性服务(property service)来管理它们的.接着来分析属性服务的代码,从上面的init.cpp的main函数中涉及属性服务的代码有<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">property_init();</span><br><span class="line">start_property_service();</span><br></pre></td></tr></table></figure></p>
<p>从property_init()开始分析,该方法的主要工作是初始化属性服务配置.位置在<code>aosp/system/core/init/property_service.cpp</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">property_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property_area_initialized) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_area_initialized = <span class="literal">true</span>;</span><br><span class="line">   <span class="comment">//__system_property_area_init()函数是用来初始化属性内存区域</span></span><br><span class="line">    <span class="keyword">if</span> (__system_property_area_init()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pa_workspace.size = <span class="number">0</span>;</span><br><span class="line">    pa_workspace.fd = open(PROP_FILENAME, O_RDONLY | O_NOFOLLOW | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (pa_workspace.fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"Failed to open %s: %s\n"</span>, PROP_FILENAME, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来查看start_property_service函数的具体代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_property_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个非阻塞的socket,</span></span><br><span class="line">    property_set_fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,</span><br><span class="line">                                    <span class="number">0666</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (property_set_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"start_property_service socket creation failed: %s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用listen函数对之前创建的socket进行监听</span></span><br><span class="line">    listen(property_set_fd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    register_epoll_handler(property_set_fd, handle_property_set_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>listen(property_set_fd, 8);</code>中的8指属性服务最多可以同时为8个试图设置属性的用户提供服务.property_set_fd代表监听<br>的端口(socket),这样属性服务就建立了.<code>register_epoll_handler(property_set_fd, handle_property_set_fd)</code>将<code>property_set_fd</code><br>放入了epoll句柄中，用epoll来监听<code>property_set_fd</code>：当<code>property_set_fd</code>中有数据到来时，init进程将用<code>handle_property_set_fd</code><br>函数进行处理。(网上资料说:在linux新的内核中，epoll用来替换select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。<br>因为内核中的select实现是采用轮询来处理的，轮询的fd数目越多，自然耗时越多,epoll还没有研究过,抽时间学习一下).<br>当有<code>property_set_fd</code>这个socket有数据来时,就会产生调用到<code>handle_property_set_fd</code>方法,接着分析该方法:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_property_set_fd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    prop_msg msg;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucred</span> <span class="title">cr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> addr_size = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    <span class="keyword">socklen_t</span> cr_size = <span class="keyword">sizeof</span>(cr);</span><br><span class="line">    <span class="keyword">char</span> * source_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">ufds</span>[1];</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> timeout_ms = <span class="number">2</span> * <span class="number">1000</span>;  <span class="comment">/* Default 2 sec timeout for caller to send property. */</span></span><br><span class="line">    <span class="keyword">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((s = accept(property_set_fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check socket options here */</span></span><br><span class="line">    <span class="keyword">if</span> (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(s);</span><br><span class="line">        ERROR(<span class="string">"Unable to receive socket options\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ufds[<span class="number">0</span>].fd = s；</span><br><span class="line">    ufds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    ufds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">    nr = TEMP_FAILURE_RETRY(poll(ufds, <span class="number">1</span>, timeout_ms));</span><br><span class="line">    <span class="keyword">if</span> (nr == <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"sys_prop: timeout waiting for uid=%d to send property message.\n"</span>, cr.uid);</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"sys_prop: error waiting for uid=%d to send property message: %s\n"</span>, cr.uid, strerror(errno));</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = TEMP_FAILURE_RETRY(recv(s, &amp;msg, <span class="keyword">sizeof</span>(msg), MSG_DONTWAIT));</span><br><span class="line">    <span class="keyword">if</span>(r != <span class="keyword">sizeof</span>(prop_msg)) &#123;</span><br><span class="line">        ERROR(<span class="string">"sys_prop: mis-match msg size received: %d expected: %zu: %s\n"</span>,</span><br><span class="line">              r, <span class="keyword">sizeof</span>(prop_msg), strerror(errno));</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(msg.cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> PROP_MSG_SETPROP:</span><br><span class="line">        msg.name[PROP_NAME_MAX<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        msg.value[PROP_VALUE_MAX<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!is_legal_property_name(msg.name, <span class="built_in">strlen</span>(msg.name))) &#123;</span><br><span class="line">            ERROR(<span class="string">"sys_prop: illegal property name. Got: \"%s\"\n"</span>, msg.name);</span><br><span class="line">            close(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getpeercon(s, &amp;source_ctx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(msg.name,<span class="string">"ctl."</span>,<span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Keep the old close-socket-early behavior when handling</span></span><br><span class="line">            <span class="comment">// ctl.* properties.</span></span><br><span class="line">            close(s);</span><br><span class="line">            <span class="keyword">if</span> (check_control_mac_perms(msg.value, source_ctx)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MTK_INIT</span></span><br><span class="line">                <span class="comment">//INFO("[PropSet]: pid:%u uid:%u gid:%u %s %s\n", cr.pid, cr.uid, cr.gid, msg.name, msg.value);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                handle_control_message((<span class="keyword">char</span>*) msg.name + <span class="number">4</span>, (<span class="keyword">char</span>*) msg.value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ERROR(<span class="string">"sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\n"</span>,</span><br><span class="line">                        msg.name + <span class="number">4</span>, msg.value, cr.uid, cr.gid, cr.pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//check_perms:检测设置系统属性的权限,允许返回1,否则返回0</span></span><br><span class="line">            <span class="keyword">if</span> (check_perms(msg.name, source_ctx)) &#123;</span><br><span class="line">#ifdef MTK_INIT</span><br><span class="line">                <span class="comment">//INFO("[PropSet]: pid:%u uid:%u gid:%u set %s=%s\n", cr.pid, cr.uid, cr.gid, msg.name, msg.value);</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(msg.name, ANDROID_RB_PROPERTY) == <span class="number">0</span>) &#123;</span><br><span class="line">                    INFO(<span class="string">"pid %d set %s=%s\n"</span>, cr.pid, msg.name, msg.value);</span><br><span class="line">                    reboot_pid(cr.pid);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="comment">//设置系统属性</span></span><br><span class="line">                property_set((<span class="keyword">char</span>*) msg.name, (<span class="keyword">char</span>*) msg.value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ERROR(<span class="string">"sys_prop: permission denied uid:%d  name:%s\n"</span>,</span><br><span class="line">                      cr.uid, msg.name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Note: bionic's property client code assumes that the</span></span><br><span class="line">            <span class="comment">// property server will not close the socket until *AFTER*</span></span><br><span class="line">            <span class="comment">// the property is written to memory.</span></span><br><span class="line">            close(s);</span><br><span class="line">        &#125;</span><br><span class="line">        freecon(source_ctx);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着看<code>property_set((char*) msg.name, (char*) msg.value)</code>的具体实现:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">property_set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = property_set_impl(name, value);</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"property_set(\"%s\", \"%s\") failed\n"</span>, name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看来实现设置的活交给了<code>property_set_impl(name, value)</code>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">property_set_impl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> namelen = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="keyword">size_t</span> valuelen = <span class="built_in">strlen</span>(value);</span><br><span class="line">    <span class="comment">//判断属性名的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (!is_legal_property_name(name, namelen)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (valuelen &gt;= PROP_VALUE_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果属性的名称等于“selinux.reload_policy”，并且前面给它设置的值等于1，那么就表示要重新加载SEAndroid策略</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"selinux.reload_policy"</span>, name) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">"1"</span>, value) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//加载SEAndroid策略</span></span><br><span class="line">        <span class="keyword">if</span> (selinux_reload_policy() != <span class="number">0</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"Failed to reload policy\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"selinux.restorecon_recursive"</span>, name) == <span class="number">0</span> &amp;&amp; valuelen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (restorecon_recursive(value) != <span class="number">0</span>) &#123;</span><br><span class="line">            ERROR(<span class="string">"Failed to restorecon_recursive %s\n"</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找名称为name的属性，如果存在的话，那么就会得到一个类型为prop_info的结构体pi，否则返回Null</span></span><br><span class="line">    prop_info* pi = (prop_info*) __system_property_find(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pi != <span class="number">0</span>) &#123;<span class="comment">//属性如果存在</span></span><br><span class="line">        <span class="comment">/* ro.* properties may NEVER be modified once set */</span></span><br><span class="line">        <span class="comment">//如果属性是ro.开头，不能修改，直接返回．</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(name, <span class="string">"ro."</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">　　　　<span class="comment">//属性可以修改，进行修改</span></span><br><span class="line">        __system_property_update(pi, value, valuelen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//属性不存在</span></span><br><span class="line">        <span class="comment">//属性不存在，添加该属性，在属性内存区域的属性值列表pa_info_array的最后增加一项</span></span><br><span class="line">        <span class="keyword">int</span> rc = __system_property_add(name, namelen, value, valuelen);</span><br><span class="line">        <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If name starts with "net." treat as a DNS property. */</span></span><br><span class="line">    <span class="comment">//接着处理net.开头的属性,</span></span><br><span class="line">    <span class="comment">//如果属性的名称是以“net.”开头，但是又不等于“net.change”(net.change是一个特殊的属性，记录网络属性是否发生变化)，那么就将名称为“net.change”的属性设置为name，表示网络属性发生了变化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(<span class="string">"net."</span>, name, <span class="built_in">strlen</span>(<span class="string">"net."</span>)) == <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"net.change"</span>, name) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * The 'net.change' property is a special property used track when any</span></span><br><span class="line"><span class="comment">        * 'net.*' property name is updated. It is _ONLY_ updated here. Its value</span></span><br><span class="line"><span class="comment">        * contains the last updated 'net.*' property.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//设置`net.change`属性</span></span><br><span class="line">        property_set(<span class="string">"net.change"</span>, name);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (persistent_properties_loaded &amp;&amp;</span><br><span class="line">            <span class="built_in">strncmp</span>(<span class="string">"persist."</span>, name, <span class="built_in">strlen</span>(<span class="string">"persist."</span>)) == <span class="number">0</span>) &#123;<span class="comment">//对`persist.`属性进行操作,该属性应该是持久化储存到文件</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Don't write properties to disk until after we have read all default properties</span></span><br><span class="line"><span class="comment">         * to prevent them from being overwritten by default values.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">　　　　<span class="comment">//调用函数write_persistent_property执行持久化操作，以便系统下次启动后，可以将该属性的初始值设置为系统上次关闭时的值</span></span><br><span class="line">        write_persistent_property(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送一个属性改变的通知，以便init进程可以执行在启动脚本init.rc中配置的操作</span></span><br><span class="line">    property_changed(name, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>property_set_impl</code>对以ro、net和persist开头的属性进行不同的处理，给张来自罗升阳blog的一张图，帮助对android属性服务有个整体上的认识(Android属性的实现框架):<br><img src="http://raw.githubusercontent.com/lqktz/document/master/res/init_property.png" alt="Android属性的实现框架"></p>
<h4 id="1-3-读取init-rc文件"><a href="#1-3-读取init-rc文件" class="headerlink" title="1.3 读取init.rc文件"></a>1.3 读取init.rc文件</h4><hr>
<p><strong>init.rc简单介绍</strong><br>init.rc是一个配置文件，内部由Android初始化语言编写（Android Init Language）编写的脚本，它主要包含五种类型语句：<br>Action、Commands、Services、Options和Import．在init.rc文件中一条语句通常占用一行，单词之间是用空格符来相隔的。<br>如果一行写不下，可以在行尾加上反斜杠，来连接下一行。也就是说，可以用反斜杠将多行代码连接成一行代码。并且使用#<br>来进行注释。在init.rc中分成三个部分（Section），而每一部分的开头需要指定on（Actions）、service（Services）或<br>import。也就是说，每一个Actions, import或 Services确定一个Section。而所有的Commands和Options只能属于最近定义的<br>Section。如果Commands和 Options在第一个Section之前被定义，它们将被忽略。Actions和Services的名称必须唯一。如果<br>有两个或多个Actions或Services拥有同样的名称，那么init在执行它们时将抛出错误，并忽略这些Action和Service。<br>完整的init文件比较长，这里重点分析Zygote的启动，后续要分析该进程．<br>下面简单的用init.rc中的例子对Action、Commands、Services、Options和Import进行说明。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> Copyright (C) 2012 The Android Open Source Project</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> IMPORTANT: Do not create world writable files or directories.</span><br><span class="line"><span class="meta">#</span> This is a common source of Android security bugs.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>导入相关的初始化配置文件</span><br><span class="line">import /init.environ.rc</span><br><span class="line">import /init.usb.rc</span><br><span class="line"><span class="meta">#</span>平台相关的如：高通、MTK</span><br><span class="line">import /init.$&#123;ro.hardware&#125;.rc</span><br><span class="line">import /init.usb.configfs.rc</span><br><span class="line"><span class="meta">#</span>导入初始化zygote进程的配置文件</span><br><span class="line">import /init.$&#123;ro.zygote&#125;.rc</span><br><span class="line"><span class="meta">#</span>on 对应action，是启动，early-init市条件 write、mkdir、start是命令（commands）</span><br><span class="line">on early-init</span><br><span class="line">    # Set init and its forked children's oom_adj.</span><br><span class="line">    write /proc/1/oom_score_adj -1000</span><br><span class="line"></span><br><span class="line">    # Disable sysrq from keyboard</span><br><span class="line">    write /proc/sys/kernel/sysrq 0</span><br><span class="line"></span><br><span class="line">    # Set the security context of /adb_keys if present.</span><br><span class="line">    restorecon /adb_keys</span><br><span class="line"></span><br><span class="line">    # Shouldn't be necessary, but sdcard won't start without it. http://b/22568628.</span><br><span class="line">    mkdir /mnt 0775 root system</span><br><span class="line"></span><br><span class="line">    # Set the security context of /postinstall if present.</span><br><span class="line">    restorecon /postinstall</span><br><span class="line"></span><br><span class="line">    start ueventd</span><br><span class="line"><span class="meta">#</span>每一个service对应一个新的进程，ueventd进程名，/sbin/ueventd进程的位置（程序执行的路径）也就是options，后面还可以跟参数，</span><br><span class="line"><span class="meta">#</span>class、critical、seclabel都是命令</span><br><span class="line">service ueventd /sbin/ueventd</span><br><span class="line">    //core 是服务的组，同样名字的会在一起被启动</span><br><span class="line">    class core</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:ueventd:s0</span><br></pre></td></tr></table></figure></p>
<p>对于这些commands在Android源码中有文档说明，在<code>aosp/system/core/init/readme.txt</code>，每个命令都有对于的代码实现，接下来就会分析到.</p>
<hr>
<p>有了对<code>init.rc</code>文件的简单认识，回到<code>init.cpp</code>中，解析<code>init.rc</code>代码的位置，解析<code>init.rc</code>主要任务由<code>aosp/system/core/init/init_parser.cpp</code>实现．<br>开始分析:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Parser&amp; parser = Parser::GetInstance();</span><br><span class="line">parser.AddSectionParser(<span class="string">"service"</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</span><br></pre></td></tr></table></figure></p>
<p><code>Parser::GetInstance()</code>的实现在<code>aosp/system/core/init/init_parser.cpp</code>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Parser&amp; Parser::GetInstance() &#123;</span><br><span class="line">    <span class="keyword">static</span> Parser instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>parser.AddSectionParser</code>同样在<code>aosp/system/core/init/init_parser.cpp</code>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Parser::AddSectionParser(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">                              <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SectionParser&gt; parser) &#123;</span><br><span class="line">    section_parsers_[name] = <span class="built_in">std</span>::move(parser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是将<code>service</code>,<code>on</code>,<code>import</code>设置为了３个Section.<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">parser.ParseConfig(<span class="string">"/init.rc"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这就是解析init.rc函数的入口，在<code>init_parser.cpp</code>里面:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Parser::ParseConfig(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_dir(path.c_str())) &#123;<span class="comment">//路径是文件夹，调用解析文件夹的函数处理</span></span><br><span class="line">        <span class="keyword">return</span> ParseConfigDir(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析init.rc</span></span><br><span class="line">    <span class="keyword">return</span> ParseConfigFile(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用了ParseConfigFile(path):<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Parser::ParseConfigFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path) &#123;</span><br><span class="line">    INFO(<span class="string">"Parsing file %s...\n"</span>, path.c_str());</span><br><span class="line">    <span class="comment">//用于记录解析init.rc的耗时</span></span><br><span class="line">    Timer t;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line">    <span class="keyword">if</span> (!read_file(path.c_str(), &amp;data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data.push_back(<span class="string">'\n'</span>); <span class="comment">// <span class="doctag">TODO:</span> fix parse_config.</span></span><br><span class="line">    <span class="comment">//解析rc文件内容</span></span><br><span class="line">    ParseData(path, data);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sp : section_parsers_) &#123;</span><br><span class="line">        <span class="comment">//EndFile在Import_parse.cpp</span></span><br><span class="line">        sp.second-&gt;EndFile(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Turning this on and letting the INFO logging be discarded adds 0.2s to</span></span><br><span class="line">    <span class="comment">// Nexus 9 boot time, so it's disabled by default.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) DumpState();</span><br><span class="line">    <span class="comment">//打印出解析文件的耗时，用来查找耗时操作</span></span><br><span class="line">    NOTICE(<span class="string">"(Parsing %s took %.2fs.)\n"</span>, path.c_str(), t.duration());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该方法中调用的主要的方法有<code>ParseData</code>,<code>EndFile</code>接下来分别对这两部分进行分析，<code>ParseData</code>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Parser::ParseData(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data) &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> Use a parser with const input and remove this copy</span></span><br><span class="line">    <span class="comment">//copy数据</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; data_copy(data.begin(), data.end());</span><br><span class="line">    data_copy.push_back(<span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">    parse_state state;</span><br><span class="line">    state.filename = filename.c_str();</span><br><span class="line">    state.line = <span class="number">0</span>;</span><br><span class="line">    state.ptr = &amp;data_copy[<span class="number">0</span>];</span><br><span class="line">    state.nexttoken = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    SectionParser* section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//循环遍历解析init.rc文件内容</span></span><br><span class="line">        <span class="comment">//next_token在system/core/init/parse.cpp</span></span><br><span class="line">        <span class="keyword">switch</span> (next_token(&amp;state)) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_EOF:</span><br><span class="line">            <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                section_parser-&gt;EndSection();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> T_NEWLINE:</span><br><span class="line">            state.line++;</span><br><span class="line">            <span class="keyword">if</span> (args.empty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (section_parsers_.count(args[<span class="number">0</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                    <span class="comment">//Section解析完成</span></span><br><span class="line">                    section_parser-&gt;EndSection();</span><br><span class="line">                &#125;</span><br><span class="line">                section_parser = section_parsers_[args[<span class="number">0</span>]].get();</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> ret_err;</span><br><span class="line">                <span class="comment">//解析Action,Service, Import 三个Section</span></span><br><span class="line">                <span class="keyword">if</span> (!section_parser-&gt;ParseSection(args, &amp;ret_err)) &#123;</span><br><span class="line">                    parse_error(&amp;state, <span class="string">"%s\n"</span>, ret_err.c_str());</span><br><span class="line">                    section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> ret_err;</span><br><span class="line">                <span class="comment">//解析section的内容</span></span><br><span class="line">                <span class="keyword">if</span> (!section_parser-&gt;ParseLineSection(args, state.filename,</span><br><span class="line">                                                      state.line, &amp;ret_err)) &#123;</span><br><span class="line">                    parse_error(&amp;state, <span class="string">"%s\n"</span>, ret_err.c_str());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            args.clear();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_TEXT:</span><br><span class="line">            args.emplace_back(state.text);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点分析<code>!section_parser-&gt;ParseSection(args, &amp;ret_err)</code>,<code>section_parser-&gt;ParseLineSection</code>,<code>ParseSection</code>方法在<code>action</code>,<code>service</code>,<br><code>import</code>三个不同的section调用的位置不同:<br><code>action</code>–&gt;<code>aosp/system/core/init/action.cpp</code>:<br><code>service</code>–&gt;<code>aosp/system/core/init/service.cpp</code><br><code>import</code>–&gt;<code>aosp/system/core/init/import_parser.cpp</code><br>section_parser-&gt;ParseLineSection方法在<code>action</code>,<code>service</code>中嵌套在里面分析<br>依次分析这对应的三个<code>ParseSection</code>方法:  </p>
<hr>
<p><strong>action ParseSection解析</strong><br>ParseSection：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> ActionParser::ParseSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</span><br><span class="line">                                <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</span><br><span class="line">    <span class="comment">//将on后面的trigger触发执行条件保存在triggers中</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; triggers(args.begin() + <span class="number">1</span>, args.end());</span><br><span class="line">    <span class="comment">//如果一个on后面没有trigger将会报错，必须要有一个</span></span><br><span class="line">    <span class="keyword">if</span> (triggers.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        *err = <span class="string">"actions must have a trigger"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> action = <span class="built_in">std</span>::make_unique&lt;Action&gt;(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!action-&gt;InitTriggers(triggers, err)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    action_ = <span class="built_in">std</span>::move(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ParseLineSection：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> ActionParser::ParseLineSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line,</span><br><span class="line">                                    <span class="built_in">std</span>::<span class="built_in">string</span>* err) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> action_ ? action_-&gt;AddCommand(args, filename, line, err) : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用了AddCommand:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Action::AddCommand(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</span><br><span class="line">                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line, <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!function_map_) &#123;</span><br><span class="line">        *err = <span class="string">"no function map available"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.empty()) &#123;</span><br><span class="line">        *err = <span class="string">"command needed, but not provided"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> function = function_map_-&gt;FindFunction(args[<span class="number">0</span>], args.size() - <span class="number">1</span>, err);</span><br><span class="line">    <span class="keyword">if</span> (!function) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddCommand(function, args, filename, line);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着调用了AddCommand(function, args, filename, line):<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Action::AddCommand(BuiltinFunction f,</span><br><span class="line">                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</span><br><span class="line">                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line) &#123;</span><br><span class="line">    commands_.emplace_back(f, args, filename, line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>service ParseSection解析</strong><br>ParseSection:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> ServiceParser::ParseSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</span><br><span class="line">                                 <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</span><br><span class="line">    <span class="comment">//检查参数个数是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (args.size() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        *err = <span class="string">"services must have a name and a program"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = args[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//检查定义的Service名字的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (!IsValidName(name)) &#123;</span><br><span class="line">        *err = StringPrintf(<span class="string">"invalid service name '%s'"</span>, name.c_str());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取执行文件位置和参数，也就是除了service和service名其他的参数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; str_args(args.begin() + <span class="number">2</span>, args.end());</span><br><span class="line">    <span class="comment">//给service赋值</span></span><br><span class="line">    service_ = <span class="built_in">std</span>::make_unique&lt;Service&gt;(name, <span class="string">"default"</span>, str_args);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义的每个service都是一个新的进程，定义service还commands,这些commands和执行他们的方法对应关系定义是:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Service::OptionHandlerMap::Map&amp; Service::OptionHandlerMap::<span class="built_in">map</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMax = <span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;::max();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Map option_handlers = &#123;</span><br><span class="line">        &#123;<span class="string">"class"</span>,       &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleClass&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"console"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleConsole&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"critical"</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleCritical&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"disabled"</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleDisabled&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"group"</span>,       &#123;<span class="number">1</span>,     NR_SVC_SUPP_GIDS + <span class="number">1</span>, &amp;Service::HandleGroup&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"ioprio"</span>,      &#123;<span class="number">2</span>,     <span class="number">2</span>,    &amp;Service::HandleIoprio&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"keycodes"</span>,    &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleKeycodes&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"oneshot"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleOneshot&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"onrestart"</span>,   &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleOnrestart&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"seclabel"</span>,    &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleSeclabel&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"setenv"</span>,      &#123;<span class="number">2</span>,     <span class="number">2</span>,    &amp;Service::HandleSetenv&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"socket"</span>,      &#123;<span class="number">3</span>,     <span class="number">6</span>,    &amp;Service::HandleSocket&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"user"</span>,        &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleUser&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"writepid"</span>,    &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleWritepid&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> option_handlers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ParseLineSection:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> ServiceParser::ParseLineSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</span><br><span class="line">                                     <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">int</span> line,</span><br><span class="line">                                     <span class="built_in">std</span>::<span class="built_in">string</span>* err) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> service_ ? service_-&gt;HandleLine(args, err) : <span class="literal">false</span>;  <span class="comment">//service_为true, 调用HandleLine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着调用了HandleLine:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Service::HandleLine(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.empty()) &#123;</span><br><span class="line">        *err = <span class="string">"option needed, but not provided"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> OptionHandlerMap handler_map;   <span class="comment">//获得option对应的函数表</span></span><br><span class="line">    <span class="keyword">auto</span> handler = handler_map.FindFunction(args[<span class="number">0</span>], args.size() - <span class="number">1</span>, err); <span class="comment">//根据option获取对应的函数名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*handler)(args, err);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>EndSection:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ServiceParser::EndSection() &#123;</span><br><span class="line">    <span class="keyword">if</span> (service_) &#123;</span><br><span class="line">        ServiceManager::GetInstance().AddService(<span class="built_in">std</span>::move(service_));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ServiceManager::AddService(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Service&gt; service) &#123;</span><br><span class="line">    Service* old_service = FindServiceByName(service-&gt;name());</span><br><span class="line">    <span class="keyword">if</span> (old_service) &#123;    <span class="comment">//service已经被定义过了就抛弃</span></span><br><span class="line">        ERROR(<span class="string">"ignored duplicate definition of service '%s'"</span>,</span><br><span class="line">              service-&gt;name().c_str());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    services_.emplace_back(<span class="built_in">std</span>::move(service));  <span class="comment">//将service添加services_列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>import ParseSection解析</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> ImportParser::ParseSection(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,</span><br><span class="line">                                <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</span><br><span class="line">    <span class="comment">//import 命令是2参数的，如果参数个数不对就直接报错</span></span><br><span class="line">    <span class="keyword">if</span> (args.size() != <span class="number">2</span>) &#123;</span><br><span class="line">        *err = <span class="string">"single argument needed for import\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> conf_file;</span><br><span class="line">    <span class="comment">//第一个参数都是import，args[1]才是要导入的配置文件conf_file</span></span><br><span class="line">    <span class="keyword">bool</span> ret = expand_props(args[<span class="number">1</span>], &amp;conf_file);</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        *err = <span class="string">"error while expanding import"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INFO(<span class="string">"Added '%s' to import list\n"</span>, conf_file.c_str());</span><br><span class="line">    <span class="comment">//将所有的conf_file添加到imports_列表</span></span><br><span class="line">    imports_.emplace_back(<span class="built_in">std</span>::move(conf_file));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>终于把<code>ParseData</code>方法粗略的过了一遍，接下来分析<code>EndFile</code>，该方法其实就在<code>import_parser.cpp</code>中:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> ImportParser::EndFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename) &#123;</span><br><span class="line">    <span class="keyword">auto</span> current_imports = <span class="built_in">std</span>::move(imports_);  <span class="comment">//获取imports_</span></span><br><span class="line">    imports_.clear();   <span class="comment">//将imports_列表清空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : current_imports) &#123;  <span class="comment">//遍历列表</span></span><br><span class="line">        <span class="keyword">if</span> (!Parser::GetInstance().ParseConfig(s)) &#123;   <span class="comment">//调用ParseConfig函数,对其他配置进行解析, 流程遇上面的相同</span></span><br><span class="line">            ERROR(<span class="string">"could not import file '%s' from '%s': %s\n"</span>,</span><br><span class="line">                  s.c_str(), filename.c_str(), strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，init.rc文件的解析工作完成，接下来的的工作就是执行这些配置，由于init.rc里面配置了太多，接下来以Zygote这个service为例，分析．<br>在<code>init.rc</code>里<code>import /init.${ro.zygote}.rc</code>,这就引入了不同的zygote配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init.zygote32_64.rc  init.zygote32.rc     init.zygote64_32.rc  init.zygote64.rc</span><br></pre></td></tr></table></figure></p>
<p>这里以<code>init.zygote32.rc</code>为例:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>zygote是进程</span><br><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    #启动组名，同样名字的一起启动</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    #onrestart表示zygote重启时需要执行的命令</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks</span><br></pre></td></tr></table></figure></p>
<p>通过对这个叫zygote的service的解析之后,在init.rc配置文件中配置了怎么去启动zygote:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on nonencrypted</span><br><span class="line">    # A/B update verifier that marks a successful boot.</span><br><span class="line">    exec - root -- /system/bin/update_verifier nonencrypted</span><br><span class="line">    #通过class_start方法启动了main(这就是zygote的中配置的)</span><br><span class="line">    class_start main</span><br><span class="line">    class_start late_start</span><br></pre></td></tr></table></figure></p>
<p>找到<code>class_start</code>对应执行的函数就可以接着分析了，对应关系就在<code>aosp/system/core/init/builtins.cpp</code>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ltinFunctionMap::Map&amp; BuiltinFunctionMap::<span class="built_in">map</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMax = <span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;::max();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Map builtin_functions = &#123;</span><br><span class="line">        &#123;<span class="string">"bootchart_init"</span>,          &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_bootchart_init&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"chmod"</span>,                   &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_chmod&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"chown"</span>,                   &#123;<span class="number">2</span>,     <span class="number">3</span>,    do_chown&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_reset"</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_class_reset&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_start"</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_class_start&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_stop"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_class_stop&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"copy"</span>,                    &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_copy&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"domainname"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_domainname&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"enable"</span>,                  &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_enable&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"exec"</span>,                    &#123;<span class="number">1</span>,     kMax, do_exec&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"export"</span>,                  &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_export&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"hostname"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_hostname&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"ifup"</span>,                    &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_ifup&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"init_user0"</span>,              &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_init_user0&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"insmod"</span>,                  &#123;<span class="number">1</span>,     kMax, do_insmod&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"installkey"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_installkey&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"load_persist_props"</span>,      &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_load_persist_props&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"load_system_props"</span>,       &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_load_system_props&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"loglevel"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_loglevel&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mkdir"</span>,                   &#123;<span class="number">1</span>,     <span class="number">4</span>,    do_mkdir&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mount_all"</span>,               &#123;<span class="number">1</span>,     kMax, do_mount_all&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mount"</span>,                   &#123;<span class="number">3</span>,     kMax, do_mount&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"powerctl"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_powerctl&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restart"</span>,                 &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_restart&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restorecon"</span>,              &#123;<span class="number">1</span>,     kMax, do_restorecon&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restorecon_recursive"</span>,    &#123;<span class="number">1</span>,     kMax, do_restorecon_recursive&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"rm"</span>,                      &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_rm&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"rmdir"</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_rmdir&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"setprop"</span>,                 &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_setprop&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"setrlimit"</span>,               &#123;<span class="number">3</span>,     <span class="number">3</span>,    do_setrlimit&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"start"</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_start&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"stop"</span>,                    &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_stop&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"swapon_all"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_swapon_all&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"symlink"</span>,                 &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_symlink&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"sysclktz"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_sysclktz&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"trigger"</span>,                 &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_trigger&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"verity_load_state"</span>,       &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_verity_load_state&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"verity_update_state"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_verity_update_state&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"wait"</span>,                    &#123;<span class="number">1</span>,     <span class="number">2</span>,    do_wait&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"write"</span>,                   &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_write&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> builtin_functions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于在rc配置文件中的commands都对应一个方法函数，可以通过<code>grep -nr &quot;&lt;command&gt;&quot; .</code>在<code>aosp/system/core/init/</code>中搜索．<br>找到需要的对应关系:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;class_start&quot;,             &#123;1,     1,    do_class_start&#125;&#125;,</span><br></pre></td></tr></table></figure></p>
<p>进入do_class_start方法:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_class_start</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* Starting a class does not start services</span></span><br><span class="line"><span class="comment">         * which are explicitly disabled.  They must</span></span><br><span class="line"><span class="comment">         * be started individually.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    ServiceManager::GetInstance().</span><br><span class="line">        ForEachServiceInClass(args[<span class="number">1</span>], [] (Service* s) &#123; s-&gt;StartIfNotDisabled(); &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着看StartIfNotDisabled(),位置<code>aosp/system/core/init/service.cpp</code>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Service::StartIfNotDisabled() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(flags_ &amp; SVC_DISABLED)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Start();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags_ |= SVC_DISABLED_START;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还调了Start()，接着看吧:<br><code></code>cpp<br>bool Service::Start() {<br>   ……<br>   //判断需要启动的Service的对应的执行文件是否存在，不存在则不启动该Service<br>   struct stat sb;<br>    if (stat(args_[0].c_str(), &amp;sb) == -1) {<br>        ERROR(“cannot find ‘%s’ (%s), disabling ‘%s’\n”,<br>              args_[0].c_str(), strerror(errno), name_.c_str());<br>        flags_ |= SVC_DISABLED;<br>        return false;<br>    }<br>    ……<br>    //每一个service都是一个新进程，必然需要fork<br>    pid_t pid = fork();<br>    if (pid == 0) {<br>        umask(077);</p>
<pre><code>    for (const auto&amp; ei : envvars_) {
        add_environment(ei.name.c_str(), ei.value.c_str());
    }

    for (const auto&amp; si : sockets_) {
        int socket_type = ((si.type == &quot;stream&quot; ? SOCK_STREAM :
                            (si.type == &quot;dgram&quot; ? SOCK_DGRAM :
                             SOCK_SEQPACKET)));
        const char* socketcon =
            !si.socketcon.empty() ? si.socketcon.c_str() : scon.c_str();

        int s = create_socket(si.name.c_str(), socket_type, si.perm,
                              si.uid, si.gid, socketcon);
        if (s &gt;= 0) {
            PublishSocket(si.name, s);
        }
    }
    ......
    //execve执行程序，在`init.zygote32.rc`里写了zygote的进程程序的位置以及参数
   if (execve(args_[0].c_str(), (char**) &amp;strs[0], (char**) ENV) &lt; 0) {
        ERROR(&quot;cannot execve(&apos;%s&apos;): %s\n&quot;, args_[0].c_str(), strerror(errno));
    }

    _exit(127);
}
......
NotifyStateChange(&quot;running&quot;);
return true;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在fork出来的新的子进程里就会进入java层面，`aosp/frameworks/base/cmds/app_process/app_main.cpp`的main()函数:  </span><br><span class="line">```C++</span><br><span class="line">int main(int argc, char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) &lt; 0) &#123;</span><br><span class="line">        // Older kernels don&apos;t understand PR_SET_NO_NEW_PRIVS and return</span><br><span class="line">        // EINVAL. Don&apos;t die on such kernels.</span><br><span class="line">        if (errno != EINVAL) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(&quot;PR_SET_NO_NEW_PRIVS failed: %s&quot;, strerror(errno));</span><br><span class="line">            return 12;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</span><br><span class="line">    // Process command line arguments</span><br><span class="line">    // ignore argv[0]</span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line">    ......</span><br><span class="line">    if (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.string());</span><br><span class="line">        //设置进程名为zygote</span><br><span class="line">        set_process_name(niceName.string());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (zygote) &#123;//经过一系列的初始化和参数判断，会调用到这里</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);</span><br><span class="line">    &#125; else if (className) &#123;//与上面的启动方式对比,两者在native层实现相同,区别在java层,ZygoteInit比RuntimeInit多做不少事情</span><br><span class="line">        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);</span><br><span class="line">        return 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终使用runtime.start执行”com.android.internal.os.ZygoteInit”,接着分析runtime.start的具体实现.runtime是AppRuntime类,可是AppRuntime<br>类没有start方法,于是找到AppRuntime的父类AndroidRuntime的start方法:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGD(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n"</span>,</span><br><span class="line">            className != <span class="literal">NULL</span> ? className : <span class="string">"(unknown)"</span>, getuid());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">"start-system-server"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 'startSystemServer == true' means runtime is obsolete and not run from</span></span><br><span class="line"><span class="comment">     * init.rc anymore, so we print out the boot start event here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options[i] == startSystemServer) &#123;</span><br><span class="line">           <span class="comment">/* track our progress through the boot sequence */</span></span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</span><br><span class="line">           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">"ANDROID_ROOT"</span>);</span><br><span class="line">    <span class="keyword">if</span> (rootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rootDir = <span class="string">"/system"</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasDir(<span class="string">"/system"</span>)) &#123;</span><br><span class="line">            LOG_FATAL(<span class="string">"No root directory specified, and /android does not exist."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setenv(<span class="string">"ANDROID_ROOT"</span>, rootDir, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//const char* kernelHack = getenv("LD_ASSUME_KERNEL");</span></span><br><span class="line">    <span class="comment">//ALOGD("Found LD_ASSUME_KERNEL='%s'\n", kernelHack);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">//启动虚拟机</span></span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line">    <span class="comment">//注册JNI方法到虚拟机</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We want to call main() with a String array with arguments in it.</span></span><br><span class="line"><span class="comment">     * At present we have two arguments, the class name and an option string.</span></span><br><span class="line"><span class="comment">     * Create an array to hold them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//启动com.android.internal.os.ZygoteInit</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">                threadExitUncaughtException(env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">"Shutting down VM\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">        ALOGW(<span class="string">"Warning: unable to detach main thread\n"</span>);</span><br><span class="line">    mVMShutdown = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">        ALOGW(<span class="string">"Warning: VM did not shut down cleanly\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法做了一下几件事:  </p>
<ul>
<li>启动java虚拟机   </li>
<li>将JNI方法注册到java虚拟机  </li>
<li>进入到ZygoteInit.java的main()方法  </li>
</ul>
<p>进入到ZygoteInit.java也就是进入到java层,在分析Zygote的启动过程中再接着分析,这里告一段落.需要注意的是Zygote进程的启动是在解析init.Zygote32.rc开始的,<br>到这里还没有完成,只是到这,C++层的执行完了.在另一篇介绍Zygote启动的文章中,再接着ZygoteInit.java的main()分析,从java层分析.在C++层只是讲Zygote进程创建,<br>但是什么活也没干,干活是在java层面,因此文章将zygote进程的分析从此处分成两个部分,同事也是为了让文章内容是以init进程分析为主.  </p>
<p>###总结<br>本文主要分析了,init进程的启动,主要分析了一下内容:   </p>
<ul>
<li>init进程启动属性服务的过程,分析了属性服务建立过程  </li>
<li>init进程对rc配置文件的解析,分为对import,action,service,commands的的解析  </li>
<li>以zygote进程为例子,分析了作为service被解析之后的执行过程,一直到调用到java层的过程  </li>
</ul>
<p>###参考blog<br><a href="http://blog.csdn.net/fu_kevin0606/article/details/53339001" target="_blank" rel="noopener">http://blog.csdn.net/fu_kevin0606/article/details/53339001</a><br><a href="http://blog.csdn.net/innost/article/details/47204675" target="_blank" rel="noopener">http://blog.csdn.net/innost/article/details/47204675</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/38102011" target="_blank" rel="noopener">http://blog.csdn.net/luoshengyang/article/details/38102011</a><br><a href="http://blog.csdn.net/itachi85/article/details/54783506" target="_blank" rel="noopener">http://blog.csdn.net/itachi85/article/details/54783506</a><br><a href="http://blog.csdn.net/kc58236582/article/details/52247547" target="_blank" rel="noopener">http://blog.csdn.net/kc58236582/article/details/52247547</a><br><a href="http://blog.csdn.net/fu_kevin0606/article/details/53320515" target="_blank" rel="noopener">http://blog.csdn.net/fu_kevin0606/article/details/53320515</a>  </p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Michael</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lqktz.github.io/2019/04/10/init进程启动源码分析/">https://lqktz.github.io/2019/04/10/init进程启动源码分析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lqktz.github.io">Michael Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/10/Android-O-耗电统计/"><i class="fa fa-chevron-left">  </i><span>Android O电量统计</span></a></div><div class="next-post pull-right"><a href="/2019/04/10/androidstart/"><span>Android开机总体流程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Michael</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to Michael <a href="http://lqktz.github.io/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>